<!DOCTYPE html>
<html lang="de">
<head>
<link rel="manifest" href="manifest.json">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Oma Display V10</title>
         
<style>
    /* === GRUNDLAGEN (DARK MODE ONLY) === */
    :root { 
        --bg: #000000; 
        --card-bg: #1a1a1a; 
        --text: #ffffff; 
        --text-sub: #aaaaaa;
        --accent: #4cd137; 
        --stop-color: #ff4757;
    }
    
    * { box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
    
    body { 
        margin: 0; padding: 0; 
        background-color: var(--bg); 
        color: var(--text); 
        font-family: sans-serif; 
        overflow: hidden; 
        height: 100vh; width: 100vw; 
        display: flex; flex-direction: column; 
    }

    /* === 1. AMBIENT BACKGROUND (Lebendiger Hintergrund) === */
    #ambientBg {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-size: cover; background-position: center;
        filter: blur(40px) brightness(0.4); /* Stark unscharf & abgedunkelt */
        z-index: 0;
        transition: background-image 1s ease-in-out;
    }

    /* === 2. HEADER MIT PLAY BUTTON === */
    #header {
        height: 80px; width: 100%;
        display: flex; align-items: center; justify-content: space-between;
        padding: 0 20px;
        z-index: 20; /* √úber dem Background */
        background: rgba(0,0,0,0.3); /* Leicht transparent */
        backdrop-filter: blur(10px);
    }

    #metaInfo { font-size: 1.8vh; color: #ddd; text-align: left; }
    
    /* Der gro√üe Play-Button in der Mitte */
    #playBtn {
        background: var(--accent); color: white;
        border: none; border-radius: 30px;
        padding: 10px 40px;
        font-size: 20px; font-weight: bold;
        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        cursor: pointer;
        display: flex; align-items: center; gap: 10px;
        transition: transform 0.1s, background 0.3s;
    }
    #playBtn:active { transform: scale(0.95); }
    #playBtn.stop-mode { background: var(--stop-color); }

    /* === 3. HAUPTBEREICH (KARTE) === */
    #displayArea {
        flex: 1; z-index: 10;
        display: flex; align-items: center; justify-content: center;
        padding: 20px; position: relative;
    }

    .card {
        background: var(--card-bg);
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0,0,0,0.6);
        width: 100%; max-width: 1000px;
        max-height: 85vh;
        display: flex; overflow: hidden;
        transition: transform 0.3s ease;
    }

    /* Layout Logik: Querformat (Tablet Standard) */
    @media (orientation: landscape) {
        .card { flex-direction: row; }
        .card-img-area { width: 55%; height: 100%; }
        .card-text-area { width: 45%; height: 100%; border-left: 1px solid #333; }
    }
    
    /* Layout Logik: Hochformat (Tablet gedreht) */
    @media (orientation: portrait) {
        .card { flex-direction: column; }
        .card-img-area { width: 100%; height: 50%; }
        .card-text-area { width: 100%; height: 50%; border-top: 1px solid #333; }
    }

    /* Bildbereich in der Karte */
    .card-img-area {
        background: black;
        display: flex; align-items: center; justify-content: center;
        position: relative;
    }
    #cardImg {
        max-width: 100%; max-height: 100%;
        object-fit: contain;
        cursor: pointer; /* Zeigt an, dass man klicken kann (Zoom) */
    }

    /* Textbereich in der Karte */
    .card-text-area {
        padding: 30px;
        display: flex; flex-direction: column;
        justify-content: flex-start; /* Text oben b√ºndig */
    }

    #smartDate {
        color: var(--accent);
        font-size: 2vh; font-weight: bold; text-transform: uppercase;
        margin-bottom: 10px; letter-spacing: 1px;
    }

    #cardText {
        font-size: 3.5vh; line-height: 1.4; color: #fff;
        overflow-y: auto; flex: 1; /* F√ºllt den Rest */
        white-space: pre-wrap; /* Zeilenumbr√ºche erhalten */
    }

    /* === 4. NAVIGATION PFEILE (NEU) === */
    .nav-arrow {
        position: absolute; top: 50%; transform: translateY(-50%);
        font-size: 80px; color: rgba(255,255,255,0.6);
        cursor: pointer; z-index: 50; padding: 20px;
        transition: color 0.2s, transform 0.2s;
        text-shadow: 0 0 20px rgba(0,0,0,0.8);
    }
    .nav-arrow:active { color: white; transform: translateY(-50%) scale(1.2); }
    #btnPrev { left: 10px; }
    #btnNext { right: 10px; }

    /* === EXTRAS: Lightbox & Overlays (bleiben √§hnlich) === */
    #lightbox { 
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: black; z-index: 1000; align-items: center; justify-content: center;
    }
    #lightbox img { max-width: 100%; max-height: 100%; object-fit: contain; }
    
    /* Setup Screen & Co bleiben unver√§ndert im Style, hier nicht extra aufgef√ºhrt */
</style>

</head>
<body>
<body>
    <!-- 1. Hintergrund-Ebene -->
    <div id="ambientBg"></div>

    <!-- 2. Header mit Play Button -->
    <div id="header">
        <div id="metaInfo">Oma Display V12</div> <!-- Platzhalter links -->
        
        <button id="playBtn" onclick="toggleSlideshow()">
            <span id="playIcon">‚ñ∂</span> <span id="playText">Abspielen</span>
        </button>
        
        <!-- Status & Reload (klein rechts) -->
        <div style="display:flex; gap:10px;">
            <div id="statusLight" onclick="handleSecretClick()" style="width:15px; height:15px; border-radius:50%; background:orange; border:2px solid white;"></div>
            <div onclick="location.reload()" style="color:#666; font-size:20px; cursor:pointer;">‚Üª</div>
        </div>
    </div>

    <!-- 3. Hauptbereich mit Karte & Pfeilen -->
    <div id="displayArea">
        
        <!-- Pfeil Links -->
        <div id="btnPrev" class="nav-arrow" onclick="prevMsg()">‚ùÆ</div>

        <!-- Die Karte -->
        <div class="card">
            <div class="card-img-area">
                <img id="cardImg" src="" onclick="openLightbox()" style="display:none;">
            </div>
            <div class="card-text-area">
                <div id="smartDate">Lade...</div>
                <div id="cardText">Warte auf Nachrichten...</div>
                <div style="margin-top:auto; font-size:1.5vh; color:#666; padding-top:10px;" id="msgCounter"></div>
            </div>
        </div>

        <!-- Pfeil Rechts -->
        <div id="btnNext" class="nav-arrow" onclick="nextMsg()">‚ùØ</div>
    </div>

    <!-- 4. Overlays (Lightbox etc. - aus deinem alten Code √ºbernehmen oder hier kurz halten) -->
    <div id="lightbox" onclick="closeLightbox()"><img id="lightboxImg" src=""></div>
    <div id="newMsgOverlay" onclick="dismissNotification()" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:2000; flex-direction:column; align-items:center; justify-content:center; color:white;">
        <div style="font-size:100px;">üì©</div>
        <h1>Neue Nachricht!</h1>
        <p>Tippen zum Ansehen</p>
    </div>
    
    <!-- Setup Screen & Debug Log hier einf√ºgen (oder lassen wie im alten Code) -->
    <div id="debugLog" style="display:none; position:fixed; bottom:0; left:0; height:100px; width:100%; background:rgba(0,0,0,0.8); color:lime; overflow:scroll; z-index:9000;"></div>
    
<script>
// === 0. MAGIC LINK CHECK ===
  // === 0. MAGIC LINK CHECK (MIT √úBERSCHREIB-SCHUTZ) ===
    (function checkMagicLink() {
        const hash = window.location.hash;
        if (hash.startsWith('#config=')) {
            try {
                const b64 = hash.substring(8);
                const json = JSON.parse(atob(b64));
                
                // Wir laden zuerst die existierende Config, um die ID zu retten
                let existingConf = {};
                try { 
                    existingConf = JSON.parse(localStorage.getItem('oma_conf_v10') || '{}'); 
                } catch(e) {}

                // LOGIK: Nimm die ID aus dem Link nur, wenn da wirklich eine drin steht.
                // Sonst behalte die ID, die wir schon lokal haben (durch Umbenennung).
                const finalDeviceId = json.did || existingConf.deviceId;

                const newConf = {
                    ghUser: json.gu,
                    ghRepo: json.gr,
                    ghToken: json.gt,
                    ntfyTopic: json.t,
                    pass: json.p,
                    deviceId: finalDeviceId // <--- HIER IST DER FIX
                };

                if(newConf.ghUser && newConf.ntfyTopic && newConf.pass) {
                    localStorage.setItem('oma_conf_v10', JSON.stringify(newConf));
                    
                    // URL s√§ubern, damit beim n√§chsten Reload nicht wieder importiert wird
                    // (Wichtig, falls man die Seite ohne Hash neu l√§dt)
                    history.replaceState(null, null, window.location.pathname);
                    
                    // Wir laden NICHT neu, wenn wir eh schon da sind, um Loops zu vermeiden,
                    // aber initialisieren alles neu.
                    if (existingConf.ntfyTopic !== newConf.ntfyTopic) {
                        location.reload(); 
                    }
                } else { 
                    alert("Link unvollst√§ndig."); 
                }
            } catch (e) { 
                console.error("Link Error", e); 
                alert("Link fehlerhaft."); 
            }
        }
    })();
    // === 1. BASIC UTILS ===
    function log(msg) { console.log(msg); const d=document.getElementById('debugLog'); if(d) d.innerHTML=`> ${msg}<br>`+d.innerHTML; }
    function toggleDebug() { const d=document.getElementById('debugLog'); d.style.display=d.style.display==='none'?'block':'none'; }


let config = JSON.parse(localStorage.getItem('oma_conf_v10')) || null;
    let messages = []; 
    // NEU: Eine Merkliste f√ºr gel√∂schte Timestamps
    let hiddenRegistry = new Set(); 
    let currentIndex = 0;
    
    // Web Crypto Setup
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    async function getKey(password, salt) {
        const k = await window.crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]);
        return window.crypto.subtle.deriveKey({name:"PBKDF2", salt:salt, iterations:100000, hash:"SHA-256"}, k, {name:"AES-GCM", length:256}, true, ["encrypt","decrypt"]);
    }

// ... getKey bleibt ...

    // NEU: Bin√§rdaten entschl√ºsseln
    async function decryptData(buffer, password) {
        try {
            const bytes = new Uint8Array(buffer);
            // Salt (16) + IV (12) extrahieren
            const s = bytes.slice(0, 16);
            const iv = bytes.slice(16, 28);
            const data = bytes.slice(28); // Der Rest ist die verschl√ºsselte Datei
            
            const k = await getKey(password, s);
            return await window.crypto.subtle.decrypt({name: "AES-GCM", iv: iv}, k, data);
        } catch(e) { 
            console.error("Entschl√ºsselung fehlgeschlagen:", e);
            return null; 
        }
    }

    // Hilfsfunktion: Base64 String zu ArrayBuffer
    function base64ToBuffer(b64) {
        const bin = atob(b64);
        const len = bin.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
        return bytes.buffer;
    }
    
async function processAndAdd(item, silent = false) {
        // 1. TIMESTAMP NORMALISIEREN
        let safeTs = item.ts;
        if (safeTs < 100000000000) safeTs *= 1000;
        
        // 2. ZOMBIE CHECK
        if (item.hidden || hiddenRegistry.has(safeTs)) {
            hiddenRegistry.add(safeTs); 
            return; 
        }
        
        // 3. DUPLIKAT CHECK
        const exists = messages.some(m => Math.abs(m.timestamp - safeTs) < 2000);
        if (exists) return;

        let plain = { sender: '?', text: 'Fehler', image: null };
        
        // 4. INHALT ENTSCHL√úSSELN
        if (!item.enc) return;
        const jsonStr = await decryptStr(item.enc, config.pass);
        
        if(jsonStr) {
            try {
                const content = JSON.parse(jsonStr);
                plain.sender = content.sender;
                plain.text = content.text;
                if (content.image || content.img) plain.image = content.image || content.img;
            } catch(e) { plain.text = "Format Fehler"; }
        } else { return; }

        // 5. BILD LADEN
        if (item.img) {
            let encryptedBuffer = null;
            if (item.img.startsWith('http')) {
                try {
                    const resp = await fetch(item.img);
                    encryptedBuffer = await resp.arrayBuffer();
                } catch(e) {}
            } else {
                encryptedBuffer = base64ToBuffer(item.img);
            }

            if (encryptedBuffer) {
                const decryptedImageBuffer = await decryptData(encryptedBuffer, config.pass);
                if (decryptedImageBuffer) {
                    const blob = new Blob([decryptedImageBuffer], {type: 'image/jpeg'});
                    plain.image = URL.createObjectURL(blob);
                }
            }
        }

        messages.push({
            timestamp: safeTs,
            sender: plain.sender,
            text: plain.text,
            image: plain.image
        });
        
        // === HIER IST DIE √ÑNDERUNG: NEUESTE ZUERST ===
        // b.timestamp - a.timestamp sorgt f√ºr absteigende Sortierung (Neu -> Alt)
        messages.sort((a,b) => b.timestamp - a.timestamp);
        
        if (!silent) {
            // Bei neuer Nachricht: Springe immer auf Index 0 (das ist jetzt die Neueste!)
            currentIndex = 0; 
            updateDisplay(); 
            checkNewMessage(safeTs);
        }
    }   
    
    
    async function decryptStr(base64Data, password) {
        try {
            if(!base64Data) return null;
            const bin = atob(base64Data);
            const bytes = new Uint8Array(bin.length);
            for(let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
            const salt=bytes.slice(0,16), iv=bytes.slice(16,28), data=bytes.slice(28);
            const key = await getKey(password, salt);
            const decrypted = await window.crypto.subtle.decrypt({name:"AES-GCM", iv:iv}, key, data);
            return dec.decode(decrypted);
        } catch(e) { console.error(e); return null; }
    }

    // Falls Config da ist -> Direkt start
    if(config) {
        document.getElementById('setupScreen').style.display = 'none';
        startApp();
    } else {
        // Setup Formular Felder f√ºllen falls vorhanden
        if(config) {
            document.getElementById('ghUser').value = config.ghUser || "";
            document.getElementById('setupTopic').value = config.ntfyTopic || "";
        }
    }

  // === LOGGING & COOLDOWN LOGIC ===
    
    // Einstellung: Wie lange (in ms) Ruhe geben nach einem Log?
    // 1000 * 60 * 60 = 1 Stunde
    const LOG_COOLDOWN = 1000 * 60 * 60; 

    function smartLog(msg) {
        // 1. History aus dem Speicher laden
        let history = {};
        try { 
            history = JSON.parse(localStorage.getItem('oma_log_history') || '{}'); 
        } catch(e) {}

        const now = Date.now();
        const lastSent = history[msg.timestamp] || 0;

        // 2. Check: Ist die Stunde schon rum?
        if (now - lastSent < LOG_COOLDOWN) {
            // Noch im Cooldown -> ABBRUCH, nichts senden
            return;
        }

        // 3. Wenn wir hier sind: Senden erlaubt!
        sendReadReceipt(msg);

        // 4. Update: "Habe jetzt gesendet" speichern
        history[msg.timestamp] = now;
        localStorage.setItem('oma_log_history', JSON.stringify(history));
    }

    // Die reine Sende-Funktion (ohne Timer, ohne Checks)
    async function sendReadReceipt(msg) {
        // Nur senden, wenn eine DeviceID konfiguriert ist
        if(!config.deviceId) return; 

        // Verschl√ºsselung vorbereiten
        // (Falls encryptStr fehlt, muss es weiter oben definiert sein, siehe vorherige Schritte)
        const logData = {
            type: "read",
            ts: Math.floor(Date.now() / 1000),
            dev: config.deviceId,
            sender: msg.sender,
            msg_ts: msg.timestamp,
            // Snippet k√ºrzen
            snippet: msg.text ? (msg.text.substring(0, 15) + (msg.text.length>15?"...":"")) : "Bild"
        };

        const encLog = await encryptStr(JSON.stringify(logData), config.pass);
        
        if(encLog) {
            // Senden an ntfy
            fetch(`https://ntfy.sh/${config.ntfyTopic}`, {
                method: 'POST',
                body: "LOG_ENTRY", 
                headers: { 'Title': encLog }
            }).then(() => log("Log gesendet.")).catch(e => console.error(e));
        }
    }
    
    // Hilfsfunktion: Text verschl√ºsseln (falls noch nicht vorhanden)
    async function encryptStr(plainText, password) {
        try {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const k = await getKey(password, salt);
            // HIER IST DER FEHLER: da stand "key" statt "k"
            const encData = await window.crypto.subtle.encrypt({name:"AES-GCM", iv:iv}, k, enc.encode(plainText));
            const u8 = new Uint8Array(16 + 12 + encData.byteLength);
            u8.set(salt, 0); u8.set(iv, 16); u8.set(new Uint8Array(encData), 28);
            return btoa(String.fromCharCode(...u8));
        } catch(e) { console.error("Encrypt Error:", e); return null; } // Habe hier auch ein console.error eingebaut
    }

    function saveSetup() {
        const c = {
            ghUser: document.getElementById('ghUser').value.trim(),
            ghRepo: document.getElementById('ghRepo').value.trim(),
            ghToken: document.getElementById('ghToken').value.trim(),
            ntfyTopic: document.getElementById('setupTopic').value.trim(),
            pass: document.getElementById('setupPass').value.trim()
        };
        if(!c.ghUser || !c.ghToken || !c.ntfyTopic || !c.pass) return alert("Alles ausf√ºllen!");
        localStorage.setItem('oma_conf_v10', JSON.stringify(c));
        location.reload();
    }
    function resetApp() { localStorage.removeItem('oma_conf_v10'); location.reload(); }

    // === 2. HAUPTLOGIK ===
   
    async function startApp() {
        await loadGitHubArchive();
        connectNtfy();
        startConnectionWatchdog(); // <--- DIESE ZEILE IST WICHTIG!
    }

async function loadGitHubArchive() {
        log("Lade GitHub Archiv...");
        try {
            const timeParam = new Date().getTime();
            const url = `https://api.github.com/repos/${config.ghUser}/${config.ghRepo}/contents/messages.json?t=${timeParam}`;
            
            const resp = await fetch(url, { 
                cache: "no-store", 
                headers: { 'Authorization': `Bearer ${config.ghToken}`, 'Accept': 'application/vnd.github.v3.raw' }
            });
            
            if(resp.ok) {
                const archiveData = await resp.json();
                if (Array.isArray(archiveData)) {
                    log(`${archiveData.length} Nachrichten im Archiv.`);
                    
                    for(let item of archiveData) {
                        if(item.hidden) hiddenRegistry.add(item.timestamp);
                        
                        await processAndAdd({
                            ts: item.timestamp,
                            enc: item.enc,
                            img: item.img,
                            hidden: item.hidden 
                        }, true); // Silent = true
                    }
                    
                    // === HIER DIE √ÑNDERUNG ===
                    // Nach dem Laden setzen wir den Index auf 0 (die Neueste)
                    currentIndex = 0;
                    updateDisplay();
                }
            } else { log("Archiv leer/Fehler."); }
        } catch(e) { log("GitHub Fehler: " + e.message); }
    }

    // === GLOBALE VARIABLEN F√úR DIE VERBINDUNG ===
    let es = null;
    let connectionWatchdog = null;

    // === VERBINDUNGSAUFBAU MIT RECONNECT-SCHUTZ ===
    function connectNtfy() {
        // 1. Alte Verbindung sauber schlie√üen, falls vorhanden
        if (es) {
            try { es.close(); } catch(e) {}
            es = null;
        }

        log(`Verbinde zu: ${config.ntfyTopic}...`);
        // Status auf Orange (Verbinde...)
        const statusEl = document.getElementById('statusLight');
        if(statusEl) statusEl.style.background = 'orange';

        // 2. Neue Verbindung √∂ffnen
        es = new EventSource(`https://ntfy.sh/${config.ntfyTopic}/sse?since=all`);
        
        es.onopen = () => {
            log("Verbindung stabil ‚úÖ");
            if(statusEl) statusEl.style.background = '#4cd137'; // Gr√ºn
        };

        es.onerror = (err) => {
            // Fehler anzeigen, aber keinen sofortigen Loop starten (macht der Watchdog)
            if(statusEl) statusEl.style.background = 'red';
        };

        es.onmessage = async (e) => {
            const data = JSON.parse(e.data);
            
            // Keepalive Events ignorieren
            if (data.event === 'keepalive') return;

            const msgTimestamp = data.time;

            if (data.event === 'message') {
                
                if (data.message === "LOG_ENTRY") return; 

                // === ADMIN COMMANDS ===
                try {
                    // Pr√ºfen ob es JSON ist (Command)
                    const cmdData = JSON.parse(data.message);
                    
                    // 1. TARGET CHECK (Bin ich gemeint?)
                    const myId = config.deviceId || "unbekannt";
                    const target = cmdData.target || "ALL"; // Default: Alle
                    
                    // Wenn Target NICHT "ALL" ist UND NICHT meine ID -> Ignorieren
                    if (target !== "ALL" && target !== myId) {
                        return; 
                    }

                    // 2. DELETE (Immer erlaubt, global)
                    if (cmdData.cmd === 'DELETE' && cmdData.ts) {
                        log(`CMD: L√∂sche ${cmdData.ts}`);
                        messages = messages.filter(m => m.timestamp !== cmdData.ts);
                        if (currentIndex >= messages.length) currentIndex = Math.max(0, messages.length - 1);
                        updateDisplay();
                        return; 
                    }

                    // 3. SYSTEM BEFEHLE (Nur einmal pro Timestamp!)
                    const lastCmdTs = parseInt(localStorage.getItem('oma_last_cmd_ts') || '0');
                    if (msgTimestamp <= lastCmdTs) return; // Schon erledigt

                    // Merken, dass wir diesen Befehl ausgef√ºhrt haben
                    localStorage.setItem('oma_last_cmd_ts', msgTimestamp);

                    // --- PING (Status senden) ---
                    if (cmdData.cmd === 'PING') {
                        // Antwortet asynchron in die devices.json
                        registerSelfOnGitHub();
                        return;
                    }

                    // --- RENAME (Umbenennen) ---
                    if (cmdData.cmd === 'RENAME_DEVICE') {
                        if (target === "ALL") return; // Sicherheits-Check
                        if (cmdData.newId) {
                            config.deviceId = cmdData.newId;
                            localStorage.setItem('oma_conf_v10', JSON.stringify(config));
                            log(`Ger√§t umbenannt zu: ${cmdData.newId}`);
                            setTimeout(() => location.reload(), 2000);
                        }
                        return;
                    }

                    // --- RELOAD ---
                    if (cmdData.cmd === 'RELOAD') {
                        log("CMD: Reload");
                        location.reload();
                        return;
                    }

                    // --- TRIGGER ALARM ---
                    if (cmdData.cmd === 'TRIGGER_NEW') {
                        log("CMD: Alarm");
                        if(messages.length > 0) {
                            currentIndex = messages.length - 1;
                            updateDisplay();
                        }
                        // Alarm erzwingen (auch nachts, wenn explizit gefordert)
                        document.getElementById('newMsgOverlay').style.display = 'flex';
                        wakeUp(); // Screensaver beenden
                        return;
                    }

                    // --- SCHRIFT ---
                    if (cmdData.cmd === 'SET_FONTSIZE') {
                        const size = parseFloat(cmdData.val);
                        if(size) {
                            uiConf.textSize = size;
                            localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));
                            applyUi(uiConf.textSize, uiConf.imgSize);
                        }
                        return;
                    }

                    // --- NACHTMODUS ---
                    if (cmdData.cmd === 'CONFIG_NIGHT') {
                        uiConf.nightStart = cmdData.start;
                        uiConf.nightEnd = cmdData.end;
                        localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));
                        checkNightMode(); 
                        return;
                    }

                } catch(err) { /* Kein JSON-Command -> Normale Nachricht, Fehler ignorieren */ }

                // === 3. NORMALE NACHRICHT ===
                let encPayload = data.attachment ? data.title : data.message;
                let imgData = data.attachment ? data.attachment.url : null;

                await processAndAdd({
                    ts: data.time,
                    enc: encPayload,
                    img: imgData,
                    hidden: false 
                });
            }
        };
    }

    // === DER WACHHUND (WATCHDOG) ===
    // Diese Funktion muss EINMAL in startApp() aufgerufen werden!
    function startConnectionWatchdog() {
        if (connectionWatchdog) clearInterval(connectionWatchdog);

        // Pr√ºfe alle 15 Sekunden
        connectionWatchdog = setInterval(() => {
            // readyState: 0=CONNECTING, 1=OPEN, 2=CLOSED
            // Wenn Verbindung zu (2) oder seit Ewigkeiten versucht zu verbinden (0)
            if (!es || es.readyState === 2) {
                log("Watchdog: Verbindung tot. Neustart...");
                connectNtfy();
            } else if (es.readyState === 0) {
                // H√§ngt im Connecting Status? Resetten.
                log("Watchdog: H√§ngt. Reset...");
                connectNtfy();
            }
        }, 15000);

        // Zus√§tzlich: Wenn Tablet aufwacht und Netzwerk meldet
        window.addEventListener('online', () => {
            log("Netzwerk ist zur√ºck! Reconnect...");
            connectNtfy();
        });
    }
    

function updateDisplay() {
    if(messages.length === 0) {
        document.getElementById('cardText').innerText = "Warte auf neue Nachrichten...";
        document.getElementById('cardImg').style.display = 'none';
        document.getElementById('smartDate').innerText = "";
        return;
    }
    
    const msg = messages[currentIndex];
    
    // 1. Text setzen
    document.getElementById('cardText').innerText = msg.text || "";
    document.getElementById('msgCounter').innerText = `Nachricht ${currentIndex + 1} von ${messages.length} ‚Ä¢ ${msg.sender}`;
    
    // 2. Smartes Datum setzen
    document.getElementById('smartDate').innerText = getSmartDate(msg.timestamp);

    // 3. Bild setzen
    const imgEl = document.getElementById('cardImg');
    const bgEl = document.getElementById('ambientBg');
    
    if(msg.image) {
        imgEl.src = msg.image; 
        imgEl.style.display = 'block';
        // Ambient Background setzen (das gleiche Bild, nur unscharf via CSS)
        bgEl.style.backgroundImage = `url('${msg.image}')`;
    } else {
        imgEl.style.display = 'none';
        // Fallback Hintergrund wenn kein Bild da ist (neutrales Dunkelgrau oder Muster)
        bgEl.style.backgroundImage = 'none';
        bgEl.style.background = '#111';
    }

    // Logging (deine alte Funktion)
    smartLog(msg);
}
    
    
    // Navigation
    window.nextMsg = function() { if(currentIndex < messages.length - 1) { currentIndex++; updateDisplay(); } };
    window.prevMsg = function() { if(currentIndex > 0) { currentIndex--; updateDisplay(); } };
    
    document.addEventListener('keydown', (e) => { 
        if(e.key === 'ArrowLeft') prevMsg(); 
        if(e.key === 'ArrowRight') nextMsg(); 
    });

    if(!window.isSecureContext) alert("Achtung: HTTPS erforderlich f√ºr Verschl√ºsselung!");

// === UI TWEAKS LOGIC & LIGHTBOX ===

    // Standards erweitert: Screensaver (20 Min Standard)
    let uiConf = { 
        textSize: 4, 
        imgSize: 50, 
        zoomActive: false, 
        zoomTime: 10,
        nightStart: "22:00", 
        nightEnd: "08:00",
        screensaverMin: 20 // NEU: Minuten bis dunkel (0=aus)
    }; 
    
    let clickCnt = 0;
    let clickTimer = null;
    let lightboxTimer = null;
    let screensaverTimer = null; // Timer Variable f√ºr Screensaver

    // 1. Beim Start laden
    (function initUi() {
        try {
            const saved = JSON.parse(localStorage.getItem('oma_ui_settings'));
            if(saved) { uiConf = { ...uiConf, ...saved }; }
        } catch(e){}
        
        applyUi(uiConf.textSize, uiConf.imgSize);
        
        // Nachtmodus Check starten (alle 10 Sekunden)
        checkNightMode();
        setInterval(checkNightMode, 10000); 

        // Screensaver starten
        resetIdleTimer();
        
        // Globaler Listener: Bei JEDEM Klick/Touch aufwachen & Timer resetten
        document.addEventListener('click', resetIdleTimer);
        document.addEventListener('touchstart', resetIdleTimer);
    })();

    // Hilfsfunktion: Zeitstring "22:30" in Tagesminuten (1350) umwandeln
    function getMins(timeStr) {
        if (typeof timeStr === 'number') return timeStr * 60; 
        if (!timeStr) return 0;
        const parts = timeStr.split(':');
        return (parseInt(parts[0]) * 60) + parseInt(parts[1]);
    }

    // === SCREENSAVER LOGIC ===
    function resetIdleTimer() {
        // 1. Wenn dunkel -> Aufwecken (Overlay weg)
        wakeUp();

        // 2. Timer neu starten
        clearTimeout(screensaverTimer);
        
        // Nur starten, wenn aktiviert (>0) UND kein "Neue Nachricht" Alarm da ist
        const isAlertOpen = document.getElementById('newMsgOverlay').style.display === 'flex';
        
        if (uiConf.screensaverMin > 0 && !isAlertOpen) {
            const ms = uiConf.screensaverMin * 60 * 1000;
            screensaverTimer = setTimeout(goDark, ms);
        }
    }

    function goDark() {
        // Sicherheitscheck: Nicht abdunkeln wenn Alarm an ist
        if (document.getElementById('newMsgOverlay').style.display === 'flex') return;
        
        const el = document.getElementById('screensaverOverlay');
        if(el) el.classList.add('active');
    }

    function wakeUp() {
        const el = document.getElementById('screensaverOverlay');
        if (el && el.classList.contains('active')) {
            el.classList.remove('active');
        }
    }

    // 2. Secret Click Handler (5x klicken)
    function handleSecretClick() {
        clickCnt++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { 
            if(clickCnt < 5) toggleDebug(); 
            clickCnt = 0; 
        }, 400);

        if(clickCnt >= 5) {
            clickCnt = 0;
            clearTimeout(clickTimer);
            openUiSettings();
        }
    }

// 3. Men√º √∂ffnen & Werte setzen
    function openUiSettings() {
        document.getElementById('uiTweaksModal').style.display = 'flex';
        
        // Slider Werte
        document.getElementById('rangeText').value = uiConf.textSize;
        document.getElementById('rangeImg').value = uiConf.imgSize;
        document.getElementById('valText').innerText = uiConf.textSize;
        document.getElementById('valImg').innerText = uiConf.imgSize;

        // Zoom & Screensaver Einstellungen laden
        document.getElementById('checkZoom').checked = uiConf.zoomActive;
        document.getElementById('numZoomTime').value = uiConf.zoomTime || 10;
        
        // NEU: Screensaver Feld f√ºllen (falls vorhanden)
        const saverInput = document.getElementById('numSaverTime');
        if(saverInput) saverInput.value = uiConf.screensaverMin || 0;

        // Device ID laden
        document.getElementById('inputDeviceId').value = config.deviceId || "";
    }
    
    // 4. Live Vorschau beim Schieben (Slider)
    function previewUi() {
        const t = document.getElementById('rangeText').value;
        const i = document.getElementById('rangeImg').value;
        document.getElementById('valText').innerText = t;
        document.getElementById('valImg').innerText = i;
        applyUi(t, i);
    }

// 5. Speichern oder Abbrechen
    function closeUi(save) {
        document.getElementById('uiTweaksModal').style.display = 'none';
        
        if(save) {
            // A) UI Settings speichern
            uiConf.textSize = document.getElementById('rangeText').value;
            uiConf.imgSize = document.getElementById('rangeImg').value;
            uiConf.zoomActive = document.getElementById('checkZoom').checked;
            uiConf.zoomTime = parseInt(document.getElementById('numZoomTime').value) || 10;
            
            // NEU: Screensaver speichern
            const saverVal = document.getElementById('numSaverTime');
            if(saverVal) uiConf.screensaverMin = parseInt(saverVal.value) || 0;

            localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));
            
            // Timer mit neuen Werten sofort anwenden
            resetIdleTimer();

            // B) Device ID speichern
            const newId = document.getElementById('inputDeviceId').value.trim();
            const currentId = config.deviceId || "";

            if (newId !== currentId) {
                config.deviceId = newId;
                localStorage.setItem('oma_conf_v10', JSON.stringify(config));
                alert("Ger√§te-ID gespeichert! App wird neu geladen.");
                location.reload(); 
                return;
            }

            alert("Einstellungen gespeichert!");
        } else {
            // Reset auf alte Werte bei Abbruch
            applyUi(uiConf.textSize, uiConf.imgSize);
        }
    }
    
    // 6. Werte anwenden (CSS)
    function applyUi(textVal, imgVal) {
        const txt = document.getElementById('messageText');
        const img = document.getElementById('messageImg');
        if(txt) txt.style.fontSize = textVal + "vh";
        if(img) img.style.maxHeight = imgVal + "vh";
    }

    // === NEU: LIGHTBOX FUNKTIONEN ===
    
    function openLightbox() {
        // Nur √∂ffnen, wenn im Admin-Men√º aktiviert UND ein Bild da ist
        const src = document.getElementById('messageImg').src;
        if(!uiConf.zoomActive || !src || document.getElementById('messageImg').style.display === 'none') return;

        const lb = document.getElementById('lightbox');
        const lbImg = document.getElementById('lightboxImg');
        
        lbImg.src = src;
        lb.style.display = 'flex'; // Zeigen

        // Auto-Close Timer starten
        clearTimeout(lightboxTimer); // Sicherheitshalber alte Timer l√∂schen
        const ms = uiConf.zoomTime * 1000;
        lightboxTimer = setTimeout(closeLightbox, ms);
        
        log(`Lightbox offen f√ºr ${uiConf.zoomTime}s`);
    }

    function closeLightbox() {
        const lb = document.getElementById('lightbox');
        lb.style.display = 'none';
        clearTimeout(lightboxTimer); // Timer stoppen, falls manuell geschlossen
    }
// === NEU: NOTIFICATION LOGIC ===
    
    // Cache laden oder erstellen
    let seenCache = {};
    try {
        seenCache = JSON.parse(localStorage.getItem('oma_seen_msgs') || '{}');
    } catch(e) {}

// HILFSFUNKTION: Ist es gerade Schlafenszeit?
    function isNightTime() {
        if (!uiConf.nightStart || !uiConf.nightEnd) return false;

        const now = new Date();
        const curMins = (now.getHours() * 60) + now.getMinutes();
        const startMins = getMins(uiConf.nightStart);
        const endMins = getMins(uiConf.nightEnd);

        if (startMins > endMins) {
            // Geht √ºber Mitternacht (z.B. 22:00 bis 08:00)
            return (curMins >= startMins || curMins < endMins);
        } else {
            // Gleicher Tag (z.B. 13:00 bis 15:00 - Mittagsschlaf)
            return (curMins >= startMins && curMins < endMins);
        }
    }

function checkNightMode() {
        const overlay = document.getElementById('nightOverlay');
        const isNight = isNightTime();
        const wasNight = overlay.style.display === 'block';

        if (isNight) {
            if(!wasNight) overlay.style.display = 'block';
        } else {
            if(wasNight) {
                // GUTE MORGEN LOGIK:
                overlay.style.display = 'none';
                
                // Pr√ºfen, ob wir was verpasst haben, w√§hrend wir geschlafen haben
                // Wir schauen uns die aktuellste Nachricht an
                if(messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    // Wenn die noch nicht gesehen wurde -> Alarm jetzt nachholen!
                    checkNewMessage(lastMsg.timestamp);
                }
            }
        }
    }

    
    // ALARM CHECKER (Jetzt mit Nachtruhe-Schutz)
    function checkNewMessage(ts) {
        // 1. DER WICHTIGSTE CHECK:
        // Wenn es Nacht ist -> ABBRUCH. Kein Aufwecken, kein Overlay.
        // Die Nachricht wird geladen, aber stillschweigend.
        if (isNightTime()) {
            console.log("Nachtmodus aktiv: Nachricht empfangen, aber Alarm unterdr√ºckt.");
            return; 
        }

        // 2. Wenn Tag ist -> Normales Verhalten
        wakeUp(); // Screensaver weg
        
        // Wenn Timestamp noch NICHT im Cache ist -> ALARM!
        if (!seenCache[ts]) {
            const overlay = document.getElementById('newMsgOverlay');
            if (overlay.style.display !== 'flex') {
                overlay.style.display = 'flex';
                clearTimeout(screensaverTimer);
            }
        }
    }

    
// Funktion: Wird beim Klick auf das Overlay ausgef√ºhrt
    function dismissNotification() {
        // 1. Overlay ausblenden
        document.getElementById('newMsgOverlay').style.display = 'none';

        // 2. Alle aktuell geladenen Nachrichten als "gesehen" markieren
        const now = Date.now();
        messages.forEach(m => {
            seenCache[m.timestamp] = now; 
        });

        // 3. Aufr√§umen (Pruning > 14 Tage)
        const FOURTEEN_DAYS = 14 * 24 * 60 * 60 * 1000;
        for (const [ts, seenTime] of Object.entries(seenCache)) {
            if (now - seenTime > FOURTEEN_DAYS) {
                delete seenCache[ts];
            }
        }

        // 4. Speichern
        localStorage.setItem('oma_seen_msgs', JSON.stringify(seenCache));
        
        // NEU: Jetzt wo der Alarm best√§tigt ist, darf der Screensaver-Countdown wieder laufen
        resetIdleTimer();
    }
    
    // === DEVICE REGISTRATION (PING ANTWORT) ===
    async function registerSelfOnGitHub() {
        if(!config.ghUser || !config.ghToken) return;

        log("PING empfangen! Registriere...");
        
        // 1. Zuf√§llige Wartezeit (0-10s) gegen Kollisionen bei "PING ALL"
        const delay = Math.floor(Math.random() * 10000);
        await new Promise(r => setTimeout(r, delay));

        try {
            const myId = config.deviceId || "unbekannt";
            
            // 2. Aktuelle Liste laden
            const url = `https://api.github.com/repos/${config.ghUser}/${config.ghRepo}/contents/devices.json`;
            const header = { 'Authorization': `Bearer ${config.ghToken}`, 'Accept': 'application/vnd.github.v3+json' };
            
            let devices = [];
            let sha = null;

            const resp = await fetch(url, { headers: header, cache: "no-store" });
            
            if(resp.ok) {
                const fileData = await resp.json();
                sha = fileData.sha;
                // Sauberes Decoding
                const rawContent = fileData.content.replace(/\s/g, '');
                try {
                    devices = JSON.parse(decodeURIComponent(escape(atob(rawContent))));
                } catch(e){}
            } 

            // 3. Akku Status holen (falls m√∂glich)
            let batt = "?";
            try {
                const b = await navigator.getBattery();
                batt = Math.round(b.level * 100);
            } catch(e){}

            // 4. Liste updaten
            const now = Math.floor(Date.now() / 1000);
            const myEntry = {
                id: myId,
                lastSeen: now,
                battery: batt,
                userAgent: navigator.userAgent
            };

            // Pr√ºfen ob ID schon existiert -> √úberschreiben, sonst Hinzuf√ºgen
            const idx = devices.findIndex(d => d.id === myId);
            if(idx >= 0) devices[idx] = myEntry;
            else devices.push(myEntry);

            // 5. Hochladen
            const newContent = btoa(unescape(encodeURIComponent(JSON.stringify(devices, null, 2))));
            const body = {
                message: `Device Update: ${myId}`,
                content: newContent
            };
            if(sha) body.sha = sha;

            await fetch(url, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${config.ghToken}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            log("Ger√§teliste aktualisiert ‚úÖ");

        } catch(e) {
            console.error(e);
            // Log nur lokal, um Loop zu vermeiden
        }
    }

// Hilfsfunktion: Macht aus Timestamp "Heute Mittag", "Gestern Abend" etc.
function getSmartDate(ts) {
    const date = new Date(ts);
    const now = new Date();
    
    // Zeit bereinigen (nur Tage vergleichen)
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
    const msgDay = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
    const diffDays = Math.round((today - msgDay) / (1000 * 60 * 60 * 24));

    // Tageszeit bestimmen
    const hour = date.getHours();
    let timeOfDay = "Nacht";
    if (hour >= 5 && hour < 11) timeOfDay = "Morgen";
    else if (hour >= 11 && hour < 14) timeOfDay = "Mittag";
    else if (hour >= 14 && hour < 18) timeOfDay = "Nachmittag";
    else if (hour >= 18 && hour < 22) timeOfDay = "Abend";

    // String bauen
    if (diffDays === 0) return `Heute ${timeOfDay}`;
    if (diffDays === 1) return `Gestern ${timeOfDay}`;
    if (diffDays === 2) return `Vorgestern ${timeOfDay}`;
    
    // √Ñlter als 2 Tage: Wochentag ausschreiben (z.B. "Dienstag Nachmittag")
    const options = { weekday: 'long' };
    const weekday = date.toLocaleDateString('de-DE', options);
    return `${weekday} ${timeOfDay}`;
}

let slideshowInterval = null;

function toggleSlideshow() {
    const btn = document.getElementById('playBtn');
    const icon = document.getElementById('playIcon');
    const text = document.getElementById('playText');

    if (slideshowInterval) {
        // STOPPEN
        clearInterval(slideshowInterval);
        slideshowInterval = null;
        
        // UI zur√ºcksetzen
        btn.classList.remove('stop-mode');
        icon.innerText = "‚ñ∂";
        text.innerText = "Abspielen";
    } else {
        // STARTEN
        if (messages.length === 0) return;

        // 1. Zur neuesten Nachricht springen
        currentIndex = 0;
        updateDisplay();

        // 2. UI auf Stop √§ndern
        btn.classList.add('stop-mode');
        icon.innerText = "‚èπ";
        text.innerText = "Stop";

        // 3. Interval starten (8 Sekunden)
        slideshowInterval = setInterval(() => {
            if (currentIndex < messages.length - 1) {
                // N√§chste Nachricht (Wir gehen r√ºckw√§rts in der Zeit, also Index hoch)
                currentIndex++;
                updateDisplay();
            } else {
                // Ende erreicht -> Zur√ºck zum Start & Stop
                currentIndex = 0;
                updateDisplay();
                toggleSlideshow(); // Stoppt sich selbst
            }
        }, 8000);
    }
}
    
    
</script>
</body>
</html>
