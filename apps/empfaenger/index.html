<!DOCTYPE html>
<html lang="de">
<head>
<link rel="manifest" href="manifest.json">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Oma Display V10</title>
<style>
    /* === OMA UI DESIGN === */
    :root { --bg: #000000; --text: #ffffff; --accent: #4cd137; color-scheme: only dark; }
* { 
        box-sizing: border-box;
        /* === KIOSK SCHUTZ === */
        -webkit-user-select: none;  /* Safari/Chrome: Kein Text markieren */
        user-select: none;          /* Standard: Kein Text markieren */
        -webkit-touch-callout: none;/* iOS: Kein Kontextmen√º bei langem Dr√ºcken */
        -webkit-tap-highlight-color: transparent; /* Kein Aufblinken beim Tippen */
    }

    /* Wichtig: Eingabefelder im Setup m√ºssen bedienbar bleiben */
    input { 
        -webkit-user-select: text; 
        user-select: text; 
    }
    body { margin: 0; padding: 0; background-color: var(--bg); color: var(--text); font-family: sans-serif; overflow: hidden; height: 100vh; width: 100vw; display: flex; flex-direction: column; }
    
/* HEADER - Optimiert f√ºr Oma */
    #metaInfo { 
        height: 80px; width: 100%; 
        background: #111; border-bottom: 2px solid #333; 
        
        display: grid; /* Dreiteilung: Links, Mitte, Rechts */
        grid-template-columns: 1fr auto 1fr; 
        align-items: center; 
        padding: 0 30px; 
        flex-shrink: 0; z-index: 50; 
    }

    /* Links: Der Absender (Sehr gro√ü) */
    .meta-sender {
        font-size: 4vh; font-weight: 900; 
        color: var(--accent); text-transform: capitalize;
        text-align: left;
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }

    /* Mitte: Play Button */
    #playBtn {
        background: #333; color: white; border: 2px solid #555;
        border-radius: 50px; padding: 10px 30px; margin: 0;
        font-size: 2.5vh; font-weight: bold; cursor: pointer;
        display: flex; align-items: center; gap: 10px;
        transition: all 0.2s;
    }
    #playBtn:active { transform: scale(0.95); }
    #playBtn.active { background: #ff4757; border-color: #ff4757; }

    /* Rechts: Datum & Z√§hler */
    .meta-details {
        text-align: right; color: #fff;
        display: flex; flex-direction: column; justify-content: center;
    }
    .meta-time { font-size: 2.2vh; font-weight: bold; color: #fff; }
    .meta-date { font-size: 1.8vh; color: #bbb; margin-top: 2px; }


    /* MAIN DISPLAY - PROFESSIONAL OLED LOOK */
    #displayArea { 
        flex: 1; 
        display: flex; 
        flex-direction: column; 
        align-items: center;     
        justify-content: flex-start; 
        padding: 10px 20px;          
        overflow: hidden; 
        position: relative; 
        
        /* === HIER DIE NEUE ZEILE === */
        touch-action: pan-y; /* Erlaubt hoch/runter Scrollen, aber √ºberl√§sst links/rechts dem Skript */
    }
    
    #messageImg { 
        max-width: 100%; max-height: 45vh; 
        object-fit: contain; border-radius: 15px; 
        margin-bottom: 20px; display: none; 
        border: 1px solid #333;
    }
    
    #messageText { 
        text-align: left; font-weight: 400; line-height: 1.5; 
        width: 90%; max-width: 800px; 
        font-family: sans-serif; color: #f0f0f0; 
        font-size: 4vh; word-wrap: break-word; 
        overflow-y: auto; max-height: 100%;
    }

    /* NAVIGATION PFEILE (Sichtbar & Oben) */
    .nav-zone { 
        position: fixed; 
        top: 100px; /* Unter dem Header beginnen */
        height: 40%; /* Nur im oberen Bereich (Bildh√∂he) aktiv */
        width: 100px; 
        z-index: 40; 
        
        display: flex; align-items: center; justify-content: center;
        font-size: 80px; color: rgba(255, 255, 255, 0.25); /* Immer sichtbar */
        cursor: pointer; 
        text-shadow: 0 0 10px black;
    }
    .nav-zone:active { color: white; transform: scale(1.1); }
    #btnPrev { left: 10px; justify-content: flex-start; } 
    #btnNext { right: 10px; justify-content: flex-end; }

    /* SETUP SCREEN */
    #setupScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #222; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 15px; overflow-y: auto; padding: 20px; }
    input { padding: 12px; font-size: 18px; border-radius: 8px; border: none; width: 90%; max-width: 400px; text-align: center; }
    .group-label { color: #888; font-size: 14px; margin-top: 10px; width: 90%; max-width: 400px; text-align: left; }
    button { padding: 15px 30px; font-size: 20px; background: var(--accent); border: none; border-radius: 10px; font-weight: bold; cursor: pointer; margin-top: 20px;}

    /* TOOLS */
    #statusLight { position: fixed; top: 10px; right: 10px; width: 15px; height: 15px; border-radius: 50%; background: orange; z-index: 50; border: 2px solid white; cursor: pointer; }
    #reloadBtn { position: fixed; bottom: 15px; right: 15px; width: 40px; height: 40px; background: rgba(50,50,50,0.8); border: 1px solid #666; border-radius: 50%; color: #ccc; font-size: 20px; display: flex; align-items: center; justify-content: center; z-index: 40; cursor: pointer; }
    #debugLog { position: fixed; bottom: 0; left: 0; width: 100%; height: 100px; background: rgba(0,0,0,0.8); color: lime; font-family: monospace; font-size: 10px; overflow-y: scroll; pointer-events: none; z-index: 40; padding: 5px; box-sizing: border-box; display: none; }

/* UI TWEAKS MODAL STYLE - MIT SCROLLBAR FIX */
    #uiTweaksModal {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 80%; max-width: 350px; background: #222; border: 1px solid #444;
        border-radius: 15px; padding: 20px; z-index: 200;
        display: flex; flex-direction: column; gap: 10px;
        box-shadow: 0 0 50px rgba(0,0,0,0.8);
        
        /* HIER IST DER FIX: */
        max-height: 90vh;  /* Maximal 90% der Bildschirmh√∂he */
        overflow-y: auto;  /* Scrollbalken anzeigen */
    }
    
    #uiTweaksModal h3 { margin: 0 0 10px 0; color: white; text-align: center; }
    #uiTweaksModal label { color: #ccc; font-size: 14px; display: flex; justify-content: space-between; }
    #uiTweaksModal input[type=range] { width: 100%; height: 30px; }
    /* MAIN DISPLAY - PROFESSIONAL OLED LOOK */
    #displayArea { 
        flex: 1; 
        display: flex; 
        flex-direction: column; 
        align-items: center;     /* Zentriert den Inhalt (Bild & Textblock) horizontal */
        justify-content: center; /* Zentriert alles vertikal */
        padding: 20px; 
        overflow: hidden; 
        position: relative; 
    }

    #messageImg { 
        max-width: 100%;       /* Bild darf volle Breite nutzen */
        max-height: 45vh;      /* Etwas Platz lassen f√ºr den Text */
        object-fit: contain; 
        border-radius: 15px; 
        margin-bottom: 25px;   /* Mehr Abstand zum Text sieht edler aus */
        display: none; 
        box-shadow: 0 0 20px rgba(0,0,0,0.5); /* Leichter Schatten falls Bild hell ist */
    }

    #messageText { 
        /* 1. Linksb√ºndig f√ºr Lesbarkeit */
        text-align: left; 
        
        /* 2. Normale Dicke statt Fett */
        font-weight: 400; 
        
        /* 3. Zeilenabstand f√ºr "Luft" */
        line-height: 1.5; 
        
        /* 4. Breite begrenzen (90%) */
        width: 90%; 
        max-width: 800px; /* Profi-Tipp: Auf riesigen Tablets wird die Zeile sonst zu lang */
        
        /* Schriftart modernisieren (System Fonts) */
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        
        /* OLED-Tipp: Leichtes Off-White (#f0f0f0) ist angenehmer als grelles Wei√ü (#ffffff) */
        color: #f0f0f0; 

        /* Layout & Scrollen */
        font-size: 4vh; /* Standard, wird vom JS-Slider √ºberschrieben */
        word-wrap: break-word; 
        max-height: 100%; 
        overflow-y: auto; 
    }
    /* MAIN DISPLAY - TOP ALIGNED */
    #displayArea { 
        flex: 1; 
        display: flex; 
        flex-direction: column; 
        align-items: center; 
        
        /* HIER DIE √ÑNDERUNG: */
        justify-content: flex-start; /* Inhalt beginnt oben (statt Mitte) */
        padding: 10px 20px;          /* Oben nur 10px Abstand zum Header */
        
        overflow: hidden; 
        position: relative; 
    }
    /* HEADER - OMA FRIENDLY */
    #metaInfo { 
        height: 70px;            /* Etwas h√∂her f√ºr gr√∂√üere Schrift */
        width: 100%; 
        background: #111; 
        border-bottom: 2px solid #333; /* Deutlichere Trennlinie */
        
        display: flex;           /* Flexbox aktiviert */
        align-items: center;     /* Vertikal mittig */
        justify-content: space-between; /* Schiebt Name nach Links, Rest nach Rechts */
        
        padding: 0 50px;         /* Abstand zum Rand */
        flex-shrink: 0; 
        z-index: 5; 
    }

    /* Der Name (Links) */
    .meta-sender {
        font-size: 3.5vh;    /* Sch√∂n gro√ü */
        font-weight: 900;    /* Extra Fett */
        color: var(--accent); /* Die Akzentfarbe (Gr√ºn) oder √§ndere zu #ffffff f√ºr Wei√ü */
        text-transform: capitalize; /* Erster Buchstabe immer Gro√ü */
    }

  /* Datum & Z√§hler (Rechts) */
    .meta-details {
        text-align: right;   /* Rechtsb√ºndig */
        display: flex; 
        flex-direction: column; /* Untereinander */
        justify-content: center;
        color: #ffffff;
        
        /* HIER DIE √ÑNDERUNGEN: */
        font-size: 1.8vh;    /* Basis-Schrift etwas kleiner, damit 3 Zeilen passen */
        line-height: 1.2;    /* Zeilen enger zusammenr√ºcken */
        font-weight: normal;
    }
/* === LIGHTBOX (ZOOM) === */
    #lightbox { 
        display: none; 
        position: fixed; 
        top: 0; left: 0; 
        width: 100vw; height: 100vh; 
        background: black; 
        z-index: 999; /* √úber allem anderen */
        align-items: center; 
        justify-content: center; 
    }
    #lightbox img { 
        max-width: 100%; 
        max-height: 100%; 
        object-fit: contain; 
        box-shadow: 0 0 50px rgba(255,255,255,0.1);
    }
    /* Kleine Hilfe f√ºr das Admin-Men√º Layout */
    .setting-row { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        margin-top: 10px; 
        color: #ccc; 
        font-size: 14px;
    }
/* === NEW MESSAGE OVERLAY === */
    #newMsgOverlay {
        display: none; /* Standardm√§√üig aus */
        position: fixed; top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: rgba(0, 0, 0, 0.85); /* Dunkler Hintergrund, Fokus auf Text */
        z-index: 2000; /* √úber allem (auch √ºber Lightbox) */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        backdrop-filter: blur(5px); /* Macht den Hintergrund unscharf - sehr modern */
    }

    .notify-content {
        text-align: center;
        animation: float 3s ease-in-out infinite; /* Sanftes Schweben */
    }

    .notify-icon {
        font-size: 15vh; /* Riesiges Icon */
        margin-bottom: 2vh;
        filter: drop-shadow(0 0 20px rgba(76, 209, 55, 0.6)); /* Gr√ºnes Leuchten */
    }

    .notify-title {
        font-size: 6vh;
        font-weight: bold;
        color: white;
        margin-bottom: 1vh;
        font-family: sans-serif;
    }

    .notify-sub {
        font-size: 3vh;
        color: #aaa;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    @keyframes float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-20px); } /* Sanft hoch und runter */
        100% { transform: translateY(0px); }
    }
    

  /* === NIGHT MODE (STRENG) === */
    #nightOverlay {
        display: none;
        position: fixed; top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: #000000; /* Komplett Schwarz statt transparent */
        z-index: 3000; /* WICHTIG: √úber dem Alarm (2000) und allem anderen */
        pointer-events: none; /* Klicks gehen durch (damit man manuell aufwecken KANN, wenn man tippt) */
        transition: opacity 1s ease;
    }
    
 /* === SCREENSAVER (WETTER TIMELINE) === */
    #screensaverOverlay {
        display: none;
        position: fixed; top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: #000000;
        z-index: 1800; /* √úber App, aber UNTER Alarm (2000) */
        
        flex-direction: column;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.5s ease;
        
        /* Anti-Burn-In: Minimales Wackeln des gesamten Screens */
        animation: antiBurnIn 120s infinite alternate ease-in-out;
    }

    #screensaverOverlay.active {
        display: flex;
        opacity: 1; /* Jetzt voll sichtbar, da wir Inhalte haben */
    }

    /* Oben: Gro√üe Uhrzeit */
    #saverTopBar {
        width: 90%;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        margin-bottom: 3vh;
        border-bottom: 2px solid #333;
        padding-bottom: 10px;
    }
    #saverClock { font-size: 8vh; font-weight: bold; color: #fff; line-height: 1; }
    #saverDate { font-size: 3vh; color: #ccc; font-weight: normal; text-transform: uppercase; }

    /* Container f√ºr die 4 Karten */
    .forecast-row {
        display: flex;
        flex-direction: row;
        gap: 1.5vw;
        width: 95%;
        height: 55vh;
    }

    /* === DIE WETTER KARTEN === */
    .weather-card {
        flex: 1; 
        background: #1a1a1a;
        border: 2px solid #333;
        border-radius: 15px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-around;
        box-shadow: 0 4px 15px rgba(0,0,0,0.8);
    }

    /* === SPEZIAL: DIE ERSTE KARTE (JETZT) === */
    .weather-card.current {
        background: #222;
        border: 3px solid #4cd137; /* Gr√ºner Rand */
        transform: scale(1.02);
        box-shadow: 0 0 20px rgba(76, 209, 55, 0.2);
        z-index: 10;
        animation: pulseBorder 3s infinite;
    }


    

    /* TYPOGRAPHIE SCREENSAVER */
    .slot-name { font-size: 3.5vh; font-weight: 900; color: #fff; text-transform: uppercase; letter-spacing: 1px; }
/* WETTER ZEIT BUBBLES - Optimiert */
    .slot-time {
        font-size: 3.2vh;      /* Deutlich gr√∂√üer (vorher 2.5vh) */
        font-weight: bold;
        color: #ffffff;        /* Wei√ü statt Grau */
        background: #333;      /* Hintergrund etwas heller als die Karte */
        padding: 8px 18px;     /* Mehr Polsterung */
        border-radius: 30px;
        margin-top: 8px;
        border: 1px solid #444; /* Feiner Rand f√ºr Definition */
    }
    .slot-icon { font-size: 10vh; margin: 1vh 0; }
    .slot-temp { font-size: 7vh; font-weight: bold; color: white; }
    .slot-rain { font-size: 2.5vh; font-weight: bold; color: #4aa3df; display: flex; align-items: center; gap: 5px; }

    /* Animationen */
    @keyframes antiBurnIn { from { transform: translate(-5px,-5px); } to { transform: translate(5px,5px); } }
    @keyframes pulseBorder { 0% { border-color: #4cd137; } 50% { border-color: #38ada9; } 100% { border-color: #4cd137; } }

/* === WETTER ANIMATIONEN (CSS ONLY) === */
    .w-icon {
        width: 9vh; height: 9vh;
        position: relative;
        display: inline-block;
    }

    /* SONNE */
    .w-sun {
        width: 5vh; height: 5vh;
        background: #f1c40f;
        border-radius: 50%;
        box-shadow: 0 0 40px #f1c40f;
        position: absolute;
        top: 2vh; left: 2vh;
        animation: sunPulse 4s infinite alternate;
    }
    .w-rays {
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 8vh; height: 8vh;
        border-radius: 50%;
        border: 2px dashed rgba(241, 196, 15, 0.4);
        animation: sunSpin 20s linear infinite;
    }

    /* === WOLKE (Anti-Darkmode Fix) === */
    .w-cloud {
        width: 7vh; height: 3.5vh;
        
        /* 1. Zwinge Wei√ü */
        background: #ffffff !important;
        
        /* 2. Verbiete dem Browser Farbkorrekturen */
        forced-color-adjust: none; 
        -webkit-print-color-adjust: exact;
        
        /* 3. Trick: Schrift schwarz setzen -> Browser l√§sst Hintergrund wei√ü f√ºr Kontrast */
        color: #000000; 

        border-radius: 50px;
        position: absolute;
        top: 3vh; left: 1vh;
        z-index: 2;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.6) !important; 
        animation: cloudFloat 4s ease-in-out infinite;
    }

    /* Die Bubbles oben auf der Wolke */
    .w-cloud::after, .w-cloud::before {
        content: ''; 
        position: absolute;
        background: #ffffff !important;
        forced-color-adjust: none; /* Auch hier Schutz */
        border-radius: 50%;
        box-shadow: none !important;
    }
    
    .w-cloud::after {
        top: -1.5vh; left: 1vh;
        width: 3vh; height: 3vh;
    }
    .w-cloud::before {
        top: -2.5vh; left: 3vh;
        width: 4vh; height: 4vh;
    }

    /* === NEBEL (Helleres Grau) === */
    .w-fog {
        width: 7vh; height: 0.8vh;
        background: #e0e0e0 !important;
        border-radius: 10px;
        position: absolute; top: 4vh; left: 1vh;
        animation: fogMove 5s infinite alternate;
        opacity: 0.9;
    }
    .w-fog::after {
        content: ''; position: absolute; top: 1.5vh; left: 1vh;
        width: 5vh; height: 0.8vh; 
        background: #e0e0e0 !important;
        border-radius: 10px;
    }

    /* === GEWITTER (Auch hier Gradient nutzen) === */
    .w-storm .w-cloud, 
    .w-storm .w-cloud::after, 
    .w-storm .w-cloud::before { 
        /* Hellgrauer Verlauf f√ºr Gewitterwolken */
        background: linear-gradient(180deg, #e0e0e0, #cccccc) !important;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.2) !important;
    }

    
    /* KEYFRAMES */
    @keyframes sunPulse { 0% { transform: scale(0.9); opacity: 0.8; } 100% { transform: scale(1.1); opacity: 1; } }
    @keyframes sunSpin { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }
    @keyframes cloudFloat { 0% { transform: translateY(0); } 50% { transform: translateY(-5px); } 100% { transform: translateY(0); } }
    @keyframes rainDrop { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(3vh); opacity: 0; } }
    @keyframes snowFall { 0% { transform: translateY(0) rotate(0deg); opacity: 1; } 100% { transform: translateY(3vh) rotate(180deg); opacity: 0; } }
    @keyframes fogMove { 0% { transform: translateX(-5px); } 100% { transform: translateX(5px); } }
    @keyframes lightning { 0%, 90%, 100% { opacity: 0; } 92%, 96% { opacity: 1; } }


    /* === VOICE RECORDER UI === */
/* === VOICE & PLAY BUTTONS === */
    /* Container f√ºr die Buttons in der Mitte */
    .header-buttons {
        display: flex;
        align-items: center;
        gap: 15px; /* Abstand zwischen Play und Aufnehmen */
    }

    /* Der Play Button (Links) */
    #playBtn {
        background: #333; color: white; border: 2px solid #555;
        border-radius: 50px; padding: 10px 25px; margin: 0;
        font-size: 2.2vh; font-weight: bold; cursor: pointer;
        display: flex; align-items: center; gap: 8px;
        transition: all 0.2s;
        height: 50px; /* Feste H√∂he f√ºr Einheitlichkeit */
    }
    #playBtn:active { transform: scale(0.95); }
    #playBtn.active { background: #ff4757; border-color: #ff4757; }

    /* Der Voice Button (Rechts, jetzt mit Text!) */
    #voiceBtn {
        background: #0984e3; /* Sch√∂nes Blau zur Unterscheidung */
        color: white; 
        border: 2px solid #74b9ff;
        border-radius: 50px; /* Pillenform wie Play */
        padding: 10px 25px; 
        margin: 0;
        font-size: 2.2vh; 
        font-weight: bold; 
        cursor: pointer;
        display: flex; 
        align-items: center; 
        gap: 8px;
        transition: all 0.2s;
        height: 50px;
    }
    #voiceBtn:active { transform: scale(0.95); background: #00cec9; }

    /* === MODAL STYLE UPDATE === */
    /* Button zum Abbrechen (Grau, ganz unten) */
    .btn-cancel-modal {
        margin-top: 40px; /* Abstand nach unten */
        background: #555;
        color: #ccc;
        border: 2px solid #777;
        padding: 15px 40px;
        border-radius: 50px;
        font-size: 2.5vh;
        font-weight: bold;
        cursor: pointer;
    }
    .btn-cancel-modal:active { background: #333; }
    
    #voiceModal {
        display: none; position: fixed; top: 0; left: 0; 
        width: 100%; height: 100%; background: rgba(0,0,0,0.95);
        z-index: 2500; flex-direction: column; 
        align-items: center; justify-content: center;
    }
    
    .rec-status { font-size: 3vh; color: #ccc; margin-bottom: 20px; font-weight: bold; }
    .rec-timer { font-size: 8vh; color: white; font-family: monospace; margin-bottom: 40px; }
    
    .rec-controls { display: flex; gap: 20px; }
    
    .btn-rec { 
        width: 120px; height: 120px; border-radius: 50%; border: none;
        font-size: 40px; font-weight: bold; color: white; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
        box-shadow: 0 0 30px rgba(0,0,0,0.5); transition: all 0.2s;
    }
    .btn-start { background: #4cd137; }
    .btn-stop { background: #e84118; animation: pulseRed 1.5s infinite; }
    .btn-send { background: #00a8ff; width: auto; padding: 20px 40px; border-radius: 20px; font-size: 3vh; }
    
    .rec-close {
        position: absolute; top: 20px; right: 20px; 
        font-size: 4vh; color: #666; cursor: pointer; padding: 20px;
    }

    @keyframes pulseRed { 
        0% { box-shadow: 0 0 0 0 rgba(232, 65, 24, 0.7); } 
        70% { box-shadow: 0 0 0 20px rgba(232, 65, 24, 0); } 
        100% { box-shadow: 0 0 0 0 rgba(232, 65, 24, 0); } 
    }

  /* === VOICE MESSAGE PLAYER (OMA EDITION) === */
    #voiceContainer {
        display: none; 
        width: 100%; height: 100%;
        flex-direction: column;
        align-items: center; justify-content: center;
        text-align: center;
    }
    
    #btnPlayVoice {
        width: 90%; 
        max-width: 600px;
        padding: 40px 20px;
        border-radius: 30px; /* Abgerundetes Rechteck */
        
        /* Knalliges Gr√ºn f√ºr "Hier dr√ºcken" */
        background: linear-gradient(135deg, #4cd137, #44bd32);
        border: 4px solid white;
        color: white; 
        
        display: flex; flex-direction: column; align-items: center; gap: 10px;
        cursor: pointer;
        box-shadow: 0 10px 30px rgba(76, 209, 55, 0.4);
        transition: transform 0.1s;
    }
    #btnPlayVoice:active { transform: scale(0.95); background: #44bd32; }
    
    /* Text im Button */
    .voice-btn-icon { font-size: 8vh; }
    .voice-btn-text { font-size: 3.5vh; font-weight: bold; font-family: sans-serif; text-transform: uppercase; }

    /* Wenn es abspielt: Rot werden */
    #btnPlayVoice.playing {
        background: linear-gradient(135deg, #e84118, #c23616);
        box-shadow: 0 10px 30px rgba(232, 65, 24, 0.4);
        animation: pulseVoice 1.5s infinite;
    }
    
    /* Die Info unter dem Button (Unterscheidungsmerkmal) */
    #voiceMetaInfo {
        margin-top: 40px; 
        font-size: 3vh; 
        color: #bbb; 
        font-weight: normal;
    }
    
    /* Extra fett f√ºr die Uhrzeit */
    .voice-time-big {
        display: block;
        font-size: 5vh;
        color: white;
        font-weight: bold;
        margin-top: 10px;
        color: var(--accent);
    }

    @keyframes pulseVoice {
        0% { box-shadow: 0 0 0 0 rgba(232, 65, 24, 0.7); } 
        70% { box-shadow: 0 0 0 20px rgba(232, 65, 24, 0); } 
        100% { box-shadow: 0 0 0 0 rgba(232, 65, 24, 0); } 
    }
    
</style>
</head>
<body>
<!-- NEU: WETTER SCREENSAVER OVERLAY -->
    <div id="screensaverOverlay" onclick="wakeUp()">
        <div id="saverTopBar">
            <div id="saverClock">--:--</div>
            <div id="saverDate">--</div>
        </div>

        <!-- Hier werden die 4 Karten per Javascript reingeneriert -->
        <div class="forecast-row" id="forecastRow"></div>
        
        <div style="color:#333; font-size:12px; margin-top:20px;">Tippen zum Aufwecken</div>
    </div>
    
<!-- NEU: NIGHT MODE OVERLAY -->
    <div id="nightOverlay"></div>
    
    <div id="statusLight" onclick="handleSecretClick()"></div>
    <div id="debugLog"></div>
    <div id="reloadBtn" onclick="location.reload()">‚Üª</div>

   <!-- NEU: NOTIFICATION OVERLAY -->
    <div id="newMsgOverlay" onclick="dismissNotification()">
        <div class="notify-content">
            <div class="notify-icon">üì©</div>
            <div class="notify-title">Neue Nachricht!</div>
            <div class="notify-sub">Tippen zum Ansehen</div>
        </div>
    </div> 
    <!-- SETUP FORMULAR -->
    <div id="setupScreen">
        <h1 style="color:white; margin:0">Einrichtung</h1>
        <div style="color:#aaa; font-size:12px; margin-bottom:10px">Oder Magic-Link benutzen</div>
        
        <div class="group-label">GitHub Archiv</div>
        <input id="ghUser" placeholder="User">
        <input id="ghRepo" placeholder="Repo">
        <input id="ghToken" type="password" placeholder="Token">

        <div class="group-label">NTFY (Live)</div>
        <input id="setupTopic" placeholder="Topic">
        <input id="setupPass" type="password" placeholder="Passwort">
        
        <button onclick="saveSetup()">Starten</button>
        <button onclick="resetApp()" style="background:#555; font-size:14px; margin-top:0">Reset</button>
    </div>
<!-- UI BEREICHE -->
    <div id="metaInfo">
        <!-- Links: Name -->
        <div id="metaSender" class="meta-sender">...</div>
        

<!-- Mitte: Buttons (PLAY links, ANTWORTEN rechts) -->
    <div class="header-buttons">
        <button id="playBtn" onclick="toggleSlideshow()">
            <span id="playIcon">‚ñ∂</span> <span id="playText">Abspielen</span>
        </button>
        
        <button id="voiceBtn" onclick="openVoiceUI()">
            <span>üéôÔ∏è</span> <span>Antworten</span>
        </button>
    </div>     

        <!-- Rechts: Datum -->
        <div class="meta-details">
            <span id="metaTime" class="meta-time">...</span>
            <span id="metaDate" class="meta-date">...</span>
        </div>
    </div>

<div id="displayArea">
        <!-- Standard Nachrichten (Bild/Text) -->
        <img id="messageImg" src="" onclick="openLightbox()">
        <div id="messageText">Lade Archiv...</div>

        <!-- NEU: Sprachnachrichten Container (Oma-Optimiert) -->
        <div id="voiceContainer">
            <button id="btnPlayVoice" onclick="playCurrentVoice()">
                <span id="voiceIcon" class="voice-btn-icon">üîä</span>
                <span id="voiceLabel" class="voice-btn-text">Hier dr√ºcken<br>zum Anh√∂ren</span>
            </button>
            
            <!-- Unterscheidungsmerkmal -->
            <div id="voiceMetaInfo">
                Nachricht vom <span id="voiceDateVal">...</span>
                <span id="voiceTimeVal" class="voice-time-big">...</span>
            </div>
        </div>
    </div>
    
    <!-- Sichtbare Pfeile -->
    <div id="btnPrev" class="nav-zone" onclick="prevMsg()">‚ùÆ</div>
    <div id="btnNext" class="nav-zone" onclick="nextMsg()">‚ùØ</div>
    
    <!-- UI TWEAKS MODAL (Versteckt) -->
    <div id="uiTweaksModal" style="display:none;">
        <h3>Anzeige anpassen</h3>
        
        <label>Schriftgr√∂√üe: <span id="valText">4</span>vh</label>
        <input type="range" id="rangeText" min="2" max="10" step="0.5" oninput="previewUi()">
        
        <label>Bildh√∂he: <span id="valImg">50</span>vh</label>
        <input type="range" id="rangeImg" min="10" max="90" step="5" oninput="previewUi()">
<!-- HIER EINF√úGEN: Nach den Slidern, aber VOR den Buttons -->
    
    <div style="border-top: 1px solid #444; margin: 15px 0;"></div>

    <div class="setting-row">
        <label for="checkZoom">Bild-Zoom aktivieren?</label>
        <input type="checkbox" id="checkZoom" style="width:20px; height:20px;">
    </div>

    <div class="setting-row">
        <label>Anzeigedauer (Sekunden):</label>
        <input type="number" id="numZoomTime" min="3" max="60" style="width:60px; padding:5px; text-align:center;">
    </div>
       <div class="setting-row">
        <label>Screensaver nach (Min):</label>
        <input type="number" id="numSaverTime" min="0" max="120" style="width:60px; padding:5px; text-align:center;">
    </div>
    <div style="font-size:10px; color:#666; text-align:right; margin-top:-5px;">(0 = Deaktiviert)</div> 
        <!-- ... vorheriger Code (Screensaver input) ... -->

          <!-- === NEU: ZEITRAUM BEGRENZUNG === -->
    <div class="setting-row" style="margin-top: 10px; border-top: 1px dashed #444; padding-top: 10px;">
        <label>Nur Nachrichten der letzten (Tage):</label>
        <input type="number" id="numMaxDays" min="0" placeholder="0" style="width:60px; padding:5px; text-align:center;">
    </div>
    <div style="font-size:10px; color:#666; text-align:right; margin-top:-5px;">(0 = Alle anzeigen)</div> 
    <!-- === ENDE NEU === -->

        
    <div class="setting-row">
        <label>T√§glicher Neustart (Uhrzeit):</label>
        <!-- type="time" macht automatisch eine Uhrzeit-Auswahl -->
        <input type="time" id="inputRestartTime" style="padding:5px; background:#333; color:white; border:1px solid #555; border-radius:5px;">
    </div>

        <!-- WETTER STANDORT -->
    <div style="border-top: 1px solid #444; margin: 15px 0; padding-top: 10px;">
        <label style="color:var(--accent); margin-bottom:5px;">Wetter Standort (Lat / Lon):</label>
        <div style="display:flex; gap:10px;">
            <input type="text" id="inputLat" placeholder="52.52" style="width:50%; background:#333; color:white; border:1px solid #555; border-radius:5px;">
            <input type="text" id="inputLon" placeholder="13.41" style="width:50%; background:#333; color:white; border:1px solid #555; border-radius:5px;">
        </div>
        <div style="font-size:10px; color:#888; margin-top:5px;">
            <a href="https://www.latlong.net/" target="_blank" style="color:#888;">Koordinaten hier finden</a>
        </div>
    </div>

        <!-- NEU: INTERNET CHECKBOX -->
<div class="setting-row" style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
    <label for="checkInternetContent" style="color:var(--accent);">üåç Wiki & Reise-Infos anzeigen?</label>
    <input type="checkbox" id="checkInternetContent" style="width:20px; height:20px;">
</div>

    <!-- ... nachfolgender Code (Device ID) ... -->
<!-- NEU: Device ID Editor -->
        <div style="border-top: 1px solid #444; margin: 15px 0; padding-top: 10px;">
            <label style="display:block; margin-bottom:5px; color:var(--accent);">Ger√§te-ID (Name):</label>
            <input type="text" id="inputDeviceId" placeholder="z.B. oma-wohnzimmer" 
                   style="width:100%; background:#333; color:white; border:1px solid #555; padding:8px; border-radius:5px;">
        </div>
    <!-- DANACH kommen deine Buttons (Abbruch/Speichern) -->
        
        <div style="display:flex; gap:10px; margin-top:20px; width:100%;">
            <button onclick="closeUi(false)" style="background:#555; flex:1;">Abbruch</button>
            <button onclick="closeUi(true)" style="background:var(--accent); flex:1;">Speichern</button>
        </div>
    </div>
    <!-- LIGHTBOX OVERLAY -->
    <div id="lightbox" onclick="closeLightbox()">
        <img id="lightboxImg" src="">
    </div> 

   <!-- VOICE RECORDER MODAL -->
    <div id="voiceModal">
        <!-- Status Anzeige -->
        <div id="recStatus" class="rec-status">Bereit zur Aufnahme</div>
        <div id="recTimer" class="rec-timer">00:00</div>
        
        <!-- Controls (Start/Stop/Senden) -->
        <div class="rec-controls" id="recBtns">
            <!-- Wird per JS bef√ºllt -->
        </div>

        <!-- OMA NOTAUSGANG (Gro√ü & Deutlich) -->
        <button class="btn-cancel-modal" onclick="closeVoiceUI()">Abbrechen / Schlie√üen</button>
    </div>
<script>
// === 0. MAGIC LINK CHECK ===
  // === 0. MAGIC LINK CHECK (MIT √úBERSCHREIB-SCHUTZ) ===
    (function checkMagicLink() {
        const hash = window.location.hash;
        if (hash.startsWith('#config=')) {
            try {
                const b64 = hash.substring(8);
                const json = JSON.parse(atob(b64));
                
                // Wir laden zuerst die existierende Config, um die ID zu retten
                let existingConf = {};
                try { 
                    existingConf = JSON.parse(localStorage.getItem('oma_conf_v10') || '{}'); 
                } catch(e) {}

                // LOGIK: Nimm die ID aus dem Link nur, wenn da wirklich eine drin steht.
                // Sonst behalte die ID, die wir schon lokal haben (durch Umbenennung).
                const finalDeviceId = json.did || existingConf.deviceId;

                const newConf = {
                    ghUser: json.gu,
                    ghRepo: json.gr,
                    ghToken: json.gt,
                    ntfyTopic: json.t,
                    pass: json.p,
                    deviceId: finalDeviceId // <--- HIER IST DER FIX
                };

                if(newConf.ghUser && newConf.ntfyTopic && newConf.pass) {
                    localStorage.setItem('oma_conf_v10', JSON.stringify(newConf));
                    
                    // URL s√§ubern, damit beim n√§chsten Reload nicht wieder importiert wird
                    // (Wichtig, falls man die Seite ohne Hash neu l√§dt)
                    history.replaceState(null, null, window.location.pathname);
                    
                    // Wir laden NICHT neu, wenn wir eh schon da sind, um Loops zu vermeiden,
                    // aber initialisieren alles neu.
                    if (existingConf.ntfyTopic !== newConf.ntfyTopic) {
                        location.reload(); 
                    }
                } else { 
                    alert("Link unvollst√§ndig."); 
                }
            } catch (e) { 
                console.error("Link Error", e); 
                alert("Link fehlerhaft."); 
            }
        }
    })();
    // === 1. BASIC UTILS ===
    function log(msg) { console.log(msg); const d=document.getElementById('debugLog'); if(d) d.innerHTML=`> ${msg}<br>`+d.innerHTML; }
    function toggleDebug() { const d=document.getElementById('debugLog'); d.style.display=d.style.display==='none'?'block':'none'; }


let config = JSON.parse(localStorage.getItem('oma_conf_v10')) || null;
    let messages = []; 
    // NEU: Eine Merkliste f√ºr gel√∂schte Timestamps
    let hiddenRegistry = new Set(); 
    let currentIndex = 0;

    // === NEU: MERKLISTE F√úR SPRACHNACHRICHTEN ===
    let loadedVoiceFiles = new Set();
    
    // Web Crypto Setup
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    async function getKey(password, salt) {
        const k = await window.crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]);
        return window.crypto.subtle.deriveKey({name:"PBKDF2", salt:salt, iterations:100000, hash:"SHA-256"}, k, {name:"AES-GCM", length:256}, true, ["encrypt","decrypt"]);
    }

// ... getKey bleibt ...

    // NEU: Bin√§rdaten entschl√ºsseln
    async function decryptData(buffer, password) {
        try {
            const bytes = new Uint8Array(buffer);
            // Salt (16) + IV (12) extrahieren
            const s = bytes.slice(0, 16);
            const iv = bytes.slice(16, 28);
            const data = bytes.slice(28); // Der Rest ist die verschl√ºsselte Datei
            
            const k = await getKey(password, s);
            return await window.crypto.subtle.decrypt({name: "AES-GCM", iv: iv}, k, data);
        } catch(e) { 
            console.error("Entschl√ºsselung fehlgeschlagen:", e);
            return null; 
        }
    }

    // Hilfsfunktion: Base64 String zu ArrayBuffer
    function base64ToBuffer(b64) {
        const bin = atob(b64);
        const len = bin.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
        return bytes.buffer;
    }
    
async function processAndAdd(item, silent = false) {
        // 1. TIMESTAMP NORMALISIEREN
        let safeTs = item.ts;
        if (safeTs < 100000000000) safeTs *= 1000;

        // === ALTERSPR√úFUNG (Deine existierende Logik) ===
        if (uiConf.maxDays && uiConf.maxDays > 0) {
            const diffMs = Date.now() - safeTs;
            const diffDays = diffMs / (1000 * 60 * 60 * 24);
            if (diffDays > uiConf.maxDays) {
                return; 
            }
        }
        
        // 2. ZOMBIE CHECK
        if (item.hidden || hiddenRegistry.has(safeTs)) {
            hiddenRegistry.add(safeTs); 
            return; 
        }
        
        // 3. DUPLIKAT CHECK
        const exists = messages.some(m => Math.abs(m.timestamp - safeTs) < 2000);
        if (exists) return;

        // === NEU: Initiale Werte erweitert (audio, isVoice) ===
        let plain = { sender: '?', text: 'Fehler', image: null, audio: null, isVoice: false };
        
        // 4. INHALT ENTSCHL√úSSELN
        if (!item.enc) return;
        const jsonStr = await decryptStr(item.enc, config.pass);
        
        if(jsonStr) {
            try {
                const content = JSON.parse(jsonStr);
                plain.sender = content.sender;
                plain.text = content.text;
                
                // === NEU: PR√úFEN OB SPRACHNACHRICHT ===
                if (content.type === 'voice' || content.audio) {
                    plain.isVoice = true;
                    plain.audio = content.audio; // Das Base64 Audio
                    
                    // Falls kein Text dabei ist, setzen wir einen Platzhalter
                    if (!plain.text) plain.text = "üé§ Sprachnachricht";
                }
                // === ENDE NEU ===

                if (content.image || content.img) plain.image = content.image || content.img;
            } catch(e) { plain.text = "Format Fehler"; }
        } else { return; }

        // 5. BILD LADEN (Nur wenn es KEINE Sprachnachricht ist, um Fehler zu vermeiden)
        if (item.img && !plain.isVoice) {
            let encryptedBuffer = null;
            if (item.img.startsWith('http')) {
                try {
                    const resp = await fetch(item.img);
                    encryptedBuffer = await resp.arrayBuffer();
                } catch(e) {}
            } else {
                encryptedBuffer = base64ToBuffer(item.img);
            }

            if (encryptedBuffer) {
                const decryptedImageBuffer = await decryptData(encryptedBuffer, config.pass);
                if (decryptedImageBuffer) {
                    const blob = new Blob([decryptedImageBuffer], {type: 'image/jpeg'});
                    plain.image = URL.createObjectURL(blob);
                }
            }
        }

        // 6. ZUR LISTE HINZUF√úGEN
        messages.push({
            timestamp: safeTs,
            sender: plain.sender,
            text: plain.text,
            image: plain.image,
            // === NEU: Voice Infos speichern ===
            isVoice: plain.isVoice,
            audio: plain.audio
        });
        
        // SORTIEREN: NEUESTE ZUERST
        messages.sort((a,b) => b.timestamp - a.timestamp);
        
        if (!silent) {
            currentIndex = 0; 
            updateDisplay(); 
            checkNewMessage(safeTs);
        }
    }
    
    
    async function decryptStr(base64Data, password) {
        try {
            if(!base64Data) return null;
            const bin = atob(base64Data);
            const bytes = new Uint8Array(bin.length);
            for(let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
            const salt=bytes.slice(0,16), iv=bytes.slice(16,28), data=bytes.slice(28);
            const key = await getKey(password, salt);
            const decrypted = await window.crypto.subtle.decrypt({name:"AES-GCM", iv:iv}, key, data);
            return dec.decode(decrypted);
        } catch(e) { console.error(e); return null; }
    }

    // Falls Config da ist -> Direkt start
    if(config) {
        document.getElementById('setupScreen').style.display = 'none';
        startApp();
    } else {
        // Setup Formular Felder f√ºllen falls vorhanden
        if(config) {
            document.getElementById('ghUser').value = config.ghUser || "";
            document.getElementById('setupTopic').value = config.ntfyTopic || "";
        }
    }

  // === LOGGING & COOLDOWN LOGIC ===
    
    // Einstellung: Wie lange (in ms) Ruhe geben nach einem Log?
    // 1000 * 60 * 60 = 1 Stunde
    const LOG_COOLDOWN = 1000 * 60 * 60; 

    function smartLog(msg) {
        // 1. History aus dem Speicher laden
        let history = {};
        try { 
            history = JSON.parse(localStorage.getItem('oma_log_history') || '{}'); 
        } catch(e) {}

        const now = Date.now();
        const lastSent = history[msg.timestamp] || 0;

        // 2. Check: Ist die Stunde schon rum?
        if (now - lastSent < LOG_COOLDOWN) {
            // Noch im Cooldown -> ABBRUCH, nichts senden
            return;
        }

        // 3. Wenn wir hier sind: Senden erlaubt!
        sendReadReceipt(msg);

        // 4. Update: "Habe jetzt gesendet" speichern
        history[msg.timestamp] = now;
        localStorage.setItem('oma_log_history', JSON.stringify(history));
    }

    // Die reine Sende-Funktion (ohne Timer, ohne Checks)
    async function sendReadReceipt(msg) {
        // Nur senden, wenn eine DeviceID konfiguriert ist
        if(!config.deviceId) return; 

        // Verschl√ºsselung vorbereiten
        // (Falls encryptStr fehlt, muss es weiter oben definiert sein, siehe vorherige Schritte)
        const logData = {
            type: "read",
            ts: Math.floor(Date.now() / 1000),
            dev: config.deviceId,
            sender: msg.sender,
            msg_ts: msg.timestamp,
            // Snippet k√ºrzen
            snippet: msg.text ? (msg.text.substring(0, 15) + (msg.text.length>15?"...":"")) : "Bild"
        };

        const encLog = await encryptStr(JSON.stringify(logData), config.pass);
        
        if(encLog) {
            // Senden an ntfy
            fetch(`https://ntfy.sh/${config.ntfyTopic}`, {
                method: 'POST',
                body: "LOG_ENTRY", 
                headers: { 'Title': encLog }
            }).then(() => log("Log gesendet.")).catch(e => console.error(e));
        }
    }
    
    // Hilfsfunktion: Text verschl√ºsseln (falls noch nicht vorhanden)
    async function encryptStr(plainText, password) {
        try {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const k = await getKey(password, salt);
            // HIER IST DER FEHLER: da stand "key" statt "k"
            const encData = await window.crypto.subtle.encrypt({name:"AES-GCM", iv:iv}, k, enc.encode(plainText));
            const u8 = new Uint8Array(16 + 12 + encData.byteLength);
            u8.set(salt, 0); u8.set(iv, 16); u8.set(new Uint8Array(encData), 28);
            return btoa(String.fromCharCode(...u8));
        } catch(e) { console.error("Encrypt Error:", e); return null; } // Habe hier auch ein console.error eingebaut
    }

    function saveSetup() {
        const c = {
            ghUser: document.getElementById('ghUser').value.trim(),
            ghRepo: document.getElementById('ghRepo').value.trim(),
            ghToken: document.getElementById('ghToken').value.trim(),
            ntfyTopic: document.getElementById('setupTopic').value.trim(),
            pass: document.getElementById('setupPass').value.trim()
        };
        if(!c.ghUser || !c.ghToken || !c.ntfyTopic || !c.pass) return alert("Alles ausf√ºllen!");
        localStorage.setItem('oma_conf_v10', JSON.stringify(c));
        location.reload();
    }
    function resetApp() { localStorage.removeItem('oma_conf_v10'); location.reload(); }

    // === 2. HAUPTLOGIK ===
   
    async function startApp() {
        await loadGitHubArchive();
        await loadInternetContent();
        // === NEU: SOFORT NACH VOICE SUCHEN ===
        await loadVoiceInbox(); 

        currentIndex = 0;
        updateDisplay();
        
        connectNtfy();
        startConnectionWatchdog(); // <--- DIESE ZEILE IST WICHTIG!
        startDailyReloadTask(); 
        fetchWeather();
        
        
    }

async function loadGitHubArchive() {
        log("Lade GitHub Archiv...");
        try {
            const timeParam = new Date().getTime();
            const url = `https://api.github.com/repos/${config.ghUser}/${config.ghRepo}/contents/messages.json?t=${timeParam}`;
            
            const resp = await fetch(url, { 
                cache: "no-store", 
                headers: { 'Authorization': `Bearer ${config.ghToken}`, 'Accept': 'application/vnd.github.v3.raw' }
            });
            
            if(resp.ok) {
                const archiveData = await resp.json();
                if (Array.isArray(archiveData)) {
                    log(`${archiveData.length} Nachrichten im Archiv.`);
                    
                    for(let item of archiveData) {
                        if(item.hidden) hiddenRegistry.add(item.timestamp);
                        
                        await processAndAdd({
                            ts: item.timestamp,
                            enc: item.enc,
                            img: item.img,
                            hidden: item.hidden 
                        }, true); // Silent = true
                    }
                    
                    // === HIER DIE √ÑNDERUNG ===
                    // Nach dem Laden setzen wir den Index auf 0 (die Neueste)
                    currentIndex = 0;
                    updateDisplay();
                }
            } else { log("Archiv leer/Fehler."); }
        } catch(e) { log("GitHub Fehler: " + e.message); }
    }

    // === GLOBALE VARIABLEN F√úR DIE VERBINDUNG ===
    let es = null;
    let connectionWatchdog = null;

    // === VERBINDUNGSAUFBAU MIT RECONNECT-SCHUTZ ===
    function connectNtfy() {
        // 1. Alte Verbindung sauber schlie√üen, falls vorhanden
        if (es) {
            try { es.close(); } catch(e) {}
            es = null;
        }

        log(`Verbinde zu: ${config.ntfyTopic}...`);
        // Status auf Orange (Verbinde...)
        const statusEl = document.getElementById('statusLight');
        if(statusEl) statusEl.style.background = 'orange';

        // 2. Neue Verbindung √∂ffnen
        es = new EventSource(`https://ntfy.sh/${config.ntfyTopic}/sse?since=all`);
        
        es.onopen = () => {
            log("Verbindung stabil ‚úÖ");
            if(statusEl) statusEl.style.background = '#4cd137'; // Gr√ºn
        };

        es.onerror = (err) => {
            // Fehler anzeigen, aber keinen sofortigen Loop starten (macht der Watchdog)
            if(statusEl) statusEl.style.background = 'red';
        };

        es.onmessage = async (e) => {
            const data = JSON.parse(e.data);
            
            // Keepalive Events ignorieren
            if (data.event === 'keepalive') return;

            const msgTimestamp = data.time;

            if (data.event === 'message') {
                
                if (data.message === "LOG_ENTRY") return; 

                // === ADMIN COMMANDS ===
                try {
                    // Pr√ºfen ob es JSON ist (Command)
                    const cmdData = JSON.parse(data.message);
                    
                    // 1. TARGET CHECK (Bin ich gemeint?)
                    const myId = config.deviceId || "unbekannt";
                    const target = cmdData.target || "ALL"; // Default: Alle
                    
                    // Wenn Target NICHT "ALL" ist UND NICHT meine ID -> Ignorieren
                    if (target !== "ALL" && target !== myId) {
                        return; 
                    }

                    // 2. DELETE (Immer erlaubt, global)
                    if (cmdData.cmd === 'DELETE' && cmdData.ts) {
                        log(`CMD: L√∂sche ${cmdData.ts}`);
                        messages = messages.filter(m => m.timestamp !== cmdData.ts);
                        if (currentIndex >= messages.length) currentIndex = Math.max(0, messages.length - 1);
                        updateDisplay();
                        return; 
                    }

                    // 3. SYSTEM BEFEHLE (Nur einmal pro Timestamp!)
                    const lastCmdTs = parseInt(localStorage.getItem('oma_last_cmd_ts') || '0');
                    if (msgTimestamp <= lastCmdTs) return; // Schon erledigt

                    // Merken, dass wir diesen Befehl ausgef√ºhrt haben
                    localStorage.setItem('oma_last_cmd_ts', msgTimestamp);

                    // --- PING (Status senden) ---
                    if (cmdData.cmd === 'PING') {
                        // Antwortet asynchron in die devices.json
                        registerSelfOnGitHub();
                        return;
                    }

                    // --- RENAME (Umbenennen) ---
                    if (cmdData.cmd === 'RENAME_DEVICE') {
                        if (target === "ALL") return; // Sicherheits-Check
                        if (cmdData.newId) {
                            config.deviceId = cmdData.newId;
                            localStorage.setItem('oma_conf_v10', JSON.stringify(config));
                            log(`Ger√§t umbenannt zu: ${cmdData.newId}`);
                            setTimeout(() => location.reload(), 2000);
                        }
                        return;
                    }

                    // --- RELOAD ---
                    if (cmdData.cmd === 'RELOAD') {
                        log("CMD: Reload");
                        location.reload();
                        return;
                    }

                    // --- TRIGGER ALARM ---
                    if (cmdData.cmd === 'TRIGGER_NEW') {
                        log("CMD: Alarm");
                        if(messages.length > 0) {
                            currentIndex = messages.length - 1;
                            updateDisplay();
                        }
                        // Alarm erzwingen (auch nachts, wenn explizit gefordert)
                        document.getElementById('newMsgOverlay').style.display = 'flex';
                        wakeUp(); // Screensaver beenden
                        return;
                    }

                    // --- SCHRIFT ---
                    if (cmdData.cmd === 'SET_FONTSIZE') {
                        const size = parseFloat(cmdData.val);
                        if(size) {
                            uiConf.textSize = size;
                            localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));
                            applyUi(uiConf.textSize, uiConf.imgSize);
                        }
                        return;
                    }

                    // --- NACHTMODUS ---
                    if (cmdData.cmd === 'CONFIG_NIGHT') {
                        uiConf.nightStart = cmdData.start;
                        uiConf.nightEnd = cmdData.end;
                        localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));
                        checkNightMode(); 
                        return;
                    }

                    // --- NEUSTART ZEIT ---
                    if (cmdData.cmd === 'CONFIG_RESTART') {
                        uiConf.restartTime = cmdData.time;
                        localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));
                        log(`Neustart-Zeit ge√§ndert auf: ${cmdData.time}`);
                        return;
                    }

                } catch(err) { /* Kein JSON-Command -> Normale Nachricht, Fehler ignorieren */ }

                // === 3. NORMALE NACHRICHT ===
                let encPayload = data.attachment ? data.title : data.message;
                let imgData = data.attachment ? data.attachment.url : null;

                await processAndAdd({
                    ts: data.time,
                    enc: encPayload,
                    img: imgData,
                    hidden: false 
                });
            }
        };
    }

    // === DER WACHHUND (WATCHDOG) ===
    // Diese Funktion muss EINMAL in startApp() aufgerufen werden!
    function startConnectionWatchdog() {
        if (connectionWatchdog) clearInterval(connectionWatchdog);

        // Pr√ºfe alle 15 Sekunden
        connectionWatchdog = setInterval(() => {
            // readyState: 0=CONNECTING, 1=OPEN, 2=CLOSED
            // Wenn Verbindung zu (2) oder seit Ewigkeiten versucht zu verbinden (0)
            if (!es || es.readyState === 2) {
                log("Watchdog: Verbindung tot. Neustart...");
                connectNtfy();
            } else if (es.readyState === 0) {
                // H√§ngt im Connecting Status? Resetten.
                log("Watchdog: H√§ngt. Reset...");
                connectNtfy();
            }
        }, 15000);

        // Zus√§tzlich: Wenn Tablet aufwacht und Netzwerk meldet
        window.addEventListener('online', () => {
            log("Netzwerk ist zur√ºck! Reconnect...");
            connectNtfy();
        });
    }
    

    // Navigation
    window.nextMsg = function() { if(currentIndex < messages.length - 1) { currentIndex++; updateDisplay(); } };
    window.prevMsg = function() { if(currentIndex > 0) { currentIndex--; updateDisplay(); } };
    
    document.addEventListener('keydown', (e) => { 
        if(e.key === 'ArrowLeft') prevMsg(); 
        if(e.key === 'ArrowRight') nextMsg(); 
    });

    if(!window.isSecureContext) alert("Achtung: HTTPS erforderlich f√ºr Verschl√ºsselung!");

// === UI TWEAKS LOGIC & LIGHTBOX ===

    // Standards erweitert: Screensaver (20 Min Standard)
    let uiConf = { 
        textSize: 4, 
        imgSize: 50, 
        zoomActive: false, 
        zoomTime: 10,
        nightStart: "22:00", 
        nightEnd: "08:00",
        lat: "52.52", // Default Berlin
        lon: "13.41",
        screensaverMin: 20,
        restartTime: "04:00", // NEU: Minuten bis dunkel (0=aus)
        // NEU: Standardm√§√üig aus
        maxDays: 0,
        showInternet: false 
    }; 
    
    let clickCnt = 0;
    let clickTimer = null;
    let lightboxTimer = null;
    let screensaverTimer = null; // Timer Variable f√ºr Screensaver

    // 1. Beim Start laden
    (function initUi() {
        try {
            const saved = JSON.parse(localStorage.getItem('oma_ui_settings'));
            if(saved) { uiConf = { ...uiConf, ...saved }; }
        } catch(e){}
        
        applyUi(uiConf.textSize, uiConf.imgSize);
        
        // Nachtmodus Check starten (alle 10 Sekunden)
        checkNightMode();
        setInterval(checkNightMode, 10000); 

        // Screensaver starten
        resetIdleTimer();
        
        // Globaler Listener: Bei JEDEM Klick/Touch aufwachen & Timer resetten
        document.addEventListener('click', resetIdleTimer);
        document.addEventListener('touchstart', resetIdleTimer);
    })();

    // Hilfsfunktion: Zeitstring "22:30" in Tagesminuten (1350) umwandeln
    function getMins(timeStr) {
        if (typeof timeStr === 'number') return timeStr * 60; 
        if (!timeStr) return 0;
        const parts = timeStr.split(':');
        return (parseInt(parts[0]) * 60) + parseInt(parts[1]);
    }

    // === SCREENSAVER LOGIC ===
    function resetIdleTimer() {
        // 1. Wenn dunkel -> Aufwecken (Overlay weg)
        wakeUp();

        // 2. Timer neu starten
        clearTimeout(screensaverTimer);
        
        // Nur starten, wenn aktiviert (>0) UND kein "Neue Nachricht" Alarm da ist
        const isAlertOpen = document.getElementById('newMsgOverlay').style.display === 'flex';
        
        if (uiConf.screensaverMin > 0 && !isAlertOpen) {
            const ms = uiConf.screensaverMin * 60 * 1000;
            screensaverTimer = setTimeout(goDark, ms);
        }
    }

function goDark() {
        // Sicherheitscheck: Nicht abdunkeln wenn Alarm an ist
        if (document.getElementById('newMsgOverlay').style.display === 'flex') return;
        
        const el = document.getElementById('screensaverOverlay');
        if(el) {
            el.classList.add('active');
            renderTimeline(); // <--- DIESE ZEILE HINZUF√úGEN! Damit die Daten frisch sind beim Start
        }
    }
    
    function wakeUp() {
        const el = document.getElementById('screensaverOverlay');
        if (el && el.classList.contains('active')) {
            el.classList.remove('active');
        }
    }

    // 2. Secret Click Handler (5x klicken)
    function handleSecretClick() {
        clickCnt++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { 
            if(clickCnt < 5) toggleDebug(); 
            clickCnt = 0; 
        }, 400);

        if(clickCnt >= 5) {
            clickCnt = 0;
            clearTimeout(clickTimer);
            openUiSettings();
        }
    }

// 3. Men√º √∂ffnen & Werte setzen
    function openUiSettings() {
        document.getElementById('uiTweaksModal').style.display = 'flex';
        
        // Slider Werte
        document.getElementById('rangeText').value = uiConf.textSize;
        document.getElementById('rangeImg').value = uiConf.imgSize;
        document.getElementById('valText').innerText = uiConf.textSize;
        document.getElementById('valImg').innerText = uiConf.imgSize;

        // Wohnort
        document.getElementById('inputLat').value = uiConf.lat || "52.52";
        document.getElementById('inputLon').value = uiConf.lon || "13.41";

        // Zoom & Screensaver Einstellungen laden
        document.getElementById('checkZoom').checked = uiConf.zoomActive;
        document.getElementById('numZoomTime').value = uiConf.zoomTime || 10;

        //Wie viele Tage an Nachrichten laden
       document.getElementById('numMaxDays').value = uiConf.maxDays || 0;
        
       //Internet Inhalte        
        document.getElementById('checkInternetContent').checked = uiConf.showInternet || false;
        
        // Automatischer Restart-Zeit
        document.getElementById('inputRestartTime').value = uiConf.restartTime || "04:00";

        
        // NEU: Screensaver Feld f√ºllen (falls vorhanden)
        const saverInput = document.getElementById('numSaverTime');
        if(saverInput) saverInput.value = uiConf.screensaverMin || 0;

        // Device ID laden
        document.getElementById('inputDeviceId').value = config.deviceId || "";
    }
    
    // 4. Live Vorschau beim Schieben (Slider)
    function previewUi() {
        const t = document.getElementById('rangeText').value;
        const i = document.getElementById('rangeImg').value;
        document.getElementById('valText').innerText = t;
        document.getElementById('valImg').innerText = i;
        applyUi(t, i);
    }

// 5. Speichern oder Abbrechen
    function closeUi(save) {
        document.getElementById('uiTweaksModal').style.display = 'none';
        
        if(save) {
            // A) UI Settings speichern
            uiConf.textSize = document.getElementById('rangeText').value;
            uiConf.imgSize = document.getElementById('rangeImg').value;
            uiConf.zoomActive = document.getElementById('checkZoom').checked;
            uiConf.zoomTime = parseInt(document.getElementById('numZoomTime').value) || 10;
            uiConf.restartTime = document.getElementById('inputRestartTime').value;

            uiConf.lat = document.getElementById('inputLat').value;
            uiConf.lon = document.getElementById('inputLon').value;
            
      // NEU: Max Days auslesen
            const newMaxDays = parseInt(document.getElementById('numMaxDays').value) || 0;
            const daysChanged = (uiConf.maxDays !== newMaxDays); // Merken ob ge√§ndert
            uiConf.maxDays = newMaxDays;
            
       // NEU: Internet Checkbox auslesen
        const newShowInternet = document.getElementById('checkInternetContent').checked;

        // Checken ob sich was ge√§ndert hat (bevor wir uiConf √ºberschreiben)
        const internetChanged = (uiConf.showInternet !== newShowInternet);
        
        uiConf.showInternet = newShowInternet;
            
            localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));

             // Wetter sofort neu laden mit neuen Koordinaten
            fetchWeather(); 
            
            // NEU: Screensaver speichern
            const saverVal = document.getElementById('numSaverTime');
            if(saverVal) uiConf.screensaverMin = parseInt(saverVal.value) || 0;

            localStorage.setItem('oma_ui_settings', JSON.stringify(uiConf));
            
            // Timer mit neuen Werten sofort anwenden
            resetIdleTimer();

 

            // LOGIK UPDATE: Wenn sich Internet ODER Tage ge√§ndert haben -> RELOAD
            // Suche den Block wo "if (internetChanged)" steht und √§ndere ihn zu:
            
            if (internetChanged || daysChanged) {
                alert("Einstellungen ge√§ndert (Inhalt/Zeitraum). App wird neu geladen.");
                location.reload();
                return; 
            }
            
            // B) Device ID speichern
            const newId = document.getElementById('inputDeviceId').value.trim();
            const currentId = config.deviceId || "";

            if (newId !== currentId) {
                config.deviceId = newId;
                localStorage.setItem('oma_conf_v10', JSON.stringify(config));
                alert("Ger√§te-ID gespeichert! App wird neu geladen.");
                location.reload(); 
                return;
            }

            alert("Einstellungen gespeichert!");
        } else {
            // Reset auf alte Werte bei Abbruch
            applyUi(uiConf.textSize, uiConf.imgSize);
        }
    }
    
    // 6. Werte anwenden (CSS)
    function applyUi(textVal, imgVal) {
        const txt = document.getElementById('messageText');
        const img = document.getElementById('messageImg');
        if(txt) txt.style.fontSize = textVal + "vh";
        if(img) img.style.maxHeight = imgVal + "vh";
    }

    // === NEU: LIGHTBOX FUNKTIONEN ===
    
    function openLightbox() {
        // Nur √∂ffnen, wenn im Admin-Men√º aktiviert UND ein Bild da ist
        const src = document.getElementById('messageImg').src;
        if(!uiConf.zoomActive || !src || document.getElementById('messageImg').style.display === 'none') return;

        const lb = document.getElementById('lightbox');
        const lbImg = document.getElementById('lightboxImg');
        
        lbImg.src = src;
        lb.style.display = 'flex'; // Zeigen

        // Auto-Close Timer starten
        clearTimeout(lightboxTimer); // Sicherheitshalber alte Timer l√∂schen
        const ms = uiConf.zoomTime * 1000;
        lightboxTimer = setTimeout(closeLightbox, ms);
        
        log(`Lightbox offen f√ºr ${uiConf.zoomTime}s`);
    }

    function closeLightbox() {
        const lb = document.getElementById('lightbox');
        lb.style.display = 'none';
        clearTimeout(lightboxTimer); // Timer stoppen, falls manuell geschlossen
    }
// === NEU: NOTIFICATION LOGIC ===
    
    // Cache laden oder erstellen
    let seenCache = {};
    try {
        seenCache = JSON.parse(localStorage.getItem('oma_seen_msgs') || '{}');
    } catch(e) {}

// HILFSFUNKTION: Ist es gerade Schlafenszeit?
    function isNightTime() {
        if (!uiConf.nightStart || !uiConf.nightEnd) return false;

        const now = new Date();
        const curMins = (now.getHours() * 60) + now.getMinutes();
        const startMins = getMins(uiConf.nightStart);
        const endMins = getMins(uiConf.nightEnd);

        if (startMins > endMins) {
            // Geht √ºber Mitternacht (z.B. 22:00 bis 08:00)
            return (curMins >= startMins || curMins < endMins);
        } else {
            // Gleicher Tag (z.B. 13:00 bis 15:00 - Mittagsschlaf)
            return (curMins >= startMins && curMins < endMins);
        }
    }

function checkNightMode() {
        const overlay = document.getElementById('nightOverlay');
        const isNight = isNightTime();
        const wasNight = overlay.style.display === 'block';

        if (isNight) {
            if(!wasNight) overlay.style.display = 'block';
        } else {
            if(wasNight) {
                // GUTE MORGEN LOGIK:
                overlay.style.display = 'none';
                
                // Pr√ºfen, ob wir was verpasst haben, w√§hrend wir geschlafen haben
                // Wir schauen uns die aktuellste Nachricht an
                if(messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    // Wenn die noch nicht gesehen wurde -> Alarm jetzt nachholen!
                    checkNewMessage(lastMsg.timestamp);
                }
            }
        }
    }

    
    // ALARM CHECKER (Jetzt mit Nachtruhe-Schutz)
    function checkNewMessage(ts) {
        // 1. DER WICHTIGSTE CHECK:
        // Wenn es Nacht ist -> ABBRUCH. Kein Aufwecken, kein Overlay.
        // Die Nachricht wird geladen, aber stillschweigend.
        if (isNightTime()) {
            console.log("Nachtmodus aktiv: Nachricht empfangen, aber Alarm unterdr√ºckt.");
            return; 
        }

        // 2. Wenn Tag ist -> Normales Verhalten
        wakeUp(); // Screensaver weg
        
        // Wenn Timestamp noch NICHT im Cache ist -> ALARM!
        if (!seenCache[ts]) {
            const overlay = document.getElementById('newMsgOverlay');
            if (overlay.style.display !== 'flex') {
                overlay.style.display = 'flex';
                clearTimeout(screensaverTimer);
            }
        }
    }

    
// Funktion: Wird beim Klick auf das Overlay ausgef√ºhrt
    function dismissNotification() {
        // 1. Overlay ausblenden
        document.getElementById('newMsgOverlay').style.display = 'none';

        // 2. Alle aktuell geladenen Nachrichten als "gesehen" markieren
        const now = Date.now();
        messages.forEach(m => {
            seenCache[m.timestamp] = now; 
        });

        // 3. Aufr√§umen (Pruning > 14 Tage)
        const FOURTEEN_DAYS = 14 * 24 * 60 * 60 * 1000;
        for (const [ts, seenTime] of Object.entries(seenCache)) {
            if (now - seenTime > FOURTEEN_DAYS) {
                delete seenCache[ts];
            }
        }

        // 4. Speichern
        localStorage.setItem('oma_seen_msgs', JSON.stringify(seenCache));
        
        // NEU: Jetzt wo der Alarm best√§tigt ist, darf der Screensaver-Countdown wieder laufen
        resetIdleTimer();
    }
    
    // === DEVICE REGISTRATION (PING ANTWORT) ===
    async function registerSelfOnGitHub() {
        if(!config.ghUser || !config.ghToken) return;

        log("PING empfangen! Registriere...");
        
        // 1. Zuf√§llige Wartezeit (0-10s) gegen Kollisionen bei "PING ALL"
        const delay = Math.floor(Math.random() * 10000);
        await new Promise(r => setTimeout(r, delay));

        try {
            const myId = config.deviceId || "unbekannt";
            
            // 2. Aktuelle Liste laden
            const url = `https://api.github.com/repos/${config.ghUser}/${config.ghRepo}/contents/devices.json`;
            const header = { 'Authorization': `Bearer ${config.ghToken}`, 'Accept': 'application/vnd.github.v3+json' };
            
            let devices = [];
            let sha = null;

            const resp = await fetch(url, { headers: header, cache: "no-store" });
            
            if(resp.ok) {
                const fileData = await resp.json();
                sha = fileData.sha;
                // Sauberes Decoding
                const rawContent = fileData.content.replace(/\s/g, '');
                try {
                    devices = JSON.parse(decodeURIComponent(escape(atob(rawContent))));
                } catch(e){}
            } 

            // 3. Akku Status holen (falls m√∂glich)
            let batt = "?";
            try {
                const b = await navigator.getBattery();
                batt = Math.round(b.level * 100);
            } catch(e){}

            // 4. Liste updaten
            const now = Math.floor(Date.now() / 1000);
            const myEntry = {
                id: myId,
                lastSeen: now,
                battery: batt,
                userAgent: navigator.userAgent
            };

            // Pr√ºfen ob ID schon existiert -> √úberschreiben, sonst Hinzuf√ºgen
            const idx = devices.findIndex(d => d.id === myId);
            if(idx >= 0) devices[idx] = myEntry;
            else devices.push(myEntry);

            // 5. Hochladen
            const newContent = btoa(unescape(encodeURIComponent(JSON.stringify(devices, null, 2))));
            const body = {
                message: `Device Update: ${myId}`,
                content: newContent
            };
            if(sha) body.sha = sha;

            await fetch(url, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${config.ghToken}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            log("Ger√§teliste aktualisiert ‚úÖ");

        } catch(e) {
            console.error(e);
            // Log nur lokal, um Loop zu vermeiden
        }
    }

    
// === 1. SMART DATE HELFER (OMA EDITION) ===
    function getSmartDate(ts) {
        const date = new Date(ts);
        const now = new Date();
        
        // Uhrzeit formatieren (14:30)
        const timeStr = date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});

        // Nur das Datum ohne Uhrzeit vergleichen
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        const msgDay = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        
        // Unterschied in Tagen berechnen
        const diffDays = Math.round((today - msgDay) / (1000 * 60 * 60 * 24));
        
        // Wochentag auslesen (z.B. "Montag")
        const weekday = date.toLocaleDateString([], {weekday:'long'});

        let dayStr = "";

        // Die Oma-Logik:
        if (diffDays === 0) {
            dayStr = "Heute";
        } else if (diffDays === 1) {
            dayStr = "Gestern";
        } else if (diffDays === 2) {
            dayStr = "Vorgestern";
        } else if (diffDays < 7) {
            // Innerhalb der letzten Woche: "Am Dienstag"
            dayStr = "Am " + weekday;
        } else {
            // √Ñlter als eine Woche: "Letzten Dienstag"
            dayStr = "Letzten " + weekday;
        }

        return { day: dayStr, time: timeStr + " Uhr" };
    }

    // === 2. SLIDESHOW LOGIK (Bleibt gleich) ===
    let slideTimer = null;
    function toggleSlideshow() {
        const btn = document.getElementById('playBtn');
        const txt = document.getElementById('playText');
        const icon = document.getElementById('playIcon');

        if (slideTimer) {
            clearInterval(slideTimer);
            slideTimer = null;
            btn.classList.remove('active');
            txt.innerText = "Abspielen";
            icon.innerText = "‚ñ∂";
        } else {
            if(messages.length === 0) return;
            currentIndex = 0;
            updateDisplay();

            btn.classList.add('active');
            txt.innerText = "Stop";
            icon.innerText = "‚èπ";

            slideTimer = setInterval(() => {
                if (currentIndex < messages.length - 1) {
                    currentIndex++;
                    updateDisplay();
                } else {
                    toggleSlideshow(); // Ende -> Stop
                }
            }, 8000);
        }
    }

    // === 3. UPDATE DISPLAY ===
    window.updateDisplay = function() {
        if(messages.length === 0) {
            // ... (Dein "Keine Nachrichten" Code) ...
            return;
        }
        
          const msg = messages[currentIndex];
        
        // 1. Header Infos setzen (Das behebt das "Oma" Problem im Header)
        // msg.sender kommt direkt aus dem JSON vom Sender. 
        // Wenn da "Papa" drin stand, steht hier jetzt "Papa".
        document.getElementById('metaSender').innerText = msg.sender;
        
        const smart = getSmartDate(msg.timestamp);
        document.getElementById('metaTime').innerText = smart.day;
        document.getElementById('metaDate').innerText = smart.time;

        // UI Elemente
        const txtEl = document.getElementById('messageText');
        const imgEl = document.getElementById('messageImg');
        const voiceEl = document.getElementById('voiceContainer');
        const btnVoice = document.getElementById('btnPlayVoice');

        // Reset Voice Button
        btnVoice.classList.remove('playing');
        document.getElementById('voiceIcon').innerText = "üîä";
        document.getElementById('voiceLabel').innerHTML = "Hier dr√ºcken<br>zum Anh√∂ren";

        if (msg.isVoice) {
            // === VOICE MODUS ===
            txtEl.style.display = 'none';
            imgEl.style.display = 'none';
            voiceEl.style.display = 'flex';
            
            // Zusatz-Infos f√ºllen (Datum & Uhrzeit gro√ü)
            // Das hilft Oma zu sehen: "Ah, das ist die von 14:05 Uhr"
            const dateObj = new Date(msg.timestamp);
            document.getElementById('voiceDateVal').innerText = dateObj.toLocaleDateString();
            document.getElementById('voiceTimeVal').innerText = dateObj.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) + " Uhr";

            // Slideshow stoppen bei Sprachnachricht
            if (slideTimer) toggleSlideshow();

        } else {
            // === NORMALER MODUS ===
            voiceEl.style.display = 'none';
            txtEl.style.display = 'block';
            
            txtEl.innerText = msg.text || "";
            if(msg.image) {
                imgEl.src = msg.image; 
                imgEl.style.display = 'block';
            } else {
                imgEl.style.display = 'none';
            }
        }

        smartLog(msg);
    };
    
// === 4. AUTOMATISCHER REFRESH (STRIKT & EINFACH) ===
function startDailyReloadTask() {
    // Wir pr√ºfen alle 5 Sekunden, um die Minute sicher zu treffen
    setInterval(() => {
        // 1. Config Wert nehmen (z.B. "04:00" oder "19:00")
        // Dieser Wert kommt direkt aus deinem uiConf (das im LocalStorage gespeichert ist)
        const planTime = uiConf.restartTime; 
        if (!planTime) return;

        // 2. Aktuelle Zeit als String bauen ("HH:MM")
        const now = new Date();
        const h = String(now.getHours()).padStart(2, '0');
        const m = String(now.getMinutes()).padStart(2, '0');
        const currentTime = `${h}:${m}`;

        // 3. Strikter Vergleich: Ist JETZT die eingestellte Zeit?
        if (currentTime === planTime) {
            
            // Schutz vor Endlos-Schleife in dieser einen Minute:
            // Wir schauen in den Session-Speicher (der √ºberlebt den Reload kurz), 
            // ob wir genau f√ºr DIESE Zeit ("19:00") schon den Befehl hatten.
            const lastDone = sessionStorage.getItem('last_reload_time');

            if (lastDone !== currentTime) {
                console.log(`Es ist ${currentTime} -> Neustart wird ausgef√ºhrt!`);
                
                // Sofort markieren: "F√ºr 19:00 Uhr erledigt"
                sessionStorage.setItem('last_reload_time', currentTime);
                
                // Hart neu laden
                location.reload(true);
            }
        }
    }, 5000); // Check alle 5 Sekunden
}
        
// === 5. SWIPE GESTEN (Wischen) ===
    let touchStartX = 0;
    let touchStartY = 0;

    // Startpunkt merken
    document.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].clientX; // clientX ist pr√§ziser als screenX
        touchStartY = e.changedTouches[0].clientY;
    }, {passive: true});

    // Endpunkt auswerten
    document.addEventListener('touchend', e => {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        
        handleGesture(touchStartX, touchStartY, touchEndX, touchEndY);
    }, {passive: true});

    function handleGesture(sX, sY, eX, eY) {
        const xDiff = sX - eX;
        const yDiff = Math.abs(sY - eY);
        
        // 1. Toleranz-Check:
        // Wenn Oma versucht hat zu scrollen (mehr Bewegung hoch/runter als links/rechts),
        // dann ignorieren wir den Swipe. Das verhindert versehentliches Bl√§ttern beim Lesen.
        if (yDiff > Math.abs(xDiff)) return;

        // 2. Distanz-Check:
        // Mindestens 50px weit gewischt?
        if (Math.abs(xDiff) > 50) {
            if (xDiff > 0) {
                // Finger bewegte sich nach LINKS (Differenz positiv) -> N√§chste Nachricht
                nextMsg(); 
            } else {
                // Finger bewegte sich nach RECHTS (Differenz negativ) -> Vorherige Nachricht
                prevMsg();           
            }
        }
    }
// ==========================================
    // === ECHTE WETTER DATEN (OPEN-METEO) ===
    // ==========================================
    
    let weatherCache = null; // Hier speichern wir die Daten zwischen

    // Mapping von WMO-Codes zu Emojis
 // Ersetzt: Mapping von WMO-Codes zu ANIMIERTEM HTML
    function getWeatherAnim(code) {
        // Sonne (Code 0)
        if (code === 0) {
            return `<div class="w-icon"><div class="w-rays"></div><div class="w-sun"></div></div>`;
        }
        // Leicht bew√∂lkt (1-3)
        if (code >= 1 && code <= 3) {
            return `<div class="w-icon w-partly-cloudy"><div class="w-sun"></div><div class="w-cloud"></div></div>`;
        }
        // Nebel (45, 48)
        if (code === 45 || code === 48) {
            return `<div class="w-icon"><div class="w-fog"></div></div>`;
        }
        // Regen / Niesel (51-67, 80-82)
        if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82)) {
            return `<div class="w-icon"><div class="w-cloud"></div><div class="w-rain"><div class="w-drop"></div><div class="w-drop"></div><div class="w-drop"></div></div></div>`;
        }
        // Schnee (71-77)
        if (code >= 71 && code <= 77) {
            return `<div class="w-icon"><div class="w-cloud"></div><div class="w-snow"><div class="w-flake">‚ùÑ</div><div class="w-flake">‚ùÑ</div></div></div>`;
        }
        // Gewitter (95+)
        if (code >= 95) {
            return `<div class="w-icon w-storm"><div class="w-cloud"></div><div class="w-bolt">‚ö°</div></div>`;
        }
        
        // Fallback: Einfach Wolke
        return `<div class="w-icon"><div class="w-cloud"></div></div>`;
    }
    
    // Daten von Open-Meteo holen
    async function fetchWeather() {
        if(!uiConf.lat || !uiConf.lon) return;
        
        log("Lade Wetter...");
        try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${uiConf.lat}&longitude=${uiConf.lon}&hourly=temperature_2m,precipitation_probability,weathercode&timezone=auto&forecast_days=2`;
            
            const resp = await fetch(url);
            const data = await resp.json();
            
            if(data.hourly) {
                weatherCache = data;
                log("Wetter aktualisiert üå§Ô∏è");
                renderTimeline(); // Sofort updaten
            }
        } catch(e) {
            console.error("Wetter Fehler:", e);
        }
    }

   // Diese Funktion holt die Daten f√ºr eine bestimmte Stunde aus dem Cache
    function getRealData(hour) {
        // Falls noch keine Daten da sind -> Lade-Dummy
        if (!weatherCache || !weatherCache.hourly) return { i: "‚è≥", t: "--¬∞", r: "--%" };

        const now = new Date();
        const currentHour = now.getHours();

        // 1. ZIELZEIT BERECHNEN
        // Wir gehen erst mal davon aus, dass die Stunde HEUTE gemeint ist.
        let targetTime = new Date();
        targetTime.setHours(hour, 0, 0, 0);

        // 2. DER FIX (TOLERANZ-CHECK):
        // Wir springen nur auf "Morgen", wenn die gesuchte Stunde SEHR weit in der Vergangenheit liegt.
        // Beispiel 19:00 Uhr:
        // - Wir suchen 18:00: Differenz ist 1 Stunde. Das ist < 5. -> Bleibt HEUTE.
        // - Wir suchen 02:00: Differenz ist 17 Stunden. Das ist > 5. -> Wird MORGEN.
        if ((currentHour - hour) > 5) {
             targetTime.setDate(targetTime.getDate() + 1);
        }

        // 3. DATEN IM CACHE SUCHEN
        // Wir loopen durch die Zeit-Liste und suchen den passenden Zeitstempel.
        // Das ist sicherer als String-Vergleiche, da "targetTime" jetzt korrektes Datum hat.
        let index = -1;
        const times = weatherCache.hourly.time;
        
        for(let i=0; i < times.length; i++) {
            // Open-Meteo liefert ISO-Strings. new Date() parst das korrekt zur lokalen Zeit.
            const entryDate = new Date(times[i]);
            
            // Wir pr√ºfen, ob die Zeit √ºbereinstimmt (Toleranz < 30 min)
            if (Math.abs(entryDate - targetTime) < 1800000) { 
                index = i;
                break; // Gefunden!
            }
        }

        if (index !== -1) {
            const code = weatherCache.hourly.weathercode[index];
            const temp = Math.round(weatherCache.hourly.temperature_2m[index]);
            const rain = weatherCache.hourly.precipitation_probability[index];
            
            return {
            //Alt:    i: getWeatherEmoji(code),
                i: getWeatherAnim(code), // <--- NEU: Animierte Funktion
                t: temp + "¬∞",
                r: rain + "%"
            };
        }
        
        // Fallback (z.B. wenn es 1 Uhr nachts ist und wir Daten von "Gestern 22 Uhr" suchen, 
        // die API aber erst ab "Heute 00 Uhr" liefert)
        return { i: getWeatherAnim(3), t: "--¬∞", r: "--%" }; // Default Wolke
    }
    // Timeline rendern (angepasst auf getRealData)
    const WEATHER_LABELS = { 2: "Nachts", 6: "Morgens", 10: "Mittags", 14: "Nachm.", 18: "Abends", 22: "Sp√§t" };

    function renderTimeline() {
        const saver = document.getElementById('screensaverOverlay');
        // Update auch wenn unsichtbar, damit Clock stimmt, aber API Aufrufe sparen wir uns
        updateSaverClock();

        // Nur Rendern wenn sichtbar ODER beim ersten Start
        if (!saver.classList.contains('active') && saver.style.opacity !== '1') return;
        
        // Falls Cache leer -> Laden!
        if (!weatherCache) { fetchWeather(); }

        const now = new Date();
        const currentHour = now.getHours();

        // 1. Startblock berechnen
        let startBlock = 2;
        if (currentHour >= 22 || currentHour < 2) startBlock = 22;
        else if (currentHour >= 18) startBlock = 18;
        else if (currentHour >= 14) startBlock = 14;
        else if (currentHour >= 10) startBlock = 10;
        else if (currentHour >= 6) startBlock = 6;

        const container = document.getElementById('forecastRow');
        container.innerHTML = ""; 

        for (let i = 0; i < 4; i++) {
            let h = startBlock + (i * 4);
            if (h >= 24) h -= 24; 
            
            let endH = h + 4;
            if (endH >= 24) endH -= 24;
            
            const hStr = String(h).padStart(2, '0');
            const endHStr = String(endH).padStart(2, '0');
            
            // HIER RUFEN WIR JETZT DIE ECHTEN DATEN AB
            const data = getRealData(h);
            const label = WEATHER_LABELS[h] || "Zeit";
            
            const div = document.createElement('div');
            div.className = 'weather-card';
            if (i === 0) div.classList.add('current'); 

            div.innerHTML = `
                <div class="slot-name">${label}</div>
                <div class="slot-time">${hStr} - ${endHStr} Uhr</div>
                <div class="slot-icon">${data.i}</div>
                <div class="slot-temp">${data.t}</div>
                <div class="slot-rain">üíß ${data.r}</div>
            `;
            container.appendChild(div);
        }
    }
    
    // Update Clock Helper
    function updateSaverClock() {
        const now = new Date();
        document.getElementById('saverClock').innerText = now.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) + " Uhr";
        document.getElementById('saverDate').innerText = now.toLocaleDateString('de-DE', { weekday: 'long', day: 'numeric', month: 'long' });
    }

    // Intervalle starten
    setInterval(renderTimeline, 60000); // UI Update jede Minute
    setInterval(fetchWeather, 1000 * 60 * 60); // Wetter Update jede Stunde
       // === NEU: VOICE UPDATE (Jede Minute) ===
    setInterval(loadVoiceInbox, 60000);

// === ROBUSTE LADEFUNKTION MIT BASE64 DECODING ===
// === ROBUSTE LADEFUNKTION MIT BILD-PRELOAD ===
async function loadInternetContent() {
    if (!uiConf.showInternet) {
        log("Info: Internet-Inhalte deaktiviert.");
        return;
    }

    log("üåê Lade Internet-Inhalte...");
    
    const files = [
        'wiki-bild-des-tages.json',
        'wiki-reiseziel.json',
        'wiki-history.json'
    ];
    
    const t = new Date().getTime(); // Cache Buster
    let count = 0;

    for (const file of files) {
        try {
            const url = `https://api.github.com/repos/${config.ghUser}/${config.ghRepo}/contents/internet/${file}?t=${t}`;
            
            const resp = await fetch(url, {
                headers: { 'Authorization': `Bearer ${config.ghToken}` }
            });

            if (!resp.ok) continue;

            const apiResponse = await resp.json();
            if (!apiResponse.content) continue;

            // Base64 Decode
            const cleanB64 = apiResponse.content.replace(/\s/g, '');
            const decodedStr = decodeURIComponent(escape(window.atob(cleanB64)));
            const data = JSON.parse(decodedStr);

            if (!data.ts) data.ts = Date.now();

            // === HIER IST DER FIX: BILD VORLADEN ===
            let finalImage = data.img_url;

            if (data.img_url && data.img_url.startsWith('http')) {
                try {
                    // Wir laden das Bild JETZT herunter und speichern es als Blob
                    // Damit ist es beim Anzeigen sofort verf√ºgbar (kein Ruckeln mehr)
                    const imgFetch = await fetch(data.img_url);
                    if (imgFetch.ok) {
                        const blob = await imgFetch.blob();
                        finalImage = URL.createObjectURL(blob);
                    }
                } catch (err) {
                    console.log(`Bild-Preload Fehler bei ${file}:`, err);
                    // Fallback: Wir lassen die URL, falls Preload nicht klappt
                }
            }

            messages.push({
                timestamp: data.ts,
                sender: data.source || "Internet",
                text: data.text,
                image: finalImage, // Hier ist jetzt der schnelle Blob-Link drin
                isPublic: true
            });
            
            count++;

        } catch (e) {
            console.error(`Fehler bei ${file}:`, e);
        }
    }
    
    if (count > 0) {
        log(`‚úÖ ${count} Internet-News geladen.`);
        // WICHTIG: Sortieren, damit die neuen Sachen auch wirklich oben sind
        messages.sort((a,b) => b.timestamp - a.timestamp);
    }
}


// === VOICE RECORDER LOGIC (ENCRYPTED) ===
let mediaRecorder = null;
let audioChunks = [];
let recInterval = null;
let recSeconds = 0;
let recordedBlob = null;

// 1. UI √ñffnen
function openVoiceUI() {
    document.getElementById('voiceModal').style.flex = 'flex'; // Flex statt Block f√ºr Zentrierung
    document.getElementById('voiceModal').style.display = 'flex';
    resetRecUI();
}

function closeVoiceUI() {
    if(mediaRecorder && mediaRecorder.state === "recording") stopRecording();
    document.getElementById('voiceModal').style.display = 'none';
}

function resetRecUI() {
    recSeconds = 0;
    audioChunks = [];
    recordedBlob = null;
    document.getElementById('recTimer').innerText = "00:00";
    document.getElementById('recStatus').innerText = "Bereit zur Aufnahme";
    // Start Button zeigen
    document.getElementById('recBtns').innerHTML = `
        <button class="btn-rec btn-start" onclick="startRecording()">üéôÔ∏è</button>
    `;
}

// 2. Aufnahme Starten
async function startRecording() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream); // Standard Format (WebM)
        
        mediaRecorder.ondataavailable = event => {
            audioChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
            // Wenn Stop gedr√ºckt wurde: Blob erstellen
            recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
            showSendUI();
        };

        mediaRecorder.start();
        
        // UI Update
        document.getElementById('recStatus').innerText = "üî¥ Aufnahme l√§uft...";
        document.getElementById('recBtns').innerHTML = `
            <button class="btn-rec btn-stop" onclick="stopRecording()">‚¨õ</button>
        `;
        
        // Timer starten
        recInterval = setInterval(() => {
            recSeconds++;
            const s = recSeconds < 10 ? "0"+recSeconds : recSeconds;
            document.getElementById('recTimer').innerText = "00:" + s;
            if(recSeconds >= 60) stopRecording(); // Max 60 sek
        }, 1000);

    } catch(e) {
        alert("Mikrofon Zugriff verweigert oder Fehler: " + e);
        closeVoiceUI();
    }
}

// 3. Aufnahme Stoppen
function stopRecording() {
    if(mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(track => track.stop()); // Mic freigeben
    }
    clearInterval(recInterval);
}

// 4. Senden UI anzeigen
function showSendUI() {
    document.getElementById('recStatus').innerText = "Aufnahme fertig!";
    document.getElementById('recBtns').innerHTML = `
        <button class="btn-rec" style="background:#555; font-size:20px;" onclick="resetRecUI()">‚Ü∫</button>
        <button class="btn-rec btn-send" onclick="encryptAndUploadVoice()">Senden üöÄ</button>
    `;
}

// 5. Verschl√ºsseln & Hochladen
async function encryptAndUploadVoice() {
    if(!recordedBlob || !config.ghToken) return;
    
    document.getElementById('recStatus').innerText = "Verschl√ºssele & Sende...";
    
    // A. Blob zu Base64 konvertieren
    const reader = new FileReader();
    reader.readAsDataURL(recordedBlob); 
    reader.onloadend = async function() {
        const base64Audio = reader.result;
        
        // B. Payload bauen
        const payload = {
            sender: "Oma", // Fester Absender
            ts: Date.now(),
            audio: base64Audio
        };
        
        // C. VERSCHL√úSSELN (Nutzt deine existierende encryptStr Funktion!)
        const encryptedContent = await encryptStr(JSON.stringify(payload), config.pass);
        
        if(!encryptedContent) {
            alert("Fehler bei Verschl√ºsselung!");
            return;
        }
        
        // D. Wrapper f√ºr Upload bauen (√Ñhnlich wie Messages)
        const uploadObj = {
            sender: "Oma",
            ts: payload.ts,
            enc: encryptedContent // Hier ist das verschl√ºsselte Audio drin
        };
        
        // E. Hochladen zu GitHub (Neue Datei pro Nachricht)
        const filename = `voice_inbox/voice_${payload.ts}.json`;
        const url = `https://api.github.com/repos/${config.ghUser}/${config.ghRepo}/contents/${filename}`;
        
        const contentBase64 = btoa(unescape(encodeURIComponent(JSON.stringify(uploadObj, null, 2))));
        
        try {
            const resp = await fetch(url, {
                method: 'PUT',
                headers: { 
                    'Authorization': `Bearer ${config.ghToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: "New Voice from Oma",
                    content: contentBase64
                })
            });
            
            if(resp.ok) {
                document.getElementById('recStatus').innerText = "Gesendet! ‚úÖ";
                setTimeout(closeVoiceUI, 2000);
            } else {
                alert("Upload Fehler: " + resp.status);
            }
        } catch(e) {
            alert("Netzwerk Fehler: " + e);
        }
    };
}

  // === VOICE PLAYBACK LOGIC ===
    let activeAudio = null;
    let wasSlideshowActive = false;

    function playCurrentVoice() {
        const msg = messages[currentIndex];
        if(!msg.isVoice || !msg.audio) return;

        const btn = document.getElementById('btnPlayVoice');
        const icon = document.getElementById('voiceIcon');
        const label = document.getElementById('voiceLabel');

        // STOPPEN
        if (activeAudio) {
            activeAudio.pause();
            activeAudio = null;
            btn.classList.remove('playing');
            icon.innerText = "üîä";
            label.innerHTML = "Fortsetzen"; // Feedback
            return;
        }

        // Slideshow Status merken
        if (slideTimer) {
            wasSlideshowActive = true;
            toggleSlideshow();
        } else {
            wasSlideshowActive = false;
        }

        // STARTEN
        activeAudio = new Audio(msg.audio);
        activeAudio.play();
        
        // UI Update (Rot & Text √§ndern)
        btn.classList.add('playing');
        icon.innerText = "üëÇ"; 
        label.innerHTML = "Ich h√∂re zu...";

        // ENDE
        activeAudio.onended = () => {
            activeAudio = null;
            btn.classList.remove('playing');
            icon.innerText = "‚úÖ";
            label.innerHTML = "Fertig!<br>Nochmal?";
            
            setTimeout(() => {
                if (wasSlideshowActive) toggleSlideshow();
                // Nach 5 Sek wieder neutraler Text
                icon.innerText = "üîä";
                label.innerHTML = "Hier dr√ºcken<br>zum Anh√∂ren";
            }, 5000);
        };
    }
    
    // === NEU: SPRACHNACHRICHTEN VON GITHUB LADEN ===
    async function loadVoiceInbox() {
        if (!config.ghUser || !config.ghRepo || !config.ghToken) return;
        
        // console.log("üéôÔ∏è Pr√ºfe auf Sprachnachrichten..."); // Optional f√ºr Debugging

        try {
            // 1. Inhalt des Ordners 'voice_inbox' abrufen
            // wir nutzen t=... als Cache Buster, damit wir immer die neueste Liste kriegen
            const url = `https://api.github.com/repos/${config.ghUser}/${config.ghRepo}/contents/voice_inbox?t=${Date.now()}`;
            const resp = await fetch(url, { 
                headers: { 'Authorization': `Bearer ${config.ghToken}`, 'Accept': 'application/vnd.github.v3+json' }
            });

            if (resp.status === 404) return; // Ordner leer oder existiert noch nicht
            if (!resp.ok) return;

            const files = await resp.json();

            // 2. Jede Datei pr√ºfen
            for (const file of files) {
                // Nur JSONs und nur neue Dateien
                if (!file.name.endsWith('.json') || loadedVoiceFiles.has(file.name)) continue;

                // 3. Inhalt der Datei laden
                const fileResp = await fetch(file.url, { 
                    headers: { 'Authorization': `Bearer ${config.ghToken}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                
                if (fileResp.ok) {
                    const fileJson = await fileResp.json();
                    
                    // GitHub Content ist base64 codiert -> Decodieren
                    const rawContent = fileJson.content.replace(/\s/g, '');
                    const jsonString = decodeURIComponent(escape(atob(rawContent)));
                    const data = JSON.parse(jsonString);
                    
                    // data sieht so aus: { sender: "...", ts: 123, enc: "VERSCHL√úSSELT..." }
                    
                    // 4. An die Verarbeitungs-Zentrale √ºbergeben
                    await processAndAdd({
                        ts: data.ts,
                        enc: data.enc, // Das hier enth√§lt Audio & Type Info
                        img: null,
                        hidden: false
                    });

                    // 5. Als "erledigt" markieren
                    loadedVoiceFiles.add(file.name);
                }
            }
        } catch (e) {
            console.error("Fehler beim Laden der Voice Inbox:", e);
        }
    }
    
</script>
</body>
</html>
