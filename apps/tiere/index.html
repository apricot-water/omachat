<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1">
<title>Tier Ticker üêæ</title>
<meta name="theme-color" content="#000000">

<!-- PWA MANIFEST -->
<link rel="manifest" href='data:application/manifest+json,{"name":"Tier Ticker","short_name":"Tier Ticker","start_url":".","display":"standalone","background_color":"#121212","theme_color":"#2196f3","icons":[{"src":"https://emojicdn.elk.sh/üêæ","sizes":"192x192","type":"image/png"}]}'>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- LEAFLET MAP CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

<!-- Google Font: Fredoka (Rund & Verspielt) -->
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@500;700&display=swap" rel="stylesheet">

<!-- Handschrift-Font f√ºr die Karten -->
<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@600&display=swap" rel="stylesheet">

<style>
/* =========================================
   1. VARIABLES & RESET
   ========================================= */
*, *::before, *::after { box-sizing: border-box; }

:root{
    --bg:#f0f2f5;
    --card:rgba(255, 255, 255, 0.85);
    --card-solid:#fff;
    --text:#1c1e21;
    --btn:#e4e6eb;
    --hover:#d8dadf;
    --accent:#2196f3;
    --accent-glow: rgba(33, 150, 243, 0.4);
    --warn-bg:#fff3cd; --warn-text:#856404;
    --err-bg:#f8d7da; --err-text:#721c24;
    --sub:#65676b; 
    --nav-height: 70px;
    --glass-border: 1px solid rgba(255, 255, 255, 0.6);
    --shadow: 0 4px 12px rgba(0,0,0,0.08);
--accent: #2196f3;
--paw-color: #ff9f43; 
}
/* === FIX: H√ÑSSLICHES VIERECK BEIM KLICKEN ENTFERNEN === */
* {
    /* Deaktiviert die graue/blaue Standard-Markierung auf Mobile */
    -webkit-tap-highlight-color: transparent;
    
    /* Verhindert, dass man Text/Icons aus Versehen markiert beim schnellen Tippen */
    -webkit-touch-callout: none; 
    user-select: none;
}

/* Text-Inputs m√ºssen ausw√§hlbar bleiben, sonst kann man nicht tippen! */
input, textarea {
    user-select: text !important;
    -webkit-user-select: text !important;
}
   
body.dark {
    /* TRUE OLED BLACK */
    --bg: #000000;
    --card: #000000;
    --card-solid: #000000;
    --text: #ffffff;
    --sub: #a0a0a0;
    --btn: #1a1a1a;
    --hover: #333333;
    --accent: #44a5ff; 
    --accent-glow: rgba(68, 165, 255, 0.4);
    --warn-bg: #1a1600; --warn-text: #ffd700;
    --err-bg: #2a0005; --err-text: #ff6b6b;
    --glass-border: 1px solid #333333;
    --shadow: none; 
--paw-color: #ffca65; 
}

body {
    font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
    background:var(--bg); 
    color:var(--text); 
    max-width:980px; 
    margin:auto; 
    padding:16px; 
    padding-bottom:calc(var(--nav-height) + 40px); 
    position:relative; 
    overflow-x:hidden; 
    transition: background 0.3s;
}

h1 { 
    margin-top: 5px; margin-bottom: 20px; 
    font-size: 1.8em; font-weight: 800; letter-spacing: -0.5px; 
    background: -webkit-linear-gradient(45deg, var(--text), var(--sub)); 
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
    width: fit-content;
}

/* =========================================
   2. UTILITIES & ANIMATIONS
   ========================================= */
.hidden { display: none !important; }
.fade-in { animation: fadeIn 0.3s forwards; }
@keyframes fadeIn { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:translateY(0)} }

/* Glass Panel Utility */
.glass-panel { 
    background: var(--card); backdrop-filter: blur(12px); 
    -webkit-backdrop-filter: blur(12px); border: var(--glass-border); 
    box-shadow: var(--shadow); 
}

/* Ripple Animation */
.ripple {
    position: absolute; border-radius: 50%; transform: scale(0);
    animation: ripple-anim 0.6s linear; background-color: rgba(255, 255, 255, 0.4);
    pointer-events: none;
}
@keyframes ripple-anim { to { transform: scale(4); opacity: 0; } }

/* Floating Particles */
.particle { 
    position: fixed; pointer-events: none; font-weight: bold; z-index: 9999; 
    animation: floatUp 0.8s ease-out forwards; font-size: 20px; 
    text-shadow: 0 2px 4px rgba(0,0,0,0.2); 
}
@keyframes floatUp { 
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 
    100% { transform: translate(-50%, -150px) scale(1.5); opacity: 0; } 
}

/* =========================================
   3. HEADER & NAVIGATION
   ========================================= */
/* Top Controls */
.header-controls { position:absolute; top:16px; right:16px; display:flex; gap:8px; z-index: 100; }

/* Der Info Button (Dezent, nicht "ausgew√§hlt") */
/* === HEADER BUTTONS (Repariert) === */

/* 1. Basis-Styling f√ºr ALLE Header-Buttons (Zahnrad & Info) */
.icon-btn-header {
    width: 40px;
    height: 40px;
    
    /* WICHTIG: Das macht sie rund! */
    border-radius: 50% !important; 
    border: none;
    
    display: flex;
    align-items: center;
    justify-content: center;
    
    font-size: 20px;
    cursor: pointer;
    transition: transform 0.2s;
    
    /* Standard-Look (f√ºr das Zahnrad): Grau */
    background: var(--btn);
    color: var(--text);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 2. Speziell f√ºr den Info-Button (Dezent) */
.icon-btn-header.info {
    /* Kein blauer Hintergrund mehr! Sondern neutral grau wie das Zahnrad */
    background: var(--btn);
    
    /* Nur das "i" leuchtet blau */
    color: var(--accent);
    
    /* Optional: Ein feiner farbiger Rand, damit er sich abhebt */
    border: 1px solid var(--accent-glow);
}

/* Klick-Effekt f√ºr beide */
.icon-btn-header:active {
    transform: scale(0.9);
}


/* List Header (Search & Add) */
.list-header { 
    display:flex; gap: 10px; margin-bottom:15px; position: relative; z-index: 5; 
}
.search-bar { 
    flex:1; width:auto; padding:12px 16px; border-radius:25px; border:none; 
    background:var(--card-solid); color:var(--text); font-size:15px; 
    box-shadow: var(--shadow); transition: box-shadow 0.2s; margin:0; 
}
.search-bar:focus { outline: 2px solid var(--accent); box-shadow: 0 4px 12px var(--accent-glow); }

/* Sticky Bottom Nav */
.bottom-nav {
    position: fixed; bottom: 20px; left: 20px; right: 20px; height: 65px;
    background: rgba(30, 30, 30, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.1); border-radius: 35px;
    display: flex; justify-content: space-evenly; align-items: center;
    z-index: 9000; box-shadow: 0 10px 25px rgba(0,0,0,0.2); max-width: 500px; margin: 0 auto;
}
body:not(.dark) .bottom-nav { background: rgba(255, 255, 255, 0.85); border: 1px solid rgba(255,255,255,0.6); }
body.dark .bottom-nav { background: #000000; border-top: 1px solid #333; border-left: 1px solid #333; border-right: 1px solid #333; border-bottom: none; box-shadow: 0 -5px 20px rgba(255, 255, 255, 0.05); }

.nav-item { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--sub); cursor: pointer; transition: all 0.2s; font-size: 11px; background: none; border: none; padding: 0; position: relative; overflow: hidden; }
.nav-item .nav-icon { font-size: 22px; margin-bottom: 4px; transition: transform 0.2s; }
.nav-item.active { color: var(--accent); font-weight: 600; }
.nav-item.active .nav-icon { transform: translateY(-5px) scale(1.1); filter: drop-shadow(0 4px 5px var(--accent-glow)); }

/* Views Container */
.view-section { display: none; }
.view-section.active { display: block; animation: fadeIn 0.3s ease-out; }

/* =========================================
   4. INPUTS & BUTTONS
   ========================================= */
button { font-size:16px; padding:10px 16px; border-radius:14px; border:none; background:var(--btn); color:var(--text); cursor:pointer; transition: all 0.2s; font-weight: 600; }
button:active { transform: scale(0.96); }
button:hover { background:var(--hover); }

input,select,textarea { padding:12px; font-size:16px; border-radius:12px; border:1px solid var(--btn); background:var(--card-solid); color:var(--text); width: 100%; box-sizing: border-box; font-family: inherit; }
input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); }

/* Main Action Button (Blue Plus) */
.action-btn-main {
    background: var(--accent); color: white; width: 44px; height: 44px; border-radius: 14px;
    display: flex; align-items: center; justify-content: center; font-size: 20px; 
    box-shadow: 0 4px 10px var(--accent-glow); border: 2px solid var(--card-solid);
    transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s;
    cursor: pointer; position: relative; overflow: hidden;
}
.action-btn-main:active { transform: scale(0.90); }
.action-btn-main:hover { transform: scale(1.05); box-shadow: 0 6px 15px var(--accent-glow); }

/* Secondary Button (Edit) */
.action-btn-secondary {
    width: 44px; height: 44px; border-radius: 14px;
    background: var(--card-solid); color: var(--text); border: 1px solid var(--btn);
    display: flex; align-items: center; justify-content: center; font-size: 20px;
    cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); flex-shrink: 0;
}
.action-btn-secondary:active { transform: scale(0.9); }
.action-btn-secondary:hover { transform: scale(1.05); border-color: var(--accent); }

/* Large Sighting Button (New Header) */
.btn-sighting-large {
    flex: 1; display: flex; align-items: center; justify-content: center; gap: 8px;
    background: var(--accent); color: #fff; border: none; border-radius: 25px;
    font-weight: bold; font-size: 15px; box-shadow: var(--shadow); cursor: pointer;
    padding: 12px 16px; transition: transform 0.2s;
}
.btn-sighting-large:active { transform: scale(0.96); }

/* Floating View/Sort Buttons */
.float-btn {
    width: 44px; height: 44px; border-radius: 14px;
    background: var(--card); border: 1px solid var(--btn); color: var(--text);
    box-shadow: var(--shadow); display: flex; align-items: center; justify-content: center;
    font-size: 24px; cursor: pointer; transition: transform 0.2s;
}
.float-btn:active { transform: scale(0.9); }

/* Switch Toggle */
.switch { position: relative; display: inline-block; width: 50px; height: 28px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--btn); transition: .4s; border-radius: 34px; }
.slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
input:checked + .slider { background-color: var(--accent); }
input:checked + .slider:before { transform: translateX(22px); }

/* =========================================
   5. LIST VIEW
   ========================================= */
.row {
    display: flex; align-items: center; gap: 6px; 
    background: var(--card); backdrop-filter: blur(10px);
    padding: 8px 8px; margin-bottom: 12px; border-radius: 20px; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.05); border: 1px solid rgba(255,255,255,0.4);
    transition: transform 0.2s, box-shadow 0.2s; height: auto; min-height: 70px;
}
.row:active { transform: scale(0.99); }
.row.is-active {
    border-color: var(--accent);
    background: linear-gradient(to right, var(--card), rgba(33, 150, 243, 0.05));
    box-shadow: 0 4px 12px var(--accent-glow);
}
body.dark .row.is-active { background: linear-gradient(to right, var(--card), rgba(100, 181, 246, 0.08)); border: 1px solid var(--accent); box-shadow: 0 0 10px rgba(68, 165, 255, 0.2); }
body.dark .row { border: 1px solid #222; background: #000000; }

.click-area-left {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 4px; cursor: pointer; border-radius: 16px; padding: 4px;
    transition: background 0.2s; min-width: 85px; max-width: 100px; text-align: center;
    position: relative; overflow: hidden;
}
.click-area-left:active { background: rgba(0,0,0,0.05); transform: scale(0.98); }
.click-area-left:hover .animal-icon { transform: scale(1.1) rotate(-5deg); border-color: var(--accent); box-shadow: 0 4px 12px var(--accent-glow); }

.animal-icon {
    font-size:26px; width:46px; height:46px; flex-shrink:0; 
    display:flex; align-items:center; justify-content:center; 
    overflow:hidden; border-radius:16px; cursor: pointer; 
    background: linear-gradient(135deg, var(--bg), var(--card-solid));
    border: 1px solid var(--btn); box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.animal-icon img { width:100%; height:100%; object-fit:cover; }

.name { 
    font-weight: 700; font-size: 13px; color: var(--text);
    white-space: normal; line-height: 1.2; word-wrap: break-word; margin-bottom: 2px;
}

/* === OPTION 2: GAMIFIED LEVEL BADGE === */
.count-badge {
    /* Gr√∂√üe & Layout */
    min-width: 38px;
    height: 34px;
    padding: 0 6px;
    
    display: flex; 
    align-items: center; 
    justify-content: center;
    
    /* Der Look: Verlauf + Neigung */
    background: linear-gradient(135deg, var(--accent), #9c27b0);
    color: white;
    
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.25); /* Innerer Glanz */
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    
    /* Die Box neigen (-10 Grad) */
    transform: skewX(-10deg);
    
    margin-left: auto; 
    margin-right: 5px;
    
    /* WICHTIG: Animation vorbereiten */
    transition: transform 0.2s;
}

/* WICHTIG: Die Zahl zur√ºck-neigen, damit sie gerade steht! */
.count-badge span {
    transform: skewX(10deg);
    display: inline-block;
    
    font-family: 'Fredoka', sans-serif; /* Deine Schrift */
    font-weight: 900;
    font-size: 15px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

/* Animation beim Hochz√§hlen (Pop Effekt) */
@keyframes countPop {
    0% { transform: skewX(-10deg) scale(1); }
    50% { transform: skewX(-10deg) scale(1.4); filter: brightness(1.3); box-shadow: 0 0 15px var(--accent); }
    100% { transform: skewX(-10deg) scale(1); }
}

.bump-effect {
    animation: countPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.fav-btn {
    background: none; border: none; font-size: 24px; color: var(--btn); 
    cursor: pointer; padding: 0 4px; margin-right: -4px; transition: transform 0.2s;
}
.fav-btn:active { transform: scale(1.3); }
.fav-btn.active { color: #ffb300; filter: drop-shadow(0 0 2px rgba(255,179,0,0.5)); }

/* Tags & Floating Controls */
.tag-scroll { display: flex; gap: 8px; overflow-x: auto; padding: 4px 4px 15px 4px; margin-bottom: 0px; scrollbar-width: none; mask-image: linear-gradient(to right, black 90%, transparent 100%); }
.tag-scroll::-webkit-scrollbar { display: none; }
.tag-pill { background: var(--btn); padding: 8px 16px; border-radius: 20px; font-size: 13px; white-space: nowrap; cursor: pointer; border: 1px solid transparent; transition: all 0.2s; font-weight: 500; }
.tag-pill.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px var(--accent-glow); transform: scale(1.05); }

.list-controls-floating {
    display: none; justify-content: flex-end; gap: 10px;
    margin-bottom: 10px; padding: 0 5px; animation: fadeIn 0.3s ease-out;
}
.list-controls-floating.visible { display: flex; }

/* List Toggle Btn */
.list-toggle-btn {
    width: 100%; max-width: 300px; margin: 10px auto 20px auto; padding: 10px 20px;
    background: var(--card); border: 1px solid var(--btn); border-radius: 30px;
    color: var(--sub); font-weight: 600; font-size: 14px; text-align: center;
    cursor: pointer; box-shadow: var(--shadow);
    display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;
}
.list-toggle-btn:active { transform: scale(0.96); }
.list-toggle-btn.is-open { background: var(--btn); color: var(--text); border-color: var(--sub); }
.arrow-icon { display: inline-block; transition: transform 0.3s; }
.list-toggle-btn.is-open .arrow-icon { transform: rotate(180deg); }

/* =========================================
   6. GRID VIEW
   ========================================= */
.grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; padding-bottom: 20px; }
.grid-item { background: var(--card); border-radius: 20px; padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center; box-shadow: var(--shadow); position: relative; border: var(--glass-border); }
body.dark .grid-item { border: 1px solid #222; background: #000000; }

.grid-img-wrap { width: 80px; height: 80px; border-radius: 40px; overflow: hidden; margin-bottom: 10px; border: 4px solid var(--bg); box-shadow: 0 4px 8px rgba(0,0,0,0.1); cursor: pointer; display:flex; align-items:center; justify-content:center; font-size:40px; background:var(--btn); }
.grid-img-wrap img { width: 100%; height: 100%; object-fit: cover; }
.grid-name { font-weight: bold; font-size: 14px; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; }
.grid-count { background: transparent; color: var(--accent); padding: 2px 8px; font-size: 16px; font-weight: bold; margin-bottom: 8px; }
.grid-actions { display: flex; gap: 8px; width: 100%; margin-top: 10px; }
.grid-btn { flex: 1; padding: 8px; border-radius: 10px; font-size: 16px; display:flex; align-items:center; justify-content:center; }

.grid-fav {
    position: absolute; top: 5px; right: 5px; font-size: 32px;
    color: var(--sub); cursor: pointer; z-index: 10;
    transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    text-shadow: 0 2px 5px rgba(0,0,0,0.2); 
}
body.dark .grid-fav { color: var(--accent); opacity: 0.8; }
.grid-fav.active { color: #ffb300 !important; opacity: 1; filter: drop-shadow(0 0 8px rgba(255, 179, 0, 0.6)); transform: scale(1.1); }
.grid-fav:active { transform: scale(0.8); }

/* =========================================
   7. MODALS & UI COMPONENTS
   ========================================= */
.modal { display: none; position: fixed; z-index: 9995; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(4px); transition: opacity 0.3s; }
.modal-content {
    background-color: var(--card-solid); margin: 5% auto; padding: 25px; border-radius: 24px; width: 90%; max-width: 500px; position: relative; box-shadow: 0 20px 50px rgba(0,0,0,0.3);
    animation: zoomIn 0.2s ease-out; max-height: 85vh; overflow-y: auto;
}
@media (max-width: 600px) {
    .modal-content { margin: 0; position: absolute; bottom: 0; left: 0; width: 100%; max-width: 100%; border-radius: 24px 24px 0 0; animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1); padding-bottom: 40px; transform: translateZ(0); transition: transform 0.1s; }
}
@keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
@keyframes zoomIn { from { transform: scale(0.9); opacity:0; } to { transform: scale(1); opacity:1; } }

.close-btn { position: absolute; top: 15px; right: 20px; color: var(--sub); font-size: 24px; width:30px; height:30px; display:flex;align-items:center;justify-content:center; background:var(--btn); border-radius:50%; cursor: pointer; z-index:10; }
.sheet-handle { width: 50px; height: 6px; background: var(--btn); border-radius: 10px; margin: 0 auto 20px auto; cursor: grab; }

/* Lightbox */
#lightboxModal { display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); cursor: pointer; align-items: center; justify-content: center; animation: fadeIn 0.2s ease-out; }
#lightboxImg { max-width: 95%; max-height: 90vh; border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5); border: 2px solid #fff; transform: scale(0.9); transition: transform 0.3s; }
#lightboxModal.active #lightboxImg { transform: scale(1); }

/* Select Dropdown */
.modern-select {
    appearance: none; -webkit-appearance: none;
    background-color: var(--btn);
    background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23555%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
    background-repeat: no-repeat; background-position: right 8px top 50%; background-size: 10px auto;
    padding: 6px 24px 6px 12px; border-radius: 20px; border: 1px solid transparent;
    font-size: 12px; font-weight: 600; color: var(--sub); cursor: pointer;
    margin-right: 4px; max-width: 110px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; align-self: center; transition: all 0.2s;
}
.modern-select:focus { outline: none; border-color: var(--accent); background-color: var(--card-solid); box-shadow: 0 0 0 3px var(--accent-glow); }

/* Autocomplete */
.autocomplete-container { flex: 1; position: relative; }
.autocomplete-results { position: absolute; top: 100%; left: 0; right: 0; background: var(--card-solid); border: 1px solid var(--btn); z-index: 1000; display: none; max-height: 200px; overflow-y: auto; border-radius: 0 0 12px 12px; box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
.suggestion-item { padding: 12px; cursor: pointer; border-bottom: 1px solid var(--btn); font-size: 14px; }

/* =========================================
   8. ADMIN & TOOLS
   ========================================= */
.card-section { background:var(--card); padding:20px; border-radius:20px; box-shadow: var(--shadow); margin-bottom: 20px; border: var(--glass-border); }
.card-section h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.1em; border-bottom: 1px solid var(--btn); padding-bottom: 15px; display:flex; align-items:center; gap:10px; }
body.dark .card-section { border: 1px solid #222; background: #000000; }

.import-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
.import-actions button { height: 100%; padding: 15px; border-radius: 16px; }
.btn-merge { grid-column: span 2; background: var(--accent); color: white; }

.edit-tools { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
.file-label { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px; background: var(--btn); padding: 15px; border-radius: 16px; cursor: pointer; font-size: 13px; font-weight: bold; }

/* Accordion */
.accordion-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding-bottom: 0 !important; border-bottom: none !important; margin-bottom: 0 !important; transition: opacity 0.2s; }
.accordion-header:active { opacity: 0.6; }
.acc-chevron { font-size: 14px; opacity: 0.5; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
.card-section.open .acc-chevron { transform: rotate(180deg); }
.accordion-content { display: grid; grid-template-rows: 0fr; transition: grid-template-rows 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease-out, padding 0.3s ease; opacity: 0; overflow: hidden; }
.card-section.open .accordion-content { grid-template-rows: 1fr; opacity: 1; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--btn); }
.accordion-inner { min-height: 0; overflow: hidden; }

/* Backup Alerts */
.backup-alert { background: var(--warn-bg); color: var(--warn-text); padding: 12px 15px; border-radius: 12px; margin-bottom: 15px; font-size: 13px; display: flex; align-items: center; justify-content: space-between; animation: fadeIn 0.3s ease-out; border: 1px solid rgba(0,0,0,0.05); }
.backup-alert button { background: transparent; color: inherit; font-weight: bold; font-size: 16px; padding: 0 5px; width: auto; height: auto; border-radius: 4px; }
.backup-alert button:hover { background: rgba(0,0,0,0.1); }
/* === BACKUP BADGE MIT PFEIL ANIMATION === */

.header-warning-badge {
    background: var(--err-bg);
    color: var(--err-text);
    font-size: 11px;
    font-weight: bold;
    padding: 4px 10px;
    border-radius: 12px;
    
    /* Layout im Header */
    margin-right: 10px;
    margin-left: auto; /* Schiebt es nach rechts an den Titel */
    display: none;     /* Standardm√§√üig versteckt (JS schaltet es an) */
    
    border: 1px solid var(--err-text);
    position: relative; /* Wichtig Anker f√ºr den Pfeil */
    overflow: visible;  /* Damit der Pfeil au√üerhalb sichtbar ist */
}

/* Der rote Pfeil davor */
.header-warning-badge::before {
    content: '‚ûî'; 
    position: absolute;
    
    /* Vertikal zentrieren */
    top: 50%;
    margin-top: -1px; /* Mikrokosmos-Korrektur */
    transform: translateY(-50%);
    
    /* Farbe & Look */
    color: #ff4757; /* Knalliges Rot */
    font-size: 16px;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    
    /* Animation einbinden */
    animation: pointArrow 0.8s ease-in-out infinite alternate;
}

/* Die Bewegung */
@keyframes pointArrow {
    0% {
        left: -20px; /* Nah dran */
    }
    100% {
        left: -26px; /* Weiter weg (Ausholen) */
    }
}
@keyframes pulseBadge { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

/* Trash */
.trash-row { transition: background 0.2s; }
.trash-row:hover { background: var(--btn); }

/* =========================================
   9. STATISTICS & DASHBOARD
   ========================================= */
.level-card { background: linear-gradient(135deg, #2196f3, #673ab7); color: white; padding: 25px; border-radius: 24px; margin-bottom: 20px; text-align: center; box-shadow: 0 10px 25px rgba(33, 150, 243, 0.3); position: relative; overflow: hidden; }
.level-card::before { content:''; position: absolute; top:-50%; left:-50%; width:200%; height:200%; background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 60%); pointer-events: none; }
.level-title { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.9; margin-bottom: 5px; }
.level-num { font-size: 42px; font-weight: 900; margin: 10px 0; text-shadow: 0 2px 10px rgba(0,0,0,0.3); }
.xp-bar-bg { background: rgba(0,0,0,0.25); height: 8px; border-radius: 4px; overflow: hidden; margin-top: 15px; }
.xp-bar-fill { background: #fff; height: 100%; width: 0%; transition: width 1s ease-out; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
.xp-text { font-size: 11px; margin-top: 6px; opacity: 0.9; }

.badge-grid { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
.badge { background: var(--btn); padding: 6px 10px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; gap: 5px; opacity: 0.4; filter: grayscale(1); transition: all 0.3s; cursor: pointer; user-select: none; border: 1px solid transparent; }
.badge:active { transform: scale(0.95); }
.badge.earned { opacity: 1; filter: grayscale(0); background: rgba(33, 150, 243, 0.15); border-color: var(--accent); color: var(--accent); font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
.badge-icon { font-size: 16px; }

.stat-kpi-row { display:flex; gap:10px; justify-content:space-around; margin-bottom:15px; text-align:center; }
.stat-kpi { background:var(--card-solid); padding:10px; border-radius:12px; flex:1; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
.hbar-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 14px; }
.hbar-label { flex: 1; text-align: left; opacity: 0.9; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 0; }
.hbar-track { width: 40%; flex: none; background: var(--btn); height: 12px; border-radius: 6px; overflow: hidden; }
.hbar-fill { height: 100%; background: var(--accent); }
.hbar-val { font-size: 12px; width: 25px; text-align:right; font-weight:bold; flex:none; }

.chart-wrap { display: flex; align-items: flex-end; height: 140px; gap: 6px; padding-top: 25px; margin-top: 10px; }
.chart-col { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; height: 100%; }
.chart-bar { width: 100%; background: var(--accent); border-radius: 4px 4px 0 0; opacity: 0.9; min-height: 1px; background: linear-gradient(to top, var(--accent), #64b5f6); }
.chart-val { font-size: 10px; margin-bottom: 2px; }
.chart-label { font-size: 10px; margin-top: 4px; transform: rotate(-45deg); height: 20px; text-align: center; }


/* === LEVEL LISTE "ROADMAP" STYLE === */

.level-table { 
    width: 100%; border-collapse: separate; border-spacing: 0 4px; 
    font-size: 13px; text-align: left; 
}

.level-table tr {
    transition: transform 0.2s;
}

.level-table td { 
    padding: 8px 10px; 
    border-bottom: 1px solid rgba(0,0,0,0.05); /* Sehr dezent */
    background: var(--card-solid);
}

/* Runde Ecken f√ºr jede Zeile */
.level-table tr td:first-child { border-top-left-radius: 8px; border-bottom-left-radius: 8px; border-left-width: 4px; border-left-style: solid; }
.level-table tr td:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px; text-align: right; font-weight: bold; opacity: 0.7; }

/* === ZONEN FARBEN (Der "Hint") === */

/* Zone 1: Garten (Level 1-4) */
.row-garden td:first-child { border-left-color: #a8e063; }
.row-garden td { background: linear-gradient(90deg, rgba(168, 224, 99, 0.1), transparent); }

/* Zone 2: Wald (Level 5-8) */
.row-forest td:first-child { border-left-color: #134E5E; }
.row-forest td { background: linear-gradient(90deg, rgba(19, 78, 94, 0.1), transparent); }

/* Zone 3: Wasser (Level 9-12) */
.row-water td:first-child { border-left-color: #00c6ff; }
.row-water td { background: linear-gradient(90deg, rgba(0, 198, 255, 0.1), transparent); }

/* Zone 4: Savanne (Level 13-16) */
.row-savanna td:first-child { border-left-color: #f5af19; }
.row-savanna td { background: linear-gradient(90deg, rgba(245, 175, 25, 0.1), transparent); }

/* Zone 5: Legende (Level 17+) */
.row-legend td:first-child { border-left-color: #654ea3; }
.row-legend td { background: linear-gradient(90deg, rgba(101, 78, 163, 0.1), transparent); }

/* === AKTUELLES LEVEL === */
.level-table tr.current-level { 
    transform: scale(1.02); 
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    position: relative; z-index: 2;
}
.level-table tr.current-level td {
    background: var(--card-solid);
    border-bottom: 1px solid var(--accent);
    color: var(--accent);
    font-weight: 900;
}
.level-table tr.current-level td:first-child {
    border-left-color: var(--accent); /* Blaues Highlight f√ºr aktuelles Lvl */
    border-left-width: 6px;
}

.heatmap-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; max-width: 320px; margin: 10px auto; }
.heat-cell { aspect-ratio: 1; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: transparent; background: var(--btn); }

/* Dashboard Hero */
.dashboard-hero {
    background: linear-gradient(135deg, var(--accent), #9c27b0); border-radius: 24px; padding: 20px;
    color: white; box-shadow: 0 10px 20px rgba(33, 150, 243, 0.3); margin-bottom: 20px;
    text-align: center; position: relative; overflow: hidden;
}
.dashboard-hero h2 { margin: 0; font-size: 32px; font-weight: 900; }
.dashboard-hero p { margin: 5px 0 0 0; opacity: 0.9; font-size: 14px; }
.hero-bg-icon { position: absolute; right: -20px; bottom: -20px; font-size: 100px; opacity: 0.2; pointer-events: none; }

/* Favoriten Karussell */
.fav-scroll-title { margin-left: 5px; font-size: 13px; font-weight:bold; color:var(--sub); margin-bottom:10px; text-transform:uppercase; letter-spacing:1px; }
.fav-scroll-container { display: flex; gap: 12px; overflow-x: auto; padding: 5px 5px 20px 5px; margin-bottom: 10px; scrollbar-width: none; }
.fav-scroll-container::-webkit-scrollbar { display: none; }

.fav-card {
    min-width: 95px; background: var(--card); border-radius: 18px; padding: 12px;
    display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px;
    box-shadow: 0 0 15px -4px var(--accent-glow); border: 1px solid rgba(255,255,255,0.1);
    cursor: pointer; transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); position: relative; overflow: hidden;
}
body.dark .fav-card { background: var(--card-solid); box-shadow: 0 0 15px -2px var(--accent-glow); }
.fav-card:active { transform: scale(0.96); box-shadow: 0 0 20px var(--accent); }

.fav-visual { width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; border-radius: 12px; background: var(--bg); margin: 0; overflow: hidden; font-size: 26px; border: 1px solid rgba(0,0,0,0.05); }
.fav-visual img { width: 100%; height: 100%; object-fit: cover; }
.fav-name { font-size: 11px; font-weight: 700; text-align: center; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin: 0; opacity: 0.9; }
.fav-count { background: var(--btn); color: var(--accent); font-size: 10px; font-weight: 800; padding: 3px 8px; border-radius: 10px; margin: 0; }

/* Detail Modal Stats */
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
.stat-card { background: var(--bg); border-radius: 16px; padding: 12px; text-align: center; border: 1px solid var(--btn); box-shadow: 0 2px 5px rgba(0,0,0,0.02); }
.stat-value { font-size: 24px; font-weight: 900; color: var(--accent); margin: 5px 0; }
.stat-label { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.6; }

.time-bar-container { display: flex; height: 24px; border-radius: 12px; overflow: hidden; margin-top: 10px; background: var(--btn); }
.time-segment { height: 100%; transition: width 0.5s ease-out; }
.ts-morgens { background: #FFC107; } .ts-mittags { background: #FF9800; } .ts-abends { background: #F44336; } .ts-nachts { background: #3F51B5; }
.time-legend { display: flex; justify-content: space-between; font-size: 10px; margin-top: 5px; opacity: 0.7; }

/* Map */
#map { height: 60vh; width: 100%; border-radius: 24px; z-index: 1; margin-bottom: 20px; border: 4px solid var(--card); box-shadow: var(--shadow); }

/* =========================================
   10. TOASTS & OTHER
   ========================================= */
.undo-toast {
    position: fixed; bottom: calc(var(--nav-height) + 20px); left: 50%; transform: translateX(-50%) translateY(100px);
    background: #323232; color: white; padding: 12px 20px; border-radius: 30px;
    display: flex; align-items: center; gap: 15px; z-index: 9998;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3); opacity: 0; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: 90%; max-width: 400px; justify-content: space-between;
}
.undo-toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
.undo-btn { background: transparent; color: #64b5f6; font-weight: bold; text-transform: uppercase; font-size: 14px; padding: 5px 10px; margin: -5px -10px -5px 0; cursor: pointer; }
.error-toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: var(--err-bg); color: var(--err-text); padding: 12px 24px; border-radius: 50px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); z-index: 9999; font-size: 14px; display: none; animation: fadeIn 0.3s; font-weight: bold; width: max-content; }

/* Top 3 Stats */
.top3-container { display: flex; flex-direction: column; gap: 8px; }
.top3-row { position: relative; display: flex; align-items: center; gap: 12px; padding: 10px 15px; background: var(--bg); border-radius: 16px; overflow: hidden; border: 1px solid var(--btn); }
.top3-bar { position: absolute; left: 0; top: 0; bottom: 0; background: var(--accent); opacity: 0.15; z-index: 0; transition: width 0.5s ease-out; }
.top3-medal { font-size: 22px; z-index: 1; width: 30px; text-align: center; }
.top3-img { width: 44px; height: 44px; border-radius: 50%; background: var(--card-solid); display: flex; align-items: center; justify-content: center; font-size: 24px; z-index: 1; border: 2px solid var(--card-solid); box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow: hidden; }
.top3-img img { width: 100%; height: 100%; object-fit: cover; }
.top3-info { flex: 1; z-index: 1; display: flex; justify-content: space-between; align-items: center; font-size: 14px; font-weight: bold; }
.top3-count { background: var(--card-solid); padding: 4px 10px; border-radius: 10px; font-size: 13px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }

/* Scroll Top Button */
#scrollTopBtn {
    position: fixed; bottom: 95px; right: 20px; width: 44px; height: 44px;
    background: var(--card-solid); border: 1px solid var(--btn); border-radius: 50%;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer; z-index: 8000; transition: transform 0.2s, opacity 0.2s;
}
#scrollTopBtn:active { transform: scale(0.9); }
body.dark #scrollTopBtn { background: #222; border-color: #333; color: white; }

/* Today Modal List */
.today-list-container { display: flex; flex-direction: column; gap: 15px; padding: 10px 0; }
.today-row { display: flex; gap: 12px; animation: fadeIn 0.3s ease-out; }
.today-time-col { display: flex; flex-direction: column; align-items: center; min-width: 50px; padding-top: 5px; }
.today-time-text { font-size: 12px; font-weight: bold; color: var(--sub); background: var(--bg); padding: 2px 6px; border-radius: 8px; border: 1px solid var(--btn); }
.today-line { width: 2px; flex: 1; background: var(--btn); margin-top: 5px; border-radius: 2px; }
.today-bubble { flex: 1; background: var(--card); border: 1px solid var(--btn); border-radius: 0 16px 16px 16px; padding: 12px; position: relative; box-shadow: 0 2px 8px rgba(0,0,0,0.03); transition: transform 0.2s; }
.today-bubble:active { transform: scale(0.98); }
.today-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.today-animal-name { font-weight: 800; font-size: 15px; color: var(--text); }
.today-details { font-size: 13px; color: var(--sub); line-height: 1.4; }
.today-tag { display: inline-block; background: rgba(33, 150, 243, 0.1); color: var(--accent); padding: 2px 8px; border-radius: 6px; font-size: 11px; font-weight: bold; margin-right: 5px; }

/* Compact View Overrides */
body.compact-view .row { padding: 4px 8px; min-height: 40px; }
body.compact-view .click-area-left { flex-direction: row; min-width: auto; gap: 8px; }
body.compact-view .animal-icon { width: 30px; height: 30px; font-size: 18px; }
body.compact-view .name { font-size: 14px; text-align: left; max-width: 150px; }
body.compact-view .action-btn-main, 
body.compact-view .action-btn-secondary { width: 32px; height: 32px; font-size: 16px; }


/* === BRANDING: TIER TICKER (Green Edition) === */
.app-brand {
    margin-top: 10px; 
    margin-bottom: 20px; 
    display: flex;
    align-items: center; 
    gap: 3px; 
    width: fit-content;
    background: none !important;
}

/* "Tier" - Der fette Teil */
.brand-tier {
    font-family: 'Fredoka', sans-serif;
    font-size: 34px; 
    font-weight: 700; 
    letter-spacing: 0.5px;
    background: -webkit-linear-gradient(45deg, var(--text), var(--sub));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

/* === SUCHEN UND ERSETZEN: L√∂sche den alten .brand-ticker Block komplett! === */

.brand-ticker {
    font-family: 'Fredoka', sans-serif;
    font-size: 34px; 
    font-weight: 700; 
    
    /* Layout */
    display: inline-block;
    transform: rotate(-2deg);
    
    /* 1. Der Verlauf (zum Testen Pink & Blau, damit man es sieht!) */
    background: linear-gradient(90deg, #ff00cc, #3333ff, #ff00cc);
    background-size: 200% auto;
    
    /* 2. Clipping: Hintergrund auf Textform zuschneiden */
    -webkit-background-clip: text;
    background-clip: text;
    
    /* 3. Textfarbe entfernen (WICHTIG!) */
    color: transparent;
    -webkit-text-fill-color: transparent !important;
    
    /* 4. Animation */
    animation: gradientFlow 5s linear infinite;
}

/* Diese Keyframes m√ºssen irgendwo ins CSS (z.B. direkt drunter) */
@keyframes gradientFlow {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
}


/* DAS +1 ICON */
.brand-icon-pop {
    background: #228B22; 
    
    /* HIER DER FIX: Transparenz √ºberschreiben! */
    color: white !important;
    -webkit-text-fill-color: white !important; 
    -webkit-background-clip: border-box !important;
    
    font-size: 12px; 
    font-weight: 900;
    font-family: 'Fredoka', sans-serif;
    
    /* Layout */
    padding: 3px 7px;
    border-radius: 10px;
    display: inline-block; /* Wichtig f√ºr korrekte Darstellung */
    
    /* Positionierung */
    margin-left: 6px;
    margin-bottom: 22px; 
    
    transform: rotate(15deg);
    
    /* Gr√ºner Schatten */
    box-shadow: 0 3px 10px rgba(76, 209, 55, 0.4);
    border: 2px solid var(--bg); 
    
    animation: floatBubble 3s ease-in-out infinite;
}

@keyframes floatBubble {
    0%, 100% { transform: rotate(15deg) translateY(0); }
    50% { transform: rotate(10deg) translateY(-4px) scale(1.05); }
}

/* === BRANDING: SCHNEESPUR (SYNC VERSION) === */

.brand-tier { position: relative; }

/* Basis Pfote */

/* 1. Grundeinstellung (Standard / Light Mode) */

/* === FIX: EMOJI FARBE ERZWINGEN (Schatten-Trick) === */
.paw {
    position: absolute;
    font-size: 20px;
    z-index: 100;
    opacity: 0;
    pointer-events: none;

    /* 1. Das Original-Emoji unsichtbar machen */
    color: transparent !important;
    -webkit-text-fill-color: transparent !important;
    
    /* 2. Einen "Schatten" werfen, der so aussieht wie die Tatze */
    /* Syntax: x-offset y-offset blur color */
    text-shadow: 0 0 0 #ff9f43; /* Dein Orange */
}

/* Dark Mode: Hellerer Schatten */
body.dark .paw {
    text-shadow: 0 0 0 #ffca65; /* Helles Orange */
}

/* Pfote 1: Unten Rechts */
.paw-br {
    bottom: -12px; 
    right: -10px;
    /* Eigener Zeitplan, 8 Sekunden Loop */
    animation: pawCycle1 8s ease-out infinite;
}

/* Pfote 2: Oben Links */
.paw-tl {
    top: -16px;
    left: -4px;
    /* Eigener Zeitplan (Startet verz√∂gert im Keyframe selbst) */
    animation: pawCycle2 8s ease-out infinite;
}

/* ZEITPLAN 1 (Startet sofort) */
@keyframes pawCycle1 {
    0%   { opacity: 0; transform: scale(0.6) rotate(15deg); }
    10%  { opacity: 1; transform: scale(1) rotate(15deg); } /* Erscheint */
    75%  { opacity: 1; } /* Bleibt sichtbar bis kurz vor Ende */
    90%  { opacity: 0; } /* Verschwindet zusammen mit P2 */
    100% { opacity: 0; } /* Kurze Pause */
}

/* ZEITPLAN 2 (Wartet erst) */
@keyframes pawCycle2 {
    0%   { opacity: 0; transform: scale(0.6) rotate(-10deg); }
    30%  { opacity: 0; transform: scale(0.6) rotate(-10deg); } /* Wartet noch... */
    40%  { opacity: 1; transform: scale(1) rotate(-10deg); } /* Erscheint jetzt */
    75%  { opacity: 1; } /* Bleibt sichtbar (Sync mit P1) */
    90%  { opacity: 0; } /* Verschwindet (Sync mit P1) */
    100% { opacity: 0; } /* Kurze Pause */
}

/* === VERWALTUNG KARTEN GLOW (Gleichm√§√üig) === */
.card-section {
    background: var(--card);
    padding: 20px;
    border-radius: 24px;
    margin-bottom: 20px;
    
    /* Der Glow-Effekt: */
    border: 1px solid rgba(255, 255, 255, 0.1);
    
    /* √ÑNDERUNG: 0px Versatz in alle Richtungen, 20px Weichzeichner */
    box-shadow: 0 0 20px 2px var(--accent-glow);
    
    transition: all 0.3s ease;
}

/* Hover-Effekt: Der Glow wird intensiver */
.card-section:hover {
    box-shadow: 0 0 30px 5px var(--accent-glow);
    transform: scale(1.01); /* Minimaler Zoom wirkt edel */
    z-index: 1; /* Damit der Glow √ºber den anderen Karten liegt */
}

/* Utilities */
.hidden { display: none !important; }

/* === FIX: FADE IN ANIMATION === */
.fade-in { 
    /* WICHTIG: Element ist standardm√§√üig unsichtbar! */
    opacity: 0; 
    
    /* 'forwards' sorgt daf√ºr, dass es nach der Animation sichtbar (1) bleibt */
    animation: fadeIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
}

@keyframes fadeIn { 
    from { 
        opacity: 0; 
        transform: translateY(20px); /* Kommt leicht von unten */
    } 
    to { 
        opacity: 1; 
        transform: translateY(0); 
    } 
}

/* === MODAL STACKING === */
/* Ebene 1: Detailansicht */
#detailModal { z-index: 9990 !important; }

/* Ebene 2: Bearbeiten & Notiz (muss dar√ºber liegen) */
#iconModal, #noteModal { z-index: 9995 !important; }

/* Ebene 3: Lightbox & Toasts (ganz oben) */
#lightboxModal { z-index: 10000 !important; }
.undo-toast, .error-toast { z-index: 10001 !important; }

/* Animation f√ºr den Z√§hler */
@keyframes countPop {
    0% { transform: scale(1); }
    50% { transform: scale(1.4); color: #fff; background: var(--accent); }
    100% { transform: scale(1); }
}

.bump-effect {
    animation: countPop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}


input, select, textarea {
    padding: 12px 16px;
    font-size: 16px;
    border-radius: 16px; /* Runder */
    
    /* HIER NEU: Gef√ºllter Hintergrund statt nur Rahmen */
    background: rgba(0, 0, 0, 0.05); /* Leichter Grauschleier */
    border: 2px solid transparent; /* Rahmen vorbereiten */
    color: var(--text);
    width: 100%;
    box-sizing: border-box;
    font-family: inherit;
    font-weight: 600; /* Etwas fetter liest sich besser */
    
    transition: all 0.2s;
}

/* Fokus-Zustand: Hintergrund wird wei√ü, Rahmen farbig */
input:focus, select:focus, textarea:focus {
    outline: none;
    background: var(--card-solid);
    border-color: var(--accent);
    box-shadow: 0 4px 12px var(--accent-glow);
    transform: translateY(-1px);
}

/* Dark Mode Anpassung */
body.dark input, body.dark select, body.dark textarea {
    background: rgba(255, 255, 255, 0.1); /* Hellgrau auf Schwarz */
    color: white;
}
body.dark input:focus {
    background: #000; /* Zur√ºck zu Schwarz bei Fokus */
}
/* === START: NEON GLOW UPGRADE === */

/* 1. Der kleine Plus-Button in der Liste */
body.dark .action-btn-main {
    /* Hellerer Rand */
    border: 1px solid rgba(255,255,255,0.6);
    /* Doppelter Schatten */
    box-shadow: 
        0 0 10px rgba(33, 150, 243, 0.9),  /* Kern */
        0 0 25px rgba(33, 150, 243, 0.4);  /* Aura */
}

/* 2. Der gro√üe Sichtung-Button im Header */
body.dark .btn-sighting-large {
    /* Knalligerer Verlauf */
    background: linear-gradient(135deg, #44a5ff, #0069d9);
    
    /* Doppelter Schatten f√ºr maximalen Effekt */
    box-shadow: 
        0 0 20px rgba(33, 150, 243, 0.8),  /* Starker Kern */
        0 0 60px rgba(33, 150, 243, 0.5);  /* Weite Aura */
        
    /* Wei√üer Rand verst√§rkt den Kontrast */
    border: 1px solid rgba(255, 255, 255, 0.5);
    
    /* Optional: Macht den Text auch leicht leuchtend */
    text-shadow: 0 0 5px rgba(255,255,255,0.5);
}

/* Klick-Effekt: Kurz "abdunkeln" bzw. zusammenziehen */
body.dark .btn-sighting-large:active {
    transform: scale(0.96);
    box-shadow: 0 0 10px rgba(33, 150, 243, 1); /* Aura wird klein & hart */
}
/* === ENDE === */

/* === ONBOARDING / TUTORIAL STYLES (REPARIERT) === */

/* 1. Overlay (Transparent, dient nur als Klickschutz) */
#onboardingOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: transparent; 
    z-index: 9990; 
    display: none;
}

/* 2. Sprechblase (Ganz oben) */
.onboarding-box {
    position: fixed;
    background: var(--card-solid); color: var(--text);
    padding: 20px; border-radius: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    z-index: 10005; /* H√∂her als Highlight */
    max-width: 300px; text-align: center; border: 2px solid var(--accent);
    top: 50%; left: 50%; transform: translate(-50%, -50%);
    animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.onboarding-box h3 { margin-top: 0; color: var(--accent); margin-bottom: 10px; }
.onboarding-box p { font-size: 14px; line-height: 1.5; opacity: 0.9; margin-bottom: 20px; }
.onboarding-btn-row { display: flex; justify-content: space-between; gap: 10px; }

/* 3. Das Highlight Element */
.tour-highlight {
    position: relative;
    z-index: 9999 !important;
    
    /* Der Schatten verdunkelt den Rest */
    box-shadow: 0 0 0 4000px rgba(0, 0, 0, 0.85), 0 0 15px var(--accent) !important;
    
    pointer-events: none;
    transition: box-shadow 0.3s ease-in-out;
    
    /* WICHTIG: KEIN Background setzen, damit der blaue Button blau bleibt! */
}

/* Spezial: Header Controls m√ºssen niedrig sein, damit der Schatten sie √ºberdeckt */
.header-controls {
    z-index: 10 !important; /* Niedriger als 9999 */
}

/* Spezial: Wenn ein runder Button gehighlighted wird */
.icon-btn-header.tour-highlight {
    border-radius: 50% !important;
    background: var(--card-solid) !important; /* Hier brauchen wir Hintergrund */
    z-index: 10000 !important; /* Muss √ºber den anderen liegen */
}

/* Spezial: Bottom Nav braucht Hintergrund (sonst durchsichtig) */
.bottom-nav.tour-highlight {
    position: fixed !important; bottom: 20px !important;
    background: var(--card-solid) !important; border-radius: 35px;
}

@keyframes popIn { from{transform:translate(-50%,-50%) scale(0.5);opacity:0} to{transform:translate(-50%,-50%) scale(1);opacity:1} }
/* === FIX: Stern Farbe angepasst (var(--sub) statt var(--btn)) === */
.fav-btn {
    background: none; 
    border: none; 
    font-size: 24px; 
    
    /* HIER DIE √ÑNDERUNG: */
    color: var(--sub); /* Hellgrau im Dark Mode, Dunkelgrau im Light Mode */
    
    cursor: pointer; 
    padding: 0 4px; 
    margin-right: -4px; 
    transition: transform 0.2s;
}

.fav-btn:active { transform: scale(1.3); }

/* Der gelbe Stern bleibt wie er ist */
.fav-btn.active { 
    color: #ffb300 !important; /* Wichtig, damit es das Grau √ºberschreibt */
    filter: drop-shadow(0 0 2px rgba(255,179,0,0.5)); 
}

/* === ULTIMATE LEVEL CARD UI (4 WELTEN) === */

.level-card {
    border-radius: 24px; padding: 25px 20px;
    color: white; text-align: center; position: relative; overflow: hidden;
    margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.15);
    transition: transform 0.2s;
    /* Standard Schatten */
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}
/* === LEVEL CARD THEMES (5 ZONES) === */

.level-card {
    /* Basis Layout */
    border-radius: 24px; padding: 25px 20px;
    color: white; text-align: center; position: relative; overflow: hidden;
    margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.15);
    transition: transform 0.2s;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

/* ZONE 1: GARTEN (Hellgr√ºn/Gelb) */
.level-card.rank-garden {
    background: linear-gradient(135deg, #56ab2f, #a8e063);
    box-shadow: 0 10px 30px rgba(86, 171, 47, 0.3);
}

/* ZONE 2: WALD (Dunkelgr√ºn/Braun) */
.level-card.rank-forest {
    background: linear-gradient(135deg, #134E5E, #71B280);
    box-shadow: 0 10px 30px rgba(19, 78, 94, 0.4);
}

/* ZONE 3: WASSER (Tiefblau/T√ºrkis) */
.level-card.rank-water {
    background: linear-gradient(135deg, #00c6ff, #0072ff);
    box-shadow: 0 10px 30px rgba(0, 114, 255, 0.4);
}

/* ZONE 4: SAVANNE (Orange/Gold) */
.level-card.rank-savanna {
    background: linear-gradient(135deg, #f12711, #f5af19);
    box-shadow: 0 10px 30px rgba(245, 175, 25, 0.4);
    border: 1px solid rgba(255, 215, 0, 0.3);
}

/* ZONE 5: LEGENDE (Schwarz/Lila/Platin) */
.level-card.rank-legend {
    background: linear-gradient(135deg, #232526, #414345); /* Anthrazit */
    border: 1px solid rgba(255,255,255,0.3);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}
/* Legend√§rer Schimmer */
.level-card.rank-legend::before {
    content:''; position: absolute; top:-50%; left:-50%; width:200%; height:200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
    animation: floating 5s infinite;
}

/* Icons und Text */
.lvl-header {
    display: flex; justify-content: space-between; align-items: center;
    font-size: 11px; text-transform: uppercase; letter-spacing: 2px; opacity: 0.9;
    margin-bottom: 15px; font-weight: bold;
}
.lvl-icon-big {
    font-size: 60px; margin-bottom: 10px;
    filter: drop-shadow(0 5px 15px rgba(0,0,0,0.25));
    animation: floating 3s ease-in-out infinite;
}
.lvl-name {
    font-size: 30px; font-weight: 900; margin: 0; line-height: 1.1;
    text-shadow: 0 2px 10px rgba(0,0,0,0.2); font-family: 'Fredoka', sans-serif;
}

/* Progress Bar */
.lvl-progress-container { margin-top: 25px; position: relative; }
.lvl-bar-bg {
    background: rgba(0,0,0,0.25); height: 14px; border-radius: 20px; overflow: hidden;
    border: 1px solid rgba(255,255,255,0.1);
}
.lvl-bar-fill {
    height: 100%; border-radius: 20px; background: #fff;
    box-shadow: 0 0 20px rgba(255,255,255,0.7);
    position: relative; overflow: hidden; transition: width 1s ease-out;
}
.lvl-bar-fill::after {
    content: ''; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
    transform: translateX(-100%); animation: shimmer 2.5s infinite;
}
.lvl-stats-text {
    display: flex; justify-content: space-between; font-size: 11px; font-weight: bold; margin-top: 8px; opacity: 0.9;
}

@keyframes floating { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-8px)} }
@keyframes shimmer { 100% {transform: translateX(100%)} }


/* === JAHRES-SELECTOR (ZEITKAPSEL) === */

/* === JAHRES-SELECTOR (ZEITKAPSEL - GLOW UPDATE) === */
#statsYearSelect {
    /* 1. Reset */
    -webkit-appearance: none; appearance: none;
    
    /* 2. Look */
    background-color: var(--card-solid);
    color: var(--accent);
    font-size: 16px; font-weight: 900; letter-spacing: 0.5px;
    
    /* 3. Gr√∂√üe */
    padding: 10px 40px 10px 20px; /* Etwas kompakter */
    border: 2px solid var(--accent);
    border-radius: 30px;
    min-width: 120px;
    
    /* 4. DER NEUE GLOW: Gleichm√§√üig (0 0) und weich */
    box-shadow: 0 0 15px var(--accent-glow);
    
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    
    /* 5. Pfeil Icon */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232196f3'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 12px center;
    background-size: 20px;
}

#statsYearSelect:active {
    transform: scale(0.95);
    /* Beim Dr√ºcken wird der Glow etwas st√§rker */
    box-shadow: 0 0 25px var(--accent-glow);
}

/* Dark Mode Pfeil */
body.dark #statsYearSelect {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2344a5ff'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
    background-color: #000;
}

/* === SPLIT VIEW LIST (PROFI LOOK) === */

/* Die Zeile ist nur noch der Container (kein Klick hier drauf!) */
.row {
    display: flex; align-items: stretch; /* Volle H√∂he */
    background: var(--card); backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.4);
    border-radius: 18px;
    margin-bottom: 10px;
    padding: 0; /* Wichtig: Padding weg, das machen die Kinder */
    overflow: hidden; /* F√ºr runde Ecken */
    min-height: 72px; /* Sch√∂ne H√∂he f√ºr Daumen */
    box-shadow: 0 4px 6px rgba(0,0,0,0.02);
    transition: transform 0.2s;
}
body.dark .row { border: 1px solid rgba(255,255,255,0.1); background: rgba(30,30,30,0.6); }

/* ZONE 1: HAUPTBEREICH (Details √∂ffnen) */
.row-main {
    flex: 1; /* Nimmt den meisten Platz */
    display: flex; align-items: center; gap: 12px;
    padding: 8px 0 8px 15px; /* Links Platz, Rechts offen */
    cursor: pointer;
    /* Klick-Feedback nur hier */
}
.row-main:active { background: rgba(0,0,0,0.05); }
body.dark .row-main:active { background: rgba(255,255,255,0.05); }

/* ZONE 2: DEAD ZONE (Sicherheitsabstand) */
.row-deadzone {
    width: 20px; /* Pufferzone */
    border-left: 1px solid rgba(0,0,0,0.03); /* Ganz feine Linie */
    /* Kein Pointer-Event, Klicks gehen ins Leere */
}

/* ZONE 3: MEN√ú (Optionen) */
.row-menu {
    width: 55px;
    display: flex; align-items: center; justify-content: center;
    font-size: 22px; color: var(--sub);
    cursor: pointer;
    border-left: 1px solid transparent;
}
.row-menu:active { background: rgba(0,0,0,0.05); color: var(--accent); }

/* Tacho-Effekt Klasse */
.odometer { font-variant-numeric: tabular-nums; transition: color 0.3s; }
.odometer.rolling { color: var(--accent); transform: scale(1.1); display:inline-block; }

/* === CONTEXT MENU (Das fehlende Popup) === */
.context-menu {
    position: fixed;
    background: var(--card-solid);
    border: 1px solid var(--btn);
    border-radius: 16px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 11000; /* Muss √úBER dem Modal (9990) liegen */
    overflow: hidden;
    min-width: 180px;
    animation: fadeIn 0.1s ease-out;
}
.context-item {
    padding: 14px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 500;
    transition: background 0.1s;
    border-bottom: 1px solid rgba(0,0,0,0.03);
    color: var(--text);
}
.context-item:last-child { border-bottom: none; }
.context-item:active { background: var(--btn); }
.context-item.danger { color: var(--err-text); }
.context-backdrop {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 10999; background: transparent;
}

/* === MODERN LIST TOGGLE PILL === */
.list-toggle-btn {
    width: auto;
    max-width: fit-content;      /* Passt sich dem Text an */
    margin: 15px auto 20px auto; /* Abstand nach oben/unten */
    padding: 10px 25px;          /* Innenabstand */
    
    /* Glasmorphismus Look */
    background: var(--card);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    
    border-radius: 50px;         /* Pillen-Form */
    color: var(--text);
    
    font-weight: 700;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    
    box-shadow: 0 5px 15px rgba(0,0,0,0.08); /* Sanfter Schatten */
    cursor: pointer;
    
    display: flex; align-items: center; justify-content: center; gap: 8px; 
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    z-index: 5;
}

/* Hover & Active Effekte */
.list-toggle-btn:active { transform: scale(0.94); }
.list-toggle-btn.is-open { 
    background: var(--btn); 
    border-color: transparent;
    box-shadow: inset 0 2px 6px rgba(0,0,0,0.05); /* Eingedr√ºckt wirken */
}

/* Pfeil Animation */
.arrow-icon { display: inline-block; transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); font-size: 14px; }
.list-toggle-btn.is-open .arrow-icon { transform: rotate(180deg); }

/* Dark Mode Anpassung */
body.dark .list-toggle-btn { border-color: rgba(255,255,255,0.1); background: rgba(30,30,30,0.6); }

/* === NEUE KPI BUBBLES === */
.kpi-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 2 Spalten */
    gap: 12px;
    margin-bottom: 25px;
}

.kpi-bubble {
    background: var(--card);
    border-radius: 24px;
    padding: 15px;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    box-shadow: var(--shadow);
    border: 1px solid rgba(255,255,255,0.1);
    transition: transform 0.2s;
}

.kpi-bubble:active { transform: scale(0.96); }

/* Farb-Akzente f√ºr die KPIs */
.kpi-blue   { background: linear-gradient(145deg, rgba(33, 150, 243, 0.1), rgba(33, 150, 243, 0.02)); border-color: rgba(33, 150, 243, 0.3); }
.kpi-green  { background: linear-gradient(145deg, rgba(76, 209, 55, 0.1), rgba(76, 209, 55, 0.02)); border-color: rgba(76, 209, 55, 0.3); }
.kpi-orange { background: linear-gradient(145deg, rgba(255, 159, 67, 0.1), rgba(255, 159, 67, 0.02)); border-color: rgba(255, 159, 67, 0.3); }
.kpi-purple { background: linear-gradient(145deg, rgba(156, 39, 176, 0.1), rgba(156, 39, 176, 0.02)); border-color: rgba(156, 39, 176, 0.3); }

.kpi-icon { font-size: 24px; margin-bottom: 5px; opacity: 0.9; }
.kpi-val { font-size: 26px; font-weight: 900; color: var(--text); line-height: 1.1; }
.kpi-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; font-weight: bold; margin-top: 5px; }


/* === NEUE ROADMAP (LEVEL LISTE) === */
.roadmap-container {
    position: relative;
    padding-left: 20px; /* Platz f√ºr die Linie links */
    margin-top: 15px;
}

/* Die Linie im Hintergrund */
.roadmap-line {
    position: absolute;
    left: 10px; /* Mittig im Padding */
    top: 15px;
    bottom: 30px;
    width: 4px;
    background: var(--btn);
    border-radius: 2px;
    z-index: 0;
}

/* Ein einzelnes Level-Item (Bubble) */
.roadmap-item {
    position: relative;
    background: var(--card);
    border-radius: 20px;
    padding: 12px 15px;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    border: 1px solid transparent;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    z-index: 1; /* √úber der Linie */
}

/* Der Punkt auf der Linie */
.roadmap-dot {
    position: absolute;
    left: -24px; /* Auf der Linie positionieren */
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--sub);
    border: 3px solid var(--bg); /* Kleiner Abstand zur Linie */
    transition: all 0.3s;
}

/* Zone Colors f√ºr die Bubbles */
.rm-garden { border-left: 4px solid #a8e063; }
.rm-forest { border-left: 4px solid #134E5E; }
.rm-water  { border-left: 4px solid #00c6ff; }
.rm-savanna{ border-left: 4px solid #f5af19; }
.rm-legend { border-left: 4px solid #654ea3; }

/* Das AKTUELLE Level (Hervorgehoben) */
.roadmap-item.active {
    transform: scale(1.03) translateX(5px);
    background: var(--card-solid);
    box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    border-color: var(--accent);
}
.roadmap-item.active .roadmap-dot {
    background: var(--accent);
    transform: scale(1.5);
    box-shadow: 0 0 10px var(--accent);
}
.roadmap-xp { margin-left: auto; font-weight: bold; font-size: 12px; opacity: 0.6; background: var(--btn); padding: 4px 8px; border-radius: 10px; }

/* === HEATMAP UPGRADE === */
.heatmap-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 300px; /* Passt gut auf Mobile */
    margin: 0 auto;
}

.heatmap-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    width: 100%;
    margin-bottom: 5px;
    gap: 4px;
}

.heatmap-day-label {
    font-size: 10px;
    text-align: center;
    opacity: 0.5;
    font-weight: bold;
}

.heatmap-grid { 
    display: grid; 
    grid-template-columns: repeat(7, 1fr); 
    gap: 4px; 
    width: 100%;
}

.heat-cell { 
    aspect-ratio: 1; 
    border-radius: 6px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-size: 10px; 
    color: transparent; /* Zahl unsichtbar, au√üer bei Hover/Klick */
    background: var(--btn); 
    cursor: pointer;
    transition: transform 0.1s, border 0.1s;
}

.heat-cell:active, .heat-cell.selected {
    transform: scale(1.1);
    border: 1px solid var(--text);
    color: white !important; /* Zahl zeigen bei Klick */
    font-weight: bold;
    z-index: 2;
}

.heat-cell.is-today {
    border: 1px solid var(--accent);
}

.heatmap-info-line {
    margin-top: 10px;
    font-size: 12px;
    height: 16px; /* Reservierter Platz damit nichts springt */
    opacity: 0.8;
    text-align: center;
    font-weight: bold;
    color: var(--accent);
}

/* === FAVORITEN STORY STYLE (LARGE) === */
.fav-card {
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    min-width: 95px; /* Container breiter machen f√ºr den gro√üen Kreis */
}

/* Der Kreis (Bild/Emoji) */
.fav-visual {
    /* GR√ñSSE HIER √ÑNDERN */
    width: 75px;   /* War vorher 60px */
    height: 75px;  /* War vorher 60px */
    font-size: 38px; /* Emoji auch vergr√∂√üern */
    
    border-radius: 50% !important;
    background: var(--card);
    
    /* Rand und Glow etwas verst√§rken */
    border: 3px solid var(--accent); 
    box-shadow: 0 0 20px rgba(33, 150, 243, 0.4);
    
    margin-bottom: 8px;
    position: relative; 
}

/* Der Z√§hler-Badge (Benachrichtigung) */
.fav-count {
    position: absolute;
    /* Positionierung leicht au√üerhalb des Kreises ("Notification Style") */
    top: 3px;
    right: 6px;
    
    background: var(--accent);
    color: white;
    
    /* SCHRIFT & GR√ñSSE */
    font-size: 13px;       /* War 10px -> jetzt deutlich lesbarer */
    font-weight: 900;      /* Extra fett */
    padding: 4px 9px;      /* Mehr "Fleisch" drumherum */
    min-width: 26px;       /* Mindestbreite, damit es sch√∂n rund bleibt */
    text-align: center;
    
    border-radius: 20px;   /* Pillenform */
    border: 3px solid var(--bg); /* Dickerer Rand zur Abgrenzung */
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    margin: 0;
    z-index: 2;
}

/* Name darunter */
.fav-name {
    font-size: 12px; /* Minimal gr√∂√üer f√ºr Balance */
    opacity: 0.9;
    font-weight: 700;
}


/* === TAG SCROLL MIT FADE-EFFEKT === */
.tag-scroll {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding: 4px 10px 15px 4px; /* Etwas Platz rechts */
    margin-bottom: 0px;
    
    /* Scrollbar verstecken */
    scrollbar-width: none; 
    -ms-overflow-style: none;
    
    /* Maske f√ºr weiches Ausblenden rechts */
    -webkit-mask-image: linear-gradient(to right, black 85%, transparent 100%);
    mask-image: linear-gradient(to right, black 85%, transparent 100%);
}
.tag-scroll::-webkit-scrollbar { display: none; }

/* Tag Button etwas aufh√ºbschen */
.tag-pill {
    background: var(--card); /* Transparenter */
    border: 1px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    padding: 8px 18px;
    border-radius: 20px;
    font-size: 13px;
    white-space: nowrap;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
}

.tag-pill.active {
    background: var(--accent);
    color: white;
    border-color: transparent;
    box-shadow: 0 4px 12px var(--accent-glow);
    transform: scale(1.05);
}

/* Farbige Hintergr√ºnde f√ºr Icons */
.animal-icon.color-0 { background: rgba(255, 99, 72, 0.15); border-color: rgba(255, 99, 72, 0.3); color: #ff6348; }
.animal-icon.color-1 { background: rgba(46, 213, 115, 0.15); border-color: rgba(46, 213, 115, 0.3); color: #2ed573; }
.animal-icon.color-2 { background: rgba(30, 144, 255, 0.15); border-color: rgba(30, 144, 255, 0.3); color: #1e90ff; }
.animal-icon.color-3 { background: rgba(255, 165, 2, 0.15);  border-color: rgba(255, 165, 2, 0.3);  color: #ffa502; }
.animal-icon.color-4 { background: rgba(162, 155, 254, 0.15); border-color: rgba(162, 155, 254, 0.3); color: #a29bfe; }
.animal-icon.color-5 { background: rgba(255, 71, 87, 0.15);  border-color: rgba(255, 71, 87, 0.3);  color: #ff4757; }

/* === SNEAK PEEK LIST STYLE === */
.sneak-peek-wrapper {
    position: relative;
    width: 100%;
    transition: all 0.5s ease-out; /* Weiches Aufklappen */
}

.sneak-peek-wrapper.collapsed {
    /* H√∂he f√ºr ca. 1.5 Zeilen (Eine Row ist ca 70-80px) */
    max-height: 140px; 
    overflow: hidden;
    
    /* Der Fade-Out Effekt (Maske) */
    -webkit-mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
    mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
}

/* Unsichtbare Klickfl√§che */
.sneak-peek-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 10;
    cursor: pointer;
    display: none; 
}
.sneak-peek-wrapper.collapsed .sneak-peek-overlay { display: block; }

/* Hinweis Text darunter */
.sneak-peek-hint {
    text-align: center; font-size: 12px; opacity: 0.5; margin-top: 5px; 
    transition: opacity 0.3s; pointer-events: none;
    font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
}
.sneak-peek-wrapper:not(.collapsed) + .sneak-peek-hint { opacity: 0; height: 0; margin: 0; }


/* === STATS DASHBOARD BUTTON (Verschoben) === */
.dashboard-hero-stats {
    background: linear-gradient(135deg, var(--accent), #9c27b0); 
    border-radius: 20px; 
    padding: 15px 20px;
    color: white; 
    box-shadow: 0 5px 15px rgba(33, 150, 243, 0.3); 
    margin-bottom: 25px;
    display: flex; align-items: center; justify-content: space-between;
    cursor: pointer;
    position: relative; overflow: hidden;
    transition: transform 0.2s;
}
.dashboard-hero-stats:active { transform: scale(0.98); }
.dashboard-hero-stats::before { content:'üêæ'; position: absolute; right: -10px; bottom: -15px; font-size: 90px; opacity: 0.15; pointer-events: none; }


/* === ULTIMATE STATS WIDGET === */
.stat-widget-wrapper {
    background: var(--card);
    border-radius: 24px;
    padding: 20px;
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    min-height: 250px; 
    position: relative;
    display: flex; flex-direction: column;
    margin-bottom: 20px;
    transition: height 0.3s;
}

/* Header & Dropdown */
.widget-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1);
    padding-bottom: 10px;
}
.widget-label { font-size: 11px; text-transform: uppercase; font-weight: bold; color: var(--sub); letter-spacing: 1px; }


.stat-selector {
    background: var(--btn);
    color: var(--accent);
    border: 1px solid var(--accent);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 13px; font-weight: bold;
    outline: none; cursor: pointer;
    appearance: none; -webkit-appearance: none;
    text-align: center; width: auto; min-width: 120px;
}

/* Content Animation */
.stat-content { display: none; animation: slideInFade 0.3s ease-out; width: 100%; }
.stat-content.active { display: block; }
@keyframes slideInFade { from { opacity:0; transform:translateY(5px); } to { opacity:1; transform:translateY(0); } }

/* 1. HIGHLIGHTS GRID */
.grid-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.grid-item { background: rgba(255,255,255,0.03); padding: 12px; border-radius: 16px; display: flex; flex-direction: column; gap: 4px; }
.gi-label { font-size: 10px; opacity: 0.6; font-weight: bold; text-transform: uppercase; }
.gi-val { font-size: 15px; font-weight: bold; color: var(--text); }
.gi-icon { font-size: 18px; margin-bottom: 2px; }
.gi-highlight { color: #ff9f43; }

/* 2. TOP ORTE */
.loc-row { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
.loc-rank { width: 20px; height: 20px; background: var(--btn); color: var(--sub); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; }
.loc-rank.gold { background: #ffd700; color: #000; box-shadow: 0 0 8px rgba(255, 215, 0, 0.4); }
.loc-bar-bg { flex: 1; height: 6px; background: var(--btn); border-radius: 3px; overflow: hidden; }
.loc-bar-fill { height: 100%; background: var(--accent); border-radius: 3px; }

/* 3. RANKING LISTE */
.ranking-list { display: flex; flex-direction: column; gap: 8px; position: relative; max-height: 200px; overflow: hidden; }
.rank-row { display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 12px; background: rgba(255,255,255,0.02); opacity: 0.5; transform: scale(0.96); }
.rank-row.me { background: rgba(33, 150, 243, 0.1); border: 1px solid var(--accent); opacity: 1; transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.1); z-index: 1; }
.r-pos { font-weight: 900; width: 30px; text-align: center; }
.r-name { flex: 1; font-weight: bold; font-size: 14px; }
.r-count { font-size: 12px; opacity: 0.8; background: var(--btn); padding: 2px 6px; border-radius: 4px; }

/* 4. MEMORY SWIPE */
.mem-scroll { display: flex; gap: 12px; overflow-x: auto; padding: 5px 5px 20px 5px; scrollbar-width: none; }
.mem-scroll::-webkit-scrollbar { display: none; }
.mem-card { min-width: 130px; max-width: 140px; background: var(--card-solid); border: 1px solid var(--btn); border-radius: 6px; padding: 10px; box-shadow: var(--shadow); flex-shrink: 0; transform: rotate(-1deg); display: flex; flex-direction: column; cursor: pointer; transition: transform 0.2s; }
.mem-card:active { transform: scale(0.98); }
.mem-date { font-size: 9px; color: var(--sub); margin-bottom: 5px; font-weight: bold; }
.mem-txt { font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.3; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 4; -webkit-box-orient: vertical; flex: 1; }

/* 5. TIMELINE */
.timeline { position: relative; padding-left: 15px; margin-top: 5px; }
.timeline::before { content:''; position:absolute; left:4px; top:5px; bottom:5px; width:2px; background:var(--btn); }
.tl-item { position: relative; margin-bottom: 15px; padding-left: 15px; }
.tl-dot { position: absolute; left: -16px; top: 3px; width: 10px; height: 10px; border-radius: 50%; background: var(--card); border: 2px solid var(--dot-col); }
.tl-head { font-size: 13px; font-weight: bold; color: var(--dot-col); }
.tl-sub { font-size: 11px; opacity: 0.6; }

/* 6. DNA */
.dna-track { height: 40px; background: var(--btn); border-radius: 8px; position: relative; overflow: hidden; margin-top:10px; }
.dna-mark { position: absolute; width: 2px; height: 100%; background: #42e695; opacity: 0.8; box-shadow: 0 0 4px #42e695; }
.dna-month { display: flex; justify-content: space-between; font-size: 9px; opacity: 0.4; margin-top: 4px; text-transform: uppercase; }

/* 7. RARITY */
.rarity-track { height: 6px; background: linear-gradient(to right, #a8e063, #2196f3, #9c27b0, #ff4757); border-radius: 3px; margin-top: 25px; position: relative; }
.rarity-cursor { position: absolute; top: -5px; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; transition: left 1s ease-out; }
.rarity-tag { background: var(--card); border: 1px solid var(--accent); color: var(--accent); padding: 2px 8px; border-radius: 8px; font-size: 10px; font-weight: bold; margin-bottom: 4px; white-space: nowrap; }
.rarity-tri { width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 6px solid var(--accent); }

/* === SEPARATER VERLAUF TOGGLE === */
.history-section {
    margin-top: 20px;
    margin-bottom: 20px;
}

/* Der Button/Balken */
.history-toggle-btn {
    width: 100%;
    padding: 16px 20px;
    background: var(--card); /* Gleicher Look wie Widget */
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    
    display: flex; justify-content: space-between; align-items: center;
    
    font-size: 14px; font-weight: 800; color: var(--text);
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    transition: all 0.2s;
}

.history-toggle-btn:active {
    transform: scale(0.98);
    background: var(--btn);
}

.history-arrow {
    transition: transform 0.3s ease;
    opacity: 0.5; font-size: 12px;
}

/* Offener Zustand des Buttons */
.history-toggle-btn.open .history-arrow {
    transform: rotate(180deg);
    color: var(--accent); opacity: 1;
}

/* Der Container f√ºr die Liste (Animation) */
.history-container-wrapper {
    display: grid;
    grid-template-rows: 0fr;
    transition: grid-template-rows 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 0;
}

.history-container-wrapper.open {
    grid-template-rows: 1fr;
    opacity: 1;
    margin-top: 10px;
}

.history-inner {
    overflow: hidden; /* Wichtig f√ºr die Animation */
    min-height: 0;
}

/* Scrollbereich innerhalb des offenen Containers */
.history-scroll-area {
    max-height: 400px;
    overflow-y: auto;
    padding-right: 5px;
    /* Optional: Eigener Hintergrund f√ºr die Liste */
    background: rgba(0,0,0,0.02);
    border-radius: 16px;
    padding: 10px;
    border: 1px solid rgba(255,255,255,0.05);
}

/* === 4. MEMORY LANE (PAPER STYLE) === */
.mem-scroll { 
    display: flex; 
    gap: 15px; /* Etwas mehr Abstand f√ºr die Rotation */
    overflow-x: auto; 
    padding: 10px 10px 25px 10px; /* Platz f√ºr Schatten unten */
    scrollbar-width: none; 
}
.mem-scroll::-webkit-scrollbar { display: none; }

.mem-card {
    min-width: 140px; 
    max-width: 150px;
    flex-shrink: 0;
    
    /* PAPIER LOOK (Helles Creme/Wei√ü) */
    background: #fffbf0 !important; 
    color: #2c2c2e !important; /* Dunkle Schrift f√ºr Kontrast */
    
    /* Kein Rand, daf√ºr Schatten f√ºr Tiefe */
    border: none !important;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3) !important;
    
    /* Form */
    border-radius: 4px; /* Nur leicht abgerundet wie echtes Papier */
    padding: 15px;
    
    display: flex; flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease-out;
    position: relative;
    overflow: hidden;
}

/* Hover/Active Effekt */
.mem-card:active { transform: scale(0.96) rotate(0deg) !important; }

/* Datum wie ein Stempel */
.mem-date {
    font-size: 10px;
    color: #8a8a8a !important;
    font-weight: 800;
    text-transform: uppercase;
    margin-bottom: 8px;
    border-bottom: 1px dashed rgba(0,0,0,0.1);
    padding-bottom: 5px;
}

/* Text wie geschrieben */
.mem-txt {
    font-family: 'Courier New', Courier, monospace; /* Schreibmaschinen-Font */
    font-size: 12px;
    line-height: 1.4;
    font-weight: 600;
    
    overflow: hidden; 
    display: -webkit-box; 
    -webkit-line-clamp: 5; 
    -webkit-box-orient: vertical;
    flex: 1;
}

/* Deko-Element (Nadel/Tape oben) - Optional, sieht aber gut aus */
.mem-card::before {
    content: '';
    position: absolute; top: 0; left: 50%; transform: translateX(-50%);
    width: 30px; height: 8px;
    background: rgba(33, 150, 243, 0.3); /* Blaues "Tape" */
    opacity: 0.5;
}

/* === DNA BARCODE (Verbessert) === */
.dna-wrapper { margin-top: 10px; }
.dna-track { 
    height: 30px; background: rgba(255,255,255,0.05); border-radius: 4px; 
    position: relative; overflow: hidden; display: flex; align-items: center;
}
.dna-mark { 
    position: absolute; width: 3px; height: 100%; 
    background: #42e695; opacity: 0.8; box-shadow: 0 0 8px #42e695; 
}
/* Die Achse unten */
.dna-axis { 
    display: flex; justify-content: space-between; 
    margin-top: 6px; padding: 0 2px;
}
.dna-tick { 
    font-size: 9px; color: var(--sub); font-weight: bold; text-transform: uppercase; 
    width: 20px; text-align: center;
}
.dna-insight {
    text-align: center; font-size: 12px; color: var(--accent); 
    font-weight: bold; margin-top: 12px; background: rgba(33, 150, 243, 0.1);
    padding: 6px; border-radius: 8px;
}

/* === TIMELINE (Story Mode) === */
.timeline-container {
    position: relative; padding-left: 20px; margin-top: 10px;
}
.timeline-line {
    position: absolute; left: 7px; top: 5px; bottom: 5px; width: 2px; 
    background: linear-gradient(to bottom, var(--accent), var(--sub)); opacity: 0.3;
}
.tl-event {
    position: relative; margin-bottom: 20px;
}
.tl-icon-bubble {
    position: absolute; left: -20px; top: 0;
    width: 26px; height: 26px; border-radius: 50%;
    background: var(--card-solid); border: 2px solid var(--accent);
    display: flex; align-items: center; justify-content: center;
    font-size: 12px; z-index: 2;
}
.tl-content {
    background: rgba(255,255,255,0.03); padding: 10px; border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.05);
}
.tl-date { font-size: 10px; opacity: 0.6; font-weight: bold; text-transform: uppercase; margin-bottom: 2px; }
.tl-title { font-size: 13px; font-weight: bold; margin-bottom: 2px; color: var(--text); }
.tl-desc { font-size: 12px; opacity: 0.8; line-height: 1.3; }

/* === RARITY SCALE (Beschriftet) === */
.rarity-wrapper { margin-top: 25px; padding: 0 10px; }
.rarity-scale-line {
    height: 6px; border-radius: 3px; position: relative;
    background: linear-gradient(to right, #4cd137 0%, #00a8ff 50%, #e84118 100%);
}
.rarity-pointer {
    position: absolute; top: -35px; transform: translateX(-50%);
    display: flex; flex-direction: column; align-items: center;
    transition: left 1s ease-out;
}
.rarity-flag {
    background: var(--card-solid); color: var(--text);
    border: 2px solid var(--text); padding: 4px 10px; border-radius: 12px;
    font-size: 11px; font-weight: 900; white-space: nowrap;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3); margin-bottom: 6px;
}
.rarity-triangle {
    width: 0; height: 0; 
    border-left: 6px solid transparent; border-right: 6px solid transparent;
    border-top: 8px solid var(--text);
}
.rarity-labels {
    display: flex; justify-content: space-between; margin-top: 8px;
    font-size: 10px; font-weight: bold; opacity: 0.5; text-transform: uppercase;
}

/* === DROPDOWN: FINAL FIX (NO REPEAT) === */
.stat-selector {
    /* 1. Reset */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    outline: none;

    /* 2. Basis-Design */
    background-color: var(--btn);
    color: var(--accent);
    border: 1px solid var(--accent);
    border-radius: 15px;
    font-size: 13px; 
    font-weight: bold;
    cursor: pointer;
    min-width: 130px;
    text-align: center;
    text-align-last: center;
    padding: 6px 32px 6px 12px;

    /* 3. DAS BILD (Drei Punkte) */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232196f3'%3e%3cpath d='M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z'/%3e%3c/svg%3e");
    
    /* 4. DER FIX (Erzwungen) */
    background-repeat: no-repeat !important;
    background-position: right 8px center !important;
    background-size: 20px !important;
}

/* Dark Mode Bild austauschen */
body.dark .stat-selector {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232196f3'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
    
    /* Sicherheitshalber hier auch nicht wiederholen */
    background-repeat: no-repeat !important;
}

/* Der Container f√ºr den Header */
.detail-header-wrapper {
    position: relative;
    border-radius: 20px 20px 0 0;
    margin: -25px -25px 20px -25px; /* Negativer Margin zieht es an den Rand */
    padding: 30px 25px 20px 25px;
    overflow: hidden;
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

/* Das unscharfe Hintergrundbild */
.detail-bg-blur {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background-size: cover; background-position: center;
    filter: blur(20px) brightness(0.4);
    opacity: 0.6; z-index: 0;
}

/* Der Inhalt (√ºber dem Blur) */
.detail-header-content {
    position: relative; z-index: 1;
    display: flex; align-items: center; gap: 15px;
}

/* Update f√ºr .card-section und .row und .glass-panel */
.card-section, .row, .stat-widget-wrapper, .modal-content {
    /* 1. Hintergrund etwas dunkler f√ºr Kontrast */
    background: rgba(28, 28, 30, 0.6) !important;
    
    /* 2. Der Blur Effekt (Milchglas) */
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    
    /* 3. DER TRICK: Inneres Licht oben + Schatten unten */
    border: 1px solid rgba(255, 255, 255, 0.08) !important; /* Dunklerer Rand */
    box-shadow: 
        0 4px 20px rgba(0,0,0,0.4),       /* Tiefer Schatten */
        inset 0 1px 0 rgba(255,255,255,0.15); /* Lichtkante oben innen! */
        
    border-radius: 22px !important; /* Etwas runder wirkt freundlicher */
}

/* === PREMIUM GLASS GRID ITEM === */
.grid-item {
    /* 1. Hintergrund & Blur (Dark Glass) */
    background: rgba(28, 28, 30, 0.6) !important;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    
    /* 2. Die Premium Kanten (Licht oben, Schatten unten) */
    border: 1px solid rgba(255, 255, 255, 0.08) !important;
    border-radius: 24px !important; /* Sch√∂n rund */
    
    /* Der Trick: Inset Shadow oben simuliert Lichtkante */
    box-shadow: 
        0 10px 25px rgba(0,0,0,0.3),         /* Tiefer Schatten au√üen */
        inset 0 1px 0 rgba(255,255,255,0.15) !important; /* Helle Kante innen */

    /* Layout (Bleibt gleich) */
    padding: 15px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    text-align: center; 
    position: relative; 
    
    /* Animation */
    transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.2s;
}

/* Klick-Effekt: Kachel dr√ºckt sich rein */
.grid-item:active { 
    transform: scale(0.96); 
    /* Schatten wird kleiner beim Dr√ºcken */
    box-shadow: 
        0 2px 8px rgba(0,0,0,0.2), 
        inset 0 1px 0 rgba(255,255,255,0.1) !important; 
}

/* Optional: Bild-Kreis auch etwas aufwerten */
.grid-img-wrap {
    box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Mehr Tiefe f√ºr das Bild */
    border: 2px solid rgba(255,255,255,0.1); /* Dezentere Umrandung */
}



/* Premium Glass look Ende */
/* === SEARCH FUSION (Design Upgrade) === */
.search-fusion-wrapper {
    flex: 1; 
    display: flex; align-items: center;
    background: var(--card-solid);
    border-radius: 20px;
    
    /* NEU: Feiner Rand + Minimaler Glow */
    border: 1px solid rgba(128, 128, 128, 0.25) !important; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.05), 0 0 10px rgba(33, 150, 243, 0.15) !important;
    
    padding-right: 4px; 
    transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
    height: 50px; 
    position: relative; 
    overflow: hidden;
}

/* Fokus-Effekt (St√§rkerer Glow) */
.search-fusion-wrapper:focus-within {
    border-color: var(--accent) !important;
    box-shadow: 0 0 20px var(--accent-glow) !important;
    transform: translateY(-1px);
}

/* Dark Mode Anpassung (Damit es nicht blendet) */
body.dark .search-fusion-wrapper {
    border-color: rgba(255,255,255,0.15) !important;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4), 0 0 10px rgba(68, 165, 255, 0.1) !important;
}

/* === SHIMMER EFFEKT (PREMIUM GLANZ) === */

/* 1. Basis-Update f√ºr die Zeile (Wichtig!) */
.row {
    position: relative; /* Anker f√ºr den Effekt */
    overflow: hidden;   /* Damit der Glanz nicht √ºber den Rand geht */
}

/* 2. Der Lichtstreifen (Pseudo-Element) */
.row::after {
    content: '';
    position: absolute;
    top: 0; 
    left: -100%; /* Startet au√üerhalb links */
    width: 80%;  /* Breite des Lichtstreifens */
    height: 100%;
    
    /* Der Verlauf: Transparent -> Helles Wei√ü (ganz zart) -> Transparent */
    background: linear-gradient(
        to right, 
        transparent 0%, 
        rgba(255, 255, 255, 0.22) 50%, 
        transparent 100%
    );
    
    /* Neigung f√ºr Dynamik */
    transform: skewX(-25deg);
    
    /* WICHTIG: Klicks sollen durchgehen! */
    pointer-events: none; 
    
    /* Die Animation */
    animation: shimmerLoop 30s infinite; 
    z-index: 5; /* √úber dem Hintergrund, unter dem Text */
}

/* 3. Die Bewegung */
@keyframes shimmerLoop {
    0% { left: -100%; }
    20% { left: 200%; } /* Huschtdr√ºber */
    100% { left: 200%; } /* Lange Pause bis zur 30. Sekunde */
}

/* === SHIMMER F√úR GRID KACHELN === */

/* 1. Basis-Update (Wichtig damit der Glanz nicht rausragt) */
.grid-item {
    position: relative !important;
    overflow: hidden !important;
}

/* 2. Der Lichtstreifen (Identisch zu .row::after) */
.grid-item::after {
    content: '';
    position: absolute;
    top: 0; 
    left: -100%; 
    width: 40%; /* Deine Anpassung */
    height: 100%;
    
    /* Dein angepasster Verlauf */
    background: linear-gradient(
        to right, 
        transparent 0%, 
        rgba(255, 255, 255, 0.18) 50%, 
        transparent 100%
    );
    
    transform: skewX(-25deg);
    pointer-events: none; 
    
    /* Nutzt die gleiche Animation */
    animation: shimmerLoop 30s infinite; 
    z-index: 5;
}
/* === IMMERSIVE GRID (Instagram Style) === */
.grid-item {
    padding: 0 !important; /* Kein Padding, Bild geht bis zum Rand */
    height: 160px;         /* Feste H√∂he f√ºr Einheitlichkeit */
    align-items: stretch !important;
    overflow: hidden !important;
    justify-content: flex-end !important; /* Text nach unten */
    border: 1px solid rgba(255,255,255,0.1) !important;
}

/* Das Bild als Hintergrund der ganzen Karte */
.grid-bg-img {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    transition: transform 0.5s;
}
.grid-item:hover .grid-bg-img { transform: scale(1.1); }

/* Verlauf unten, damit Text lesbar ist */
.grid-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 70%;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
    z-index: 1;
    pointer-events: none;
}

/* Text Container */
.grid-info {
    position: relative; z-index: 2;
    padding: 12px;
    text-align: left;
    display: flex; flex-direction: column;
}

.grid-name {
    font-size: 15px !important; font-weight: 800 !important;
    color: #fff !important; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    margin-bottom: 2px !important;
}

.grid-sub {
    font-size: 11px; color: rgba(255,255,255,0.7); font-weight: 600;
}

/* Badge oben rechts */
.grid-badge-top {
    position: absolute; top: 10px; right: 10px;
    background: var(--accent); color: white;
    font-size: 12px; font-weight: 900;
    padding: 4px 8px; border-radius: 12px;
    z-index: 3;
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
}

/* === GRID STYLES UPDATE (MENU UNTEN RECHTS) === */

/* Der Text-Container */
.grid-info {
    position: relative; z-index: 2;
    padding: 12px;
    /* WICHTIG: Platz rechts lassen f√ºr den Men√º-Button, damit Text nicht √ºberlappt */
    padding-right: 45px !important; 
    text-align: left;
    display: flex; flex-direction: column;
}

/* Der Men√º Button (3 Punkte) */
.grid-menu-btn {
    position: absolute; 
    bottom: 0; 
    right: 0;
    
    width: 45px; height: 45px; /* Gro√üe Klickfl√§che */
    display: flex; align-items: center; justify-content: center;
    
    font-size: 24px; 
    color: rgba(255,255,255,0.9); /* Helles Wei√ü */
    text-shadow: 0 2px 5px rgba(0,0,0,0.8); /* Schatten f√ºr Lesbarkeit */
    
    z-index: 10; /* Ganz oben */
    cursor: pointer;
    transition: transform 0.2s;
}

.grid-menu-btn:active {
    transform: scale(1.2);
    color: var(--accent);
}

/* === RICH LIST STYLE === */

/* Container f√ºr Bild/Icon */
.list-visual {
    width: 54px; 
    height: 54px; 
    flex-shrink: 0;
    margin-right: 15px;
    position: relative;
}

/* Das echte Foto */
.list-thumb-img {
    width: 100%; height: 100%;
    object-fit: cover;
    border-radius: 16px; /* Squircle */
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

/* Der Emoji-Placeholder (wenn kein Foto) */
.list-thumb-placeholder {
    width: 100%; height: 100%;
    border-radius: 16px;
    display: flex; align-items: center; justify-content: center;
    font-size: 26px;
    /* Farben werden inline gesetzt, hier nur Fallback */
    background: rgba(255,255,255,0.05);
    box-shadow: inset 0 0 10px rgba(255,255,255,0.05);
}

/* Text Container */
.list-content {
    flex: 1;
    display: flex; flex-direction: column; justify-content: center;
    min-width: 0; /* Wichtig f√ºr Text-Overflow */
}

/* Zeile 1: Name */
.list-top-line {
    display: flex; align-items: center;
    margin-bottom: 3px;
}
.list-name {
    font-size: 16px; 
    font-weight: 800; /* Extra Fett */
    color: var(--text);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.list-fav-star {
    margin-left: 6px; 
    color: #ffb300; 
    font-size: 14px;
    filter: drop-shadow(0 0 5px rgba(255, 179, 0, 0.4));
}

/* Zeile 2: Subtext */
.list-sub-line {
    font-size: 12px; 
    color: var(--sub); 
    font-weight: 500;
    display: flex; align-items: center;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

/* Anpassung der Row-Abst√§nde f√ºr das neue Layout */
.row-main {
    padding: 10px 0 10px 12px !important; /* Etwas Luft lassen */
}
/* === REPARATUR: EIGENE KLASSE F√úR STATS KACHELN === */
.stat-grid-item {
    background: rgba(255, 255, 255, 0.05); /* Leicht heller */
    padding: 15px;
    border-radius: 16px;
    
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* WICHTIG: Linksb√ºndig, nicht zentriert! */
    justify-content: center;
    gap: 4px;
    
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    
    /* Reset von m√∂glichen Grid-St√∂rungen */
    height: auto !important; 
    min-height: 0 !important;
}

/* === PAPER MODAL STYLE (Lese-Ansicht) === */
.paper-modal {
    background: #fffbf0 !important; /* Papier-Farbe */
    color: #2c2c2e !important;      /* Dunkle Schrift */
    border-radius: 6px !important;  /* Eckiger */
    box-shadow: 0 10px 40px rgba(0,0,0,0.5) !important;
    max-width: 400px;
    border: none !important;
}

.paper-close {
    background: rgba(0,0,0,0.1) !important;
    color: #333 !important;
}

.paper-header {
    margin-bottom: 20px;
    border-bottom: 2px dashed rgba(0,0,0,0.1);
    padding-bottom: 15px;
    margin-top: 10px;
}

.paper-date {
    font-size: 18px; font-weight: 900; color: #333;
    font-family: 'Fredoka', sans-serif;
}

.paper-loc {
    font-size: 14px; color: #666; margin-top: 4px; font-weight: bold;
}

.paper-text {
    font-family: 'Courier New', Courier, monospace;
    font-size: 16px; line-height: 1.6;
    white-space: pre-wrap; /* Zeilenumbr√ºche behalten */
    font-weight: 600;
}

.paper-footer {
    margin-top: 30px;
    display: flex; justify-content: flex-end;
}

.paper-action-btn {
    background: transparent;
    border: 2px solid #333;
    color: #333;
    border-radius: 30px;
    padding: 8px 16px;
    font-weight: bold;
    font-size: 13px;
    cursor: pointer;
}
.paper-action-btn:active { background: rgba(0,0,0,0.05); transform: scale(0.95); }

/* === MAP BOTTOM SHEET (Option 2: Navigator) === */
.map-sheet {
    position: fixed;
    left: 15px; right: 15px;
    bottom: 95px; /* √úber der Bottom Nav */
    z-index: 8500;

    /* Navigator Look: Dark Glass & Border */
    background: rgba(30, 30, 30, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 20px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.6);

    /* Layout */
    display: flex; align-items: center; padding: 15px 20px; gap: 15px;
    
    /* Animation: Startet unsichtbar unten */
    transform: translateY(200%);
    transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
}

.map-sheet.active { 
    transform: translateY(0); 
}

.sheet-info { flex: 1; overflow: hidden; }
.sheet-info h4 { margin: 0; font-size: 16px; font-weight: 800; color: #fff; font-family: 'Fredoka', sans-serif; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.sheet-info p { margin: 2px 0 0 0; font-size: 12px; opacity: 0.7; color: #fff; }

/* === Animierte Pfeile (Das Highlight) === */
.arrow-track {
    display: flex; align-items: center; gap: 2px; margin-right: 5px;
}
.chevron {
    width: 8px; height: 8px;
    border-right: 3px solid #4cd137; border-top: 3px solid #4cd137;
    transform: rotate(45deg); opacity: 0;
    animation: guideArrows 1.5s infinite;
}
.chevron:nth-child(1) { animation-delay: 0s; }
.chevron:nth-child(2) { animation-delay: 0.2s; }
.chevron:nth-child(3) { animation-delay: 0.4s; }

@keyframes guideArrows {
    0% { opacity: 0; transform: translateX(-5px) rotate(45deg); }
    50% { opacity: 1; }
    100% { opacity: 0; transform: translateX(5px) rotate(45deg); }
}

/* === Der Gr√ºne Action Button === */
.v2-btn {
    width: 44px; height: 44px; border-radius: 50%;
    background: #4cd137; color: #000; border: none;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; font-weight: bold; cursor: pointer;
    box-shadow: 0 0 15px rgba(76, 209, 55, 0.5);
    transition: transform 0.2s;
    flex-shrink: 0;
}
.v2-btn:active { transform: scale(0.9); }

/* === CSS REPARATUR: MAP SHEET === */
.map-sheet {
    /* ... deine alten Werte lassen (position, bottom etc.) ... */
    
    /* √ÑNDERUNG: Von 150% auf 200% erh√∂hen, damit es sicher weg ist */
    transform: translateY(200%); 
    
    /* Optional: Opacity hinzuf√ºgen, damit es beim Start unsichtbar ist */
    opacity: 0;
    pointer-events: none; /* Klicks gehen durch wenn versteckt */
    
    transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.3s;
}

.map-sheet.active { 
    transform: translateY(0); 
    opacity: 1;
    pointer-events: all;
}


/* === MEMORY DECK (SWIPE STACK) === */
.deck-section {
    position: relative;
    width: 100%;
    height: 380px; /* Platz f√ºr den Stapel */
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    margin-bottom: 30px;
    perspective: 1000px;
    overflow: hidden; /* Damit wegfliegende Karten nicht scrollen */
}

.deck-container {
    position: relative;
    width: 280px; height: 340px;
}

.deck-card {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    border-radius: 20px;
    background: var(--card-solid);
    border: 1px solid var(--btn);
    box-shadow: 0 15px 35px rgba(0,0,0,0.15);
    display: flex; flex-direction: column;
    overflow: hidden;
    cursor: grab;
    transform-origin: 50% 120%; /* Drehpunkt unten f√ºr besseres Feeling */
    user-select: none;
    transition: transform 0.1s linear, opacity 0.3s;
}
/* Im Darkmode etwas mehr Glow */
body.dark .deck-card { box-shadow: 0 15px 40px rgba(0,0,0,0.4); border-color: rgba(255,255,255,0.1); }

.deck-card:active { cursor: grabbing; }

/* Bild-Bereich */
.dc-img-area {
    height: 60%; width: 100%; position: relative; background: var(--btn);
}
.dc-img {
    width: 100%; height: 100%; object-fit: cover; pointer-events: none;
}
.dc-overlay {
    position: absolute; bottom: 0; left: 0; width: 100%; height: 50%;
    background: linear-gradient(to top, var(--card-solid), transparent);
}

.dc-badge {
    position: absolute; top: 5px; right: 15px;
    background: var(--card-solid); 
    padding: 5px 12px; border-radius: 20px;
    font-size: 11px; font-weight: bold; text-transform: uppercase;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    border: 1px solid var(--btn);
    color: var(--sub);
}

/* Container f√ºr Text & Datum */
.dc-body {
    flex: 1; 
    padding: 15px; 
    display: flex; 
    flex-direction: column;
    /* WICHTIG: Damit der innere Scroll/Overflow funktioniert */
    min-height: 0; 
    overflow: hidden;
}

/* Der Titel */
.dc-title {
    font-family: 'Fredoka', sans-serif; 
    font-size: 20px; 
    margin: 0 0 8px 0;
    color: var(--text);
    flex-shrink: 0; /* Titel darf nicht schrumpfen */
}

/* Die Notiz (Variabel) */
.dc-note {
    font-family: 'Caveat', cursive; 
    line-height: 1.2;
    color: var(--text); 
    opacity: 0.85;
    transform: rotate(-1deg);
    
    /* Nimmt den verf√ºgbaren Platz, aber nicht mehr */
    flex-grow: 1; 
    overflow: hidden; 
    
    /* Falls Text zu lang: P√ºnktchen (...) */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    /* Zeilenanzahl wird per JS gesteuert oder CSS fallback */
    -webkit-line-clamp: 6; 
    
    /* Optional: Subtiler Fade-Out unten */
    mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
}

/* Dynamische Schriftgr√∂√üen Klassen (werden per JS gesetzt) */
.note-short  { font-size: 28px; font-weight: bold; justify-content: center; display: flex; align-items: center; text-align: center; }
.note-medium { font-size: 20px; }
.note-long   { font-size: 16px; line-height: 1.3; }

/* Das Datum (Verankert) */
.dc-date {
    margin-top: 10px; /* Abstand nach oben */
    padding-top: 10px;
    border-top: 1px dashed rgba(128, 128, 128, 0.3);
    
    /* WICHTIG: Verhindert, dass das Datum zusammengedr√ºckt wird */
    flex-shrink: 0; 
    
    font-family: ui-monospace, 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
    font-size: 11px; 
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 1px;
    display: flex; 
    justify-content: space-between;
}


/* Animation beim Wegwerfen */
.is-flying { transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important; opacity: 0 !important; }

/* Empty State */
.deck-empty {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; opacity: 0.6; pointer-events: none;
}

/* === STORY RING HEADER (Instagram Style) === */
.story-header {
    display: none; /* Erst unsichtbar, wird per JS aktiviert */
    align-items: center; 
    gap: 15px; 
    padding: 10px 5px 20px 5px; /* Platz nach unten zur Suche */
    animation: fadeIn 0.5s ease-out;
}

.story-ring-wrap {
    position: relative; width: 68px; height: 68px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; flex-shrink: 0;
}

/* Der animierte bunte Rand */
.story-ring-border {
    position: absolute; width: 100%; height: 100%;
    border-radius: 50%;
    background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888, #232526);
    background-size: 200% 200%;
    animation: storySpin 3s linear infinite;
}

/* Das innere Bild/Icon */
.story-inner {
    width: 60px; height: 60px; 
    background: var(--bg); /* Passt sich Dark/Light an */
    border-radius: 50%; z-index: 1;
    display: flex; align-items: center; justify-content: center; 
    font-size: 28px;
    border: 3px solid var(--bg); /* Abstand zum Rand */
    overflow: hidden;
}
.story-inner img { width: 100%; height: 100%; object-fit: cover; }

/* Die Zahl (Badge) */
.story-badge {
    position: absolute; bottom: 0; right: 0;
    background: var(--accent); color: #fff;
    font-size: 11px; font-weight: 900;
    min-width: 22px; height: 22px; 
    border-radius: 12px; padding: 0 4px;
    display: flex; align-items: center; justify-content: center; z-index: 2;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.story-text-col { display: flex; flex-direction: column; justify-content: center; }
.story-title { font-weight: 800; font-size: 14px; margin-bottom: 2px; }
.story-sub { font-size: 12px; opacity: 0.6; }

@keyframes storySpin { 
    0% { background-position: 0% 50%; transform: rotate(0deg); } 
    50% { background-position: 100% 50%; } 
    100% { background-position: 0% 50%; transform: rotate(360deg); } 
}

/* === CINEMATIC VOID MODAL === */
#storyModal {
    /* Der Hintergrund selbst (Ambient Light) */
    background: radial-gradient(circle at 50% 40%, #2c2c2e 0%, #000000 80%) !important;
    padding: 0 !important;
    display: none; /* Wird per JS auf flex gesetzt */
    align-items: center; 
    justify-content: center;
    z-index: 10000; /* Ganz oben */
}

/* Den Standard-Kasten unsichtbar machen */
#storyModal .modal-content {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    width: 100% !important;
    height: 100% !important;
    max-width: none !important;
    margin: 0 !important;
    border-radius: 0 !important;
    
    /* Layout f√ºr den Inhalt */
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center;
    padding: 20px;
}

/* Schwebender Close Button (Glass Style) */
.cinematic-close {
    position: absolute; 
    top: 50px; /* Platz f√ºr Statusbar */
    right: 25px;
    width: 44px; height: 44px;
    border-radius: 50%;
    
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    
    color: #fff;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer;
    z-index: 50;
    transition: transform 0.2s;
}
.cinematic-close:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }

/* Animation beim √ñffnen */
@keyframes voidFadeIn { from{opacity:0; transform:scale(0.95);} to{opacity:1; transform:scale(1);} }
#storyModal.active .deck-container { animation: voidFadeIn 0.5s cubic-bezier(0.19, 1, 0.22, 1); }

/* === FIX F√úR DEN SCHLIESSEN BUTTON === */
.deck-empty {
    /* Damit der Text nicht st√∂rt */
    pointer-events: none; 
}

.deck-empty button {
    /* Damit der Button trotzdem klickbar ist! */
    pointer-events: auto !important; 
    cursor: pointer;
    position: relative; 
    z-index: 50; /* Sicher ist sicher */
}

/* === LAYER FIX: Notizen √ºber dem Deck anzeigen === */

/* Lese-Ansicht */
#noteViewModal {
    z-index: 11000 !important; /* H√∂her als Story (10000) */
    background-color: rgba(0,0,0,0.8) !important; /* Abdunkeln damit man Fokus hat */
}

/* Bearbeiten-Ansicht (falls man von dort editiert) */
#noteModal {
    z-index: 11005 !important; 
}

/* Alert/Toasts m√ºssen GANZ oben sein */
.undo-toast, .error-toast, #lightboxModal {
    z-index: 12000 !important;
}

/* === RADAR PULSE (10s Loop) === */
.pulse-wave {
    position: absolute; 
    top: 0; left: 0; 
    width: 100%; height: 100%;
    border-radius: 50%;
    z-index: 0; /* Hinter dem Ring */
    
    /* Farbe: Ein zartes Pink/Rot passend zum Ring-Verlauf */
    background: rgba(220, 39, 67, 0.4); 
    
    /* Startzustand: Unsichtbar */
    opacity: 0;
    transform: scale(1);

    /* 10 Sekunden Gesamtdauer, unendlich */
    animation: rarePulse 20s infinite ease-out;
}

/* Die zweite Welle startet minimal sp√§ter f√ºr den Echo-Effekt */
.pulse-wave:nth-child(2) {
    animation-delay: 0.4s;
}

/* Die Animation: Nur die ersten 15% (1.5s) passiert etwas */
@keyframes rarePulse {
    0% {
        transform: scale(1);
        opacity: 0.6; /* Start sichtbar */
    }
    15% {
        transform: scale(1.8); /* W√§chst an */
        opacity: 0;   /* Blendet aus */
    }
    100% {
        transform: scale(1.8);
        opacity: 0;   /* Bleibt unsichtbar bis zum Neustart */
    }
}

/* === MINI STORY RING (In Tag Leiste) === */
.tag-story-item {
    position: relative;
    width: 42px; height: 42px; 
    flex-shrink: 0; 
    margin-right: 8px; /* Abstand zum "Alle" Button */
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
}

.tsr-border {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    border-radius: 50%;
    /* Der Instagram-Gradient */
    background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888);
    background-size: 200% 200%;
    animation: storySpin 3s linear infinite;
}

.tsr-inner {
    position: relative; z-index: 1;
    width: 36px; height: 36px;
    background: var(--bg);
    border-radius: 50%;
    border: 2px solid var(--bg); /* Abstand zum bunten Rand */
    display: flex; align-items: center; justify-content: center;
    font-size: 18px; overflow: hidden;
}
.tsr-inner img { width: 100%; height: 100%; object-fit: cover; }

.tsr-badge {
    position: absolute; bottom: -2px; right: -2px; z-index: 2;
    background: var(--accent); color: white;
    font-size: 9px; font-weight: 900;
    min-width: 16px; height: 16px; border-radius: 8px;
    display: flex; align-items: center; justify-content: center;
    border: 2px solid var(--bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

/* Animation √ºbernehmen wir vom alten Code, falls noch nicht da */
@keyframes storySpin { 
    0% { background-position: 0% 50%; transform: rotate(0deg); } 
    50% { background-position: 100% 50%; } 
    100% { background-position: 0% 50%; transform: rotate(360deg); } 
}

/* Container reparieren */
.tag-scroll {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding: 4px 10px 15px 4px;
    scrollbar-width: none;
    mask-image: linear-gradient(to right, black 85%, transparent 100%);
    
    /* DER FIX: Vertikal zentrieren statt strecken */
    align-items: center; 
}

/* Die Buttons reparieren */
.tag-pill {
    /* Style beibehalten */
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(5px);
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s;

    /* DER FIX: Text intern zentrieren & feste H√∂he nutzen */
    display: flex;
    align-items: center;
    justify-content: center;
    height: 36px; /* Feste H√∂he, etwas kleiner als der Ring (42px) */
    padding: 0 16px; /* Seitliches Padding */
}

/* Active State bleibt gleich */
.tag-pill.active {
    background: var(--accent);
    color: white;
    box-shadow: 0 4px 12px var(--accent-glow);
    transform: scale(1.05);
    border-color: transparent;
}

/* Kleiner Stern in der Liste */
.list-fav-indicator {
    display: inline-block;
    color: #ffb300; /* Golden */
    font-size: 14px;
    margin-left: 6px; /* Abstand zum Namen */
    vertical-align: middle;
    filter: drop-shadow(0 0 3px rgba(255, 179, 0, 0.4)); /* Leichter Glow */
    animation: zoomIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Kleiner Pop-Effekt */
}

/* === SEARCH FUSION (Integrierte Steuerung) === */

/* Der neue Container (sieht aus wie die alte Search Bar) */
.search-fusion-wrapper {
    flex: 1; /* Nimmt den Platz neben dem "+ Sichtung" Button ein */
    display: flex; align-items: center;
    background: var(--card-solid);
    border-radius: 25px;
    box-shadow: var(--shadow);
    border: 1px solid transparent; /* Platzhalter f√ºr Fokus */
    padding-right: 6px; /* Platz rechts f√ºr Buttons */
    transition: all 0.2s;
    height: 50px; /* Feste H√∂he f√ºr sauberes Layout */
}

/* Fokus-Effekt auf den ganzen Container √ºbertragen */
.search-fusion-wrapper:focus-within {
    outline: 2px solid var(--accent);
    box-shadow: 0 4px 12px var(--accent-glow);
}

/* Das Eingabefeld (Transparent, ohne eigenen Rand) */
.sf-input {
    flex: 1; /* F√ºllt den linken Bereich */
    width: 100%;
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 10px 0 16px; /* Textabstand */
    font-size: 15px;
    color: var(--text);
    outline: none; /* Fokus macht der Wrapper */
    height: 100%;
}

/* Der Bereich f√ºr die Buttons rechts */
.sf-controls {
    display: flex; 
    gap: 2px;
    padding-left: 8px;
    border-left: 1px solid var(--btn); /* Trennlinie */
    height: 30px; /* Kleiner als Wrapper */
    align-items: center;
}

/* Die Mini-Buttons */
.sf-btn {
    width: 34px; height: 34px;
    border-radius: 50%;
    background: transparent;
    color: var(--sub);
    border: none;
    font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    padding: 0; /* Wichtig f√ºr Zentrierung */
}

.sf-btn:active { 
    background: var(--btn); 
    color: var(--text); 
    transform: scale(0.95);
}
/* === SEARCH FUSION & SEMANTIC CONTROLS === */

/* Container Header Layout optimiert */
.list-header { 
    display: flex; gap: 10px; margin-bottom: 15px; position: relative; z-index: 5; align-items: center; 
}

/* Der neue Wrapper f√ºr die Suche (Nimmt jetzt maximalen Platz) */
.search-fusion-wrapper {
    flex: 1; /* Nimmt den ganzen freien Platz */
    display: flex; align-items: center;
    background: var(--card-solid);
    border-radius: 20px;
    box-shadow: var(--shadow);
    padding-right: 4px; 
    transition: all 0.2s;
    height: 50px;
    position: relative; /* Wichtig f√ºr Overlay */
    overflow: hidden;
}

.search-fusion-wrapper:focus-within {
    outline: 2px solid var(--accent);
    box-shadow: 0 4px 12px var(--accent-glow);
}

/* Das Eingabefeld */
.sf-input {
    flex: 1; width: 100%;
    background: transparent !important;
    border: none !important; box-shadow: none !important;
    padding: 0 10px 0 16px; 
    font-size: 15px; color: var(--text); outline: none; height: 100%;
    transition: opacity 0.2s, transform 0.2s;
}

/* SEMANTIC CONTROLS (Die Text-Buttons) */
.sem-controls {
    display: flex; gap: 4px; padding-left: 6px;
    border-left: 1px solid var(--btn); height: 32px; align-items: center;
}

.sem-btn {
    min-width: 40px; height: 36px; padding: 0 8px;
    border-radius: 12px;
    background: transparent; color: var(--sub);
    border: none;
    font-family: 'JetBrains Mono', monospace, sans-serif; /* Tech Font Look */
    font-size: 13px; font-weight: 800;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all 0.2s; user-select: none;
}

.sem-btn:active { transform: scale(0.92); background: var(--btn); color: var(--text); }
.sem-btn.active { color: var(--accent); background: rgba(33, 150, 243, 0.1); }

/* STATUS FEEDBACK OVERLAY (Der "Sprechende Balken") */
.status-overlay {
    position: absolute; left: 16px; top: 0; bottom: 0;
    display: flex; align-items: center;
    color: var(--accent); font-weight: bold; font-size: 14px;
    opacity: 0; pointer-events: none;
    transform: translateY(15px);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    background: var(--card-solid); /* Deckt Input ab */
    z-index: 10;
    padding-right: 20px;
}
.status-overlay.show { opacity: 1; transform: translateY(0); }

/* Input ausblenden wenn Status da ist (optional, Overlay liegt eh dr√ºber) */
.search-fusion-wrapper.feedback-active .sf-input { 
    opacity: 0; transform: translateY(-10px); 
}

/* NEUER KOMPAKTER SICHTUNGS-BUTTON */
.btn-sighting-compact {
    flex-shrink: 0; /* Darf nicht schrumpfen */
    width: 50px; height: 50px;
    background: var(--accent); color: #fff;
    border: none; border-radius: 18px;
    font-size: 26px; font-weight: 400;
    box-shadow: var(--shadow); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: transform 0.2s;
}
.btn-sighting-compact:active { transform: scale(0.9); box-shadow: 0 0 10px var(--accent-glow); }
/* === VISUAL NOTES STYLES === */

/* Vorschau im Bearbeiten-Modal */
.note-img-preview-container {
    position: relative; 
    width: 100%; 
    height: 140px; 
    border-radius: 16px; 
    overflow: hidden; 
    margin-bottom: 15px; 
    display: none; /* Standardm√§√üig aus */
    border: 1px solid var(--btn);
}

.note-img-preview {
    width: 100%; height: 100%; object-fit: cover;
}

.note-img-remove {
    position: absolute; top: 8px; right: 8px;
    background: rgba(0,0,0,0.6); color: #fff;
    width: 32px; height: 32px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 16px; backdrop-filter: blur(4px);
}

/* Das gro√üe Bild im Lese-Modal (Paper View) */
.paper-hero-img {
    width: 100%; 
    height: 200px; 
    object-fit: cover; 
    border-radius: 6px 6px 0 0; 
    margin: -25px -25px 15px -25px; /* Zieht es an den Rand */
    width: calc(100% + 50px);
    display: none; /* Nur sichtbar wenn Bild da ist */
    cursor: zoom-in;
    border-bottom: 2px dashed rgba(0,0,0,0.1);
}

/* Indikator Icon in der Liste */
.list-cam-icon {
    font-size: 14px; margin-right: 6px; opacity: 0.8;
}

/* === FLOATING ISLAND NAV === */
.nav-island-container {
    position: fixed; bottom: 30px; left: 0; right: 0;
    display: flex; justify-content: center; z-index: 9000;
    pointer-events: none; /* Klicks daneben gehen durch */
}

.nav-island {
    pointer-events: all;
    background: rgba(30, 30, 30, 0.85); 
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 40px;
    padding: 0 25px; 
    height: 65px;
    display: flex; align-items: center; gap: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.4);
}

/* Light Mode Anpassung f√ºr Nav */
body:not(.dark) .nav-island {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(0,0,0,0.1);
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
}

.nav-item {
    flex: none; /* Wichtig: Nicht strecken */
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    color: var(--sub); cursor: pointer; transition: all 0.2s; 
    font-size: 10px; font-weight: 700;
    background: none; border: none; padding: 0; width: 40px;
}

.nav-item .nav-icon { font-size: 24px; margin-bottom: 2px; transition: transform 0.2s; display: block; }
.nav-item.active { color: var(--accent); }
.nav-item.active .nav-icon { transform: translateY(-3px); }

/* DER ZENTRALE POWER BUTTON (+) */
.nav-main-fab {
    width: 60px; height: 60px;
    background: linear-gradient(135deg, var(--accent), #1976d2);
    border-radius: 50%;
    
    /* ZENTRIERUNG */
    display: flex; 
    align-items: center; 
    justify-content: center;
    
    /* OPTIK */
    font-size: 34px; 
    color: #fff; 
    font-weight: 900;    /* Extra Fett */
    line-height: 1;      /* Verhindert Verschiebungen durch Zeilenh√∂he */
    padding-bottom: 4px; /* Schiebt das + optisch genau in die Mitte */
    
    box-shadow: 0 8px 20px var(--accent-glow);
    border: 4px solid var(--bg); 
    transform: translateY(-20px); 
    cursor: pointer; 
    transition: transform 0.2s;
    margin: 0 5px; 
    
    /* Verhindert Auswahl des Textes beim Dr√ºcken */
    user-select: none;
    -webkit-user-select: none;
}

.nav-main-fab:active { 
    transform: translateY(-15px) scale(0.95); 
}

/* === ADMIN TOOLS GRID (Neue Buttons) === */
.admin-tools-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px; }
.tool-card {
    background: var(--card); border: 1px solid var(--btn); padding: 15px; border-radius: 18px;
    display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer;
    transition: transform 0.1s; box-shadow: var(--shadow);
}
.tool-card:active { transform: scale(0.96); background: var(--btn); }
.tc-icon { font-size: 28px; }
.tc-label { font-weight: 700; font-size: 13px; color: var(--text); }


/* === MAP TIME TRAVEL SLIDER (PROFI) === */
.map-slider-container {
    position: absolute; bottom: 95px; left: 20px; right: 20px; z-index: 1000;
    
    /* Glassmorphism Dark */
    background: rgba(20, 20, 20, 0.85); 
    backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
    
    padding: 15px 20px 20px 20px; /* Unten mehr Platz f√ºr den Glow */
    border-radius: 24px; 
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 20px 50px rgba(0,0,0,0.6);
    
    display: flex; flex-direction: column; gap: 8px;
    animation: slideUp 0.3s ease-out;
}

/* Header Text */
.ms-header { 
    display: flex; justify-content: space-between; align-items: center;
    font-size: 11px; font-weight: 900; letter-spacing: 1px;
    color: var(--sub); margin-bottom: 5px;
}

#mapTimeDisplay {
    color: var(--accent); 
    font-size: 15px; 
    text-shadow: 0 0 10px var(--accent-glow);
    display: inline-flex; align-items: center; gap: 8px;
}

/* --- DER SLIDER TRACK (Laufband) --- */
.ms-range {
    -webkit-appearance: none; appearance: none;
    width: 100%; 
    height: 14px; /* Dickerer Track */
    border-radius: 10px;
    outline: none;
    border: 1px solid rgba(255,255,255,0.1);
    
    /* ANIMIERTER HINTERGRUND (Pfeil-Muster) */
    background: repeating-linear-gradient(
        45deg,
        rgba(255,255,255,0.05) 0px,
        rgba(255,255,255,0.05) 10px,
        rgba(0,0,0,0.3) 10px,
        rgba(0,0,0,0.3) 20px
    );
    background-size: 200% 200%;
    animation: trackFlow 10s linear infinite; /* Langsame Bewegung */
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
}

@keyframes trackFlow {
    0% { background-position: 0% 50%; }
    100% { background-position: 100% 50%; }
}

/* --- DER GRIFF (Der Reaktor) --- */
.ms-range::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    
    /* Gr√∂√üe & Form */
    width: 34px; height: 34px; 
    border-radius: 50%;
    cursor: grab;
    
    /* Der Look: Wei√üer Kern mit fettem Glow */
    background: #fff;
    border: 3px solid var(--accent);
    box-shadow: 
        0 0 0 4px rgba(33, 150, 243, 0.3), /* √Ñu√üerer Ring */
        0 0 20px var(--accent);           /* Breiter Glow */

    margin-top: -2px; /* Ausgleich */
    transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s;
    
    /* Die "Atmen" Animation */
    animation: thumbPulse 2s infinite ease-in-out;
}

/* Active State (Beim Ziehen) */
.ms-range:active::-webkit-slider-thumb {
    transform: scale(1.3);
    background: var(--accent);
    border-color: #fff;
    box-shadow: 
        0 0 0 6px rgba(33, 150, 243, 0.5),
        0 0 40px var(--accent);
    cursor: grabbing;
}

@keyframes thumbPulse {
    0% { transform: scale(1); box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.3), 0 0 15px var(--accent); }
    50% { transform: scale(1.1); box-shadow: 0 0 0 6px rgba(33, 150, 243, 0.2), 0 0 25px var(--accent); }
    100% { transform: scale(1); box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.3), 0 0 15px var(--accent); }
}

/* Browser-Support (Firefox) */
.ms-range::-moz-range-thumb {
    width: 34px; height: 34px; border: none; border-radius: 50%;
    background: #fff; border: 3px solid var(--accent);
    box-shadow: 0 0 20px var(--accent);
    cursor: grab; animation: thumbPulse 2s infinite;
}

/* === SOLAR WIDGET (KOMPLETT & REPARIERT) === */

.solar-wrapper {
    /* Grund-Design (hat gefehlt) */
    background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
    border-radius: 24px; 
    padding: 20px; 
    color: #fff; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
    margin-bottom: 20px;
    border: 1px solid rgba(255,255,255,0.1);
    transition: background 1s ease;

    /* Update f√ºr Dropdown */
    overflow: visible !important; 
    position: relative;
    z-index: 5;
}

/* Texte oben */
.solar-info { display: flex; justify-content: space-between; align-items: flex-end; position: relative; z-index: 2; }
.sol-time-big { font-size: 32px; font-weight: 900; line-height: 1; }
.sol-label { font-size: 11px; text-transform: uppercase; opacity: 0.8; font-weight: bold; letter-spacing: 1px; }





/* === SOLAR WIDGET FIX (Kopffreiheit) === */

.solar-animation-box {
    overflow: hidden; 
    position: relative;
    /* √ÑNDERUNG 1: H√∂her machen (140px statt 120px) */
    height: 140px; 
    
    /* √ÑNDERUNG 2: Weniger Margin au√üen, da die Box selbst gr√∂√üer ist */
    margin-top: 10px; 
    
    /* Maske etwas fr√ºher starten lassen */
    -webkit-mask-image: linear-gradient(to bottom, black 70%, transparent 100%);
    mask-image: linear-gradient(to bottom, black 70%, transparent 100%);
    
    display: flex; 
    justify-content: center;
}

.solar-arc-container {
    height: 100%; /* F√ºllt die Box aus */
    width: 100%;
    position: relative; 
    display: flex; 
    justify-content: center;
}

.solar-arc {
    width: 260px; height: 260px; border-radius: 50%;
    border: 2px dashed rgba(255,255,255,0.3);
    position: absolute; 
    /* √ÑNDERUNG 3: Den Kreis nach unten schieben */
    top: 25px; 
}

/* Horizon bleibt, wo er ist, wandert aber durch die Box-H√∂he optisch passend mit */
.solar-horizon {
    position: absolute; bottom: 0; width: 100%; height: 1px;
    background: rgba(255,255,255,0.2);
}



/* Die Sonne / Mond */
.solar-body {
    position: absolute; top: 0; left: 50%; width: 260px; height: 260px;
    transform: translateX(-50%) rotate(0deg); 
    transition: transform 1s ease-out; pointer-events: none;
}
.solar-icon {
    position: absolute; top: -14px; left: 50%; transform: translateX(-50%);
    font-size: 24px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.8));
}

/* Der Standort Button */
.sol-loc-btn {
    text-align: center; 
    font-size: 12px; opacity: 0.8; 
    cursor: pointer; 
    padding: 8px; 
    border-radius: 12px;
    transition: background 0.2s;
    border: 1px solid transparent;
    display: flex; align-items: center; justify-content: center;
}
.sol-loc-btn:active, .sol-loc-btn:hover {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.2);
    opacity: 1;
}

/* Das Suchfeld Overlay */
.sol-search-overlay {
    display: none; 
    position: absolute; 
    top: 0; left: 0; right: 0;
    background: #fff; 
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    padding: 5px;
    z-index: 100;
    animation: fadeIn 0.2s;
}

#solWidgetInput {
    width: 100%; border: none; background: #f0f2f5; 
    color: #333; padding: 10px; border-radius: 8px; font-weight: bold;
    outline: none;
}

/* Suche diesen Block und √§ndere die Farbe: */
#solWidgetResults .suggestion-item {
    color: var(--text); /* Vorher stand hier #333 */
    border-bottom: 1px solid var(--btn);
}

/* Au√üerdem sicherstellen, dass der Hintergrund passt: */
#solWidgetResults {
    background: var(--card-solid); /* Passt sich automatisch an Dark/Light an */
    max-height: 150px; 
    overflow-y: auto; 
    border-radius: 0 0 8px 8px;
}
/* === FACT WIDGET SCROLLING === */

.fact-content-col {
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    overflow: hidden; /* Wichtig f√ºr Layout */
}

.fact-scroll-area {
    /* Maximale H√∂he: ca. 5-6 Zeilen, danach Scrollen */
    max-height: 110px; 
    
    /* Das macht es butterweich auf Touch-Ger√§ten */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; 
    
    padding-right: 5px; /* Platz f√ºr Scrollbar */
    margin-top: 5px;
    
    /* Schicke d√ºnne Scrollbar (Firefox) */
    scrollbar-width: thin;
    scrollbar-color: var(--accent) transparent;
}

/* Schicke Scrollbar (Chrome/Safari/Webkit) */
.fact-scroll-area::-webkit-scrollbar {
    width: 4px;
}
.fact-scroll-area::-webkit-scrollbar-track {
    background: transparent;
}
.fact-scroll-area::-webkit-scrollbar-thumb {
    background-color: var(--btn); /* Dezent grau */
    border-radius: 10px;
}
.fact-scroll-area::-webkit-scrollbar-thumb:hover {
    background-color: var(--accent); /* Farbe bei Interaktion */
}
/* === FACT WIDGET UPDATES === */

/* Klasse f√ºr das obere Widget, damit es unten eckig wird */
.widget-docked-top {
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
    border-bottom: none !important;
    margin-bottom: 0 !important; /* Kein Abstand nach unten */
}

/* Der Footer Button (Angedockt) */
.fact-footer-btn {
    width: 100%;
    background: linear-gradient(to bottom, var(--card), var(--bg)); /* Leichter Verlauf */
    border: 1px solid var(--btn);
    border-top: 1px solid rgba(255,255,255,0.05); /* Feine Trennlinie */
    border-radius: 0 0 20px 20px; /* Nur unten rund */
    padding: 12px;
    
    display: flex; align-items: center; justify-content: center; gap: 8px;
    font-size: 12px; font-weight: 800; color: var(--sub);
    cursor: pointer; transition: all 0.2s;
    margin-bottom: 20px; /* Hier erst der Abstand zum n√§chsten Element */
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}
.fact-footer-btn:active { background: var(--btn); color: var(--text); }

/* Das Herz Icon */

/* Das Herz Icon */
.fact-heart-btn {
    position: absolute; top: 12px; right: 55px;
    font-size: 24px; /* Gr√∂√üer */
    font-weight: 900; /* Extra Fett */
    cursor: pointer; 
    
    /* INAKTIV: Grau und gef√ºllt (sieht massiver aus) */
    color: rgba(255, 255, 255, 0.2); 
    /* Optional: Dicker Rand f√ºr "Outline"-Look, falls gew√ºnscht: */
    /* -webkit-text-stroke: 2px var(--sub); color: transparent; */
    
    transition: transform 0.2s, color 0.2s; 
    z-index: 5;
    user-select: none;
}

.fact-heart-btn.active { 
    color: #ff4757; /* Knallrot */
    opacity: 1; 
    transform: scale(1.1); 
    /* Falls Outline oben genutzt wurde: */
    /* -webkit-text-stroke: 0; */
}

.fact-heart-btn:active { transform: scale(0.8); }

/* === LIBRARY MODAL (Masonry Glass) === */
.masonry-grid-lib { column-count: 2; column-gap: 10px; padding-bottom: 20px; }

.lib-tile {
    break-inside: avoid; margin-bottom: 10px; position: relative;
    background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px; padding: 15px; backdrop-filter: blur(5px);
}
.lib-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
.lib-icon { font-size: 18px; background: rgba(255,255,255,0.05); width: 30px; height: 30px; border-radius: 8px; display:flex; align-items:center; justify-content:center;}
.lib-source { font-size: 9px; color: var(--sub); font-weight: bold; text-transform: uppercase; }
.lib-text { font-size: 13px; line-height: 1.4; font-family: 'Fredoka', sans-serif; opacity: 0.9; }

.lib-unlike {
    position: absolute; top: 10px; right: 10px;
    color: #ff4757; font-size: 16px; cursor: pointer;
}
/* === WIDGET LAYOUT FIX === */
.fact-widget-header {
    display: flex;
    justify-content: space-between; /* Schiebt Titel nach links, Controls nach rechts */
    align-items: center;            /* Vertikal mittig */
    width: 100%;                    /* Volle Breite erzwingen */
    margin-bottom: 15px;
    position: relative;
}

.fact-controls { 
    display: flex; 
    gap: 15px;             /* Abstand zwischen Herz und Men√º */
    align-items: center; 
    flex-shrink: 0;        /* Verhindert Zusammendr√ºcken */
}

/* Der Titel darf nicht alles verdr√§ngen */
.fact-widget-header h3 {
    flex: 1;               /* Nimmt verf√ºgbaren Platz */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-right: 10px;
}

/* === FIX: TABS & WIDGET LAYOUT === */

/* 1. Die Tabs im Library Modal (Nebeneinander erzwingen) */
.tab-nav {
    display: flex !important;       /* Wichtig! */
    flex-direction: row !important; /* Nebeneinander */
    gap: 10px; 
    margin-bottom: 20px;
    background: var(--btn); 
    padding: 5px; 
    border-radius: 16px;
    width: 100%;
}

.tab-btn {
    flex: 1; /* Beide nehmen gleich viel Platz */
    padding: 10px 5px; /* Etwas weniger Padding seitlich f√ºr langen Text */
    border-radius: 12px;
    text-align: center; 
    font-weight: bold; 
    font-size: 12px; /* Schrift etwas kleiner f√ºr den langen Text */
    color: var(--sub); 
    cursor: pointer; 
    transition: all 0.2s;
    white-space: nowrap; /* Kein Umbruch */
    overflow: hidden;
    text-overflow: ellipsis;
}
.tab-btn.active {
    background: var(--card-solid); 
    color: var(--accent);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 2. Der feste Refresh Button im Widget */
.fact-content-col {
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    position: relative; /* Wichtig als Anker */
    height: 120px;      /* Feste H√∂he f√ºr das Layout */
    overflow: hidden;
}

.fact-scroll-area {
    height: 100%;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; 
    
    /* WICHTIG: Platz unten lassen, damit Text nicht hinter dem Button verschwindet */
    padding-bottom: 30px; 
    padding-right: 5px;
}

.fact-refresh-fixed {
    position: absolute;
    bottom: 0;
    right: 0;
    z-index: 10;
    
    /* Kleiner Hintergrund-Verlauf, damit er lesbar bleibt */
    background: linear-gradient(to top, var(--card), rgba(255,255,255,0)); 
    background-color: var(--card); /* Oder solid f√ºr bessere Lesbarkeit */
    padding: 4px 10px;
    border-radius: 12px 0 0 0; /* Nur oben links rund */
    
    font-size: 14px;
    font-weight: bold;
    color: var(--accent);
    cursor: pointer;
    display: flex; 
    align-items: center; 
    gap: 5px;
    box-shadow: -2px -2px 10px rgba(0,0,0,0.05);
}
.fact-refresh-fixed:active { transform: scale(0.95); }

/* === VISUAL POLISH FIXES === */

/* 1. Der "Neu" Button (Jetzt schwebend & rund) */
.fact-refresh-fixed {
    position: absolute;
    bottom: 12px;  /* Abstand vom Boden */
    right: 12px;   /* Abstand von Rechts */
    z-index: 10;
    
    background: var(--card-solid);
    border: 1px solid var(--btn);
    padding: 6px 14px;     /* Etwas gr√∂√üer */
    border-radius: 30px;   /* Komplett rund (Pille) */
    
    font-size: 13px;
    font-weight: 800;
    color: var(--accent);
    cursor: pointer;
    display: flex; 
    align-items: center; 
    gap: 6px;
    
    /* Sch√∂ner Schatten damit er sich vom Text abhebt */
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
    transition: transform 0.2s;
}
.fact-refresh-fixed:active { transform: scale(0.95); }

/* 2. Der Footer Button (Gr√∂√üer & M√§chtiger) */
.fact-footer-btn {
    width: 100%;
    background: linear-gradient(to bottom, var(--card), var(--bg));
    border: 1px solid var(--btn);
    border-top: 1px solid rgba(255,255,255,0.05);
    border-radius: 0 0 24px 24px; /* Passt besser zum Widget Radius */
    
    padding: 18px; /* MEHR H√ñHE (war 12px) */
    
    display: flex; align-items: center; justify-content: center; gap: 8px;
    font-size: 13px; /* Besser lesbar */
    font-weight: 800; color: var(--sub);
    cursor: pointer; transition: all 0.2s;
    margin-bottom: 25px; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
}
.fact-footer-btn:active { background: var(--btn); color: var(--text); transform: scale(0.98); }

/* 3. Der Badge im Footer (Klasse statt Inline-Style) */
.lib-count-badge {
    background: var(--accent); 
    color: #fff; 
    padding: 4px 10px;    /* Gr√∂√üer */
    border-radius: 12px; 
    font-size: 12px;      /* Gr√∂√üer */
    font-weight: 900;
    margin-left: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Kleiner Schatten */
}
/* === FLAVOR SEARCH STYLES === */
.flavor-scroll-area {
    max-height: 250px;       /* Maximale H√∂he */
    overflow-y: auto;        /* Scrollen bei Bedarf */
    padding: 5px;            /* Etwas Platz f√ºr Fokus-Rahmen */
    
    /* Scrollbar Design */
    scrollbar-width: thin;
    scrollbar-color: var(--accent) transparent;
}

/* Design f√ºr die Tag-Buttons im Picker */
.flavor-picker-item {
    background: var(--card); 
    border: 1px solid var(--btn);
    padding: 8px 12px; 
    border-radius: 12px;
    font-size: 13px; font-weight: 600;
    cursor: pointer; 
    display: flex; align-items: center; justify-content: space-between;
    transition: all 0.2s;
    user-select: none;
}

/* Wenn ausgew√§hlt */
.flavor-picker-item.selected {
    background: rgba(33, 150, 243, 0.15); /* Leicht Blau */
    border-color: var(--accent);
    color: var(--accent);
    font-weight: 800;
}
/* === SCROLL LOCK FIX === */

/* Verhindert Scrollen auf dem Body */
body.no-scroll {
    overflow: hidden !important;
    position: fixed; /* Fixiert den Body f√ºr iOS */
    width: 100%;
}

/* Verhindert, dass Scrollen im Modal den Hintergrund bewegt (Modern Browser) */
.modal-content {
    overscroll-behavior: contain; 
}

/* === QUIZ MASTER STYLES === */
.quiz-container {
    text-align: center;
    padding: 10px 0;
}

.quiz-question-box {
    background: var(--bg);
    padding: 20px;
    border-radius: 16px;
    font-size: 16px;
    font-weight: 500;
    line-height: 1.5;
    margin-bottom: 25px;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
    border: 1px solid var(--btn);
}

.quiz-options-grid {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.quiz-btn {
    background: var(--card);
    border: 2px solid var(--btn);
    padding: 15px;
    border-radius: 16px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.1s;
    display: flex; align-items: center; justify-content: center; gap: 10px;
}
.quiz-btn:active { transform: scale(0.96); }

/* Zust√§nde */
.quiz-btn.correct {
    background: #4cd137 !important; color: #fff; border-color: #4cd137;
    animation: pulseBadge 0.3s;
}
.quiz-btn.wrong {
    background: #ff4757 !important; color: #fff; border-color: #ff4757;
    opacity: 0.6;
}

.quiz-score-display {
    font-size: 12px; font-weight: 900; 
    text-transform: uppercase; color: var(--accent);
    margin-bottom: 10px; letter-spacing: 1px;
}
/* === QUIZ MODES STYLES === */
.quiz-mode-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    margin-bottom: 20px;
}

.quiz-mode-card {
    background: var(--card);
    border: 2px solid var(--btn);
    border-radius: 16px;
    padding: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    cursor: pointer;
    transition: transform 0.2s, border-color 0.2s;
}
.quiz-mode-card:active { transform: scale(0.96); }
.quiz-mode-card:hover { border-color: var(--accent); }

.qmc-icon { font-size: 32px; }
.qmc-info { text-align: left; }
.qmc-title { font-weight: 800; font-size: 15px; display: block; margin-bottom: 2px; }
.qmc-desc { font-size: 12px; opacity: 0.7; }

/* L√ºgendetektor Buttons (2 Spalten Layout) */
.quiz-options-grid.lie-mode {
    flex-direction: row; /* Nebeneinander */
}
.quiz-options-grid.lie-mode .quiz-btn {
    flex: 1; /* Gleich breit */
    flex-direction: column;
    padding: 20px 10px;
}

/* === DECK MANAGER STYLES === */
.deck-grid {
    display: flex; flex-direction: column; gap: 10px;
    margin-top: 15px; max-height: 300px; overflow-y: auto;
}

.deck-card {
    background: var(--card); border: 1px solid var(--btn);
    border-radius: 16px; padding: 15px;
    display: flex; align-items: center; justify-content: space-between;
    transition: all 0.2s;
}
.deck-card.disabled { opacity: 0.6; background: var(--bg); }

.deck-info { flex: 1; }
.deck-title { font-weight: 800; font-size: 14px; display: block; margin-bottom: 2px; }
.deck-meta { font-size: 11px; opacity: 0.6; }

.deck-actions { display: flex; align-items: center; gap: 10px; }
.deck-delete {
    color: var(--err-text); font-size: 18px; padding: 5px;
    cursor: pointer; opacity: 0.5;
}
.deck-delete:hover { opacity: 1; }

/* Switch Anpassung f√ºr Decks */
.deck-switch { position: relative; display: inline-block; width: 40px; height: 24px; }
.deck-switch input { opacity: 0; width: 0; height: 0; }
.deck-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
.deck-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
input:checked + .deck-slider { background-color: var(--accent); }
input:checked + .deck-slider:before { transform: translateX(16px); }

/* === FIX: ADMIN GRID (3 SPALTEN) === */
.admin-tools-grid { 
    display: grid; 
    grid-template-columns: 1fr 1fr 1fr; /* Zwingend 3 Spalten */
    gap: 8px; /* Etwas engerer Abstand damit es passt */
    margin-bottom: 20px; 
}

.tool-card {
    background: var(--card); border: 1px solid var(--btn); padding: 10px 5px; /* Weniger Padding */
    border-radius: 16px;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 6px; cursor: pointer;
    box-shadow: var(--shadow);
    min-height: 80px; /* Einheitliche H√∂he */
}
.tc-label { font-size: 11px; text-align: center; line-height: 1.2; } /* Kleinere Schrift */

/* === FIX: DECK CARD LAYOUT (Damit nichts verrutscht) === */
.deck-grid {
    display: flex; flex-direction: column; gap: 10px;
    margin-top: 10px; margin-bottom: 20px;
    max-height: 300px; overflow-y: auto;
    padding: 2px; /* Platz f√ºr Schatten */
}

.deck-card {
    position: relative; /* Wichtig! */
    background: var(--card-solid); /* Solider Hintergrund gegen √úberlappung */
    border: 1px solid var(--btn);
    border-radius: 16px; 
    padding: 15px;
    display: flex; 
    align-items: center; 
    justify-content: space-between; /* Text links, Switch rechts */
    gap: 15px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.deck-info { 
    flex: 1; 
    display: flex; flex-direction: column; 
    overflow: hidden; /* Text abschneiden falls zu lang */
}

/* Der Toggle Switch Container */
.deck-switch { 
    position: relative; 
    display: inline-block; 
    width: 44px; height: 26px; 
    flex-shrink: 0; /* Darf nicht gequetscht werden */
}
/* === ADMIN GRID FIX (Zur√ºck zu 2 Spalten) === */
.admin-tools-grid { 
    display: grid; 
    grid-template-columns: 1fr 1fr; /* Wieder 2 statt 3 */
    gap: 12px; 
    margin-bottom: 20px; 
}
/* === SEARCH RESULT TABS (Konzept 2) === */
.search-tabs-container {
    display: flex; gap: 10px; margin-bottom: 15px;
    animation: fadeIn 0.3s ease-out;
}

.search-tab {
    flex: 1;
    background: var(--card);
    border: 1px solid var(--btn);
    border-radius: 12px;
    padding: 8px 12px;
    font-size: 13px; font-weight: 700;
    color: var(--sub);
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    display: flex; align-items: center; justify-content: center; gap: 6px;
}

.search-tab.active {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    box-shadow: 0 4px 10px var(--accent-glow);
}

.search-tab-count {
    background: rgba(0,0,0,0.15);
    padding: 2px 6px; border-radius: 8px;
    font-size: 11px;
}
.search-tab.active .search-tab-count { background: rgba(255,255,255,0.2); }

/* === LOGBUCH STYLE (Timeline Notes) === */
.log-entry {
    display: flex;
    align-items: stretch; /* Damit die Linie durchgeht */
    margin-bottom: 0;     /* Linie verbindet Elemente */
    position: relative;
    padding-bottom: 15px; /* Abstand zum n√§chsten */
}

/* LINKE SPALTE (Zeitlinie & Icon) */
.log-left {
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    width: 50px; 
    flex-shrink: 0;
    margin-right: 10px;
}

/* Der Knotenpunkt (Bild oder Emoji) */
.log-node {
    width: 42px; height: 42px; 
    border-radius: 50%; 
    background: var(--card);
    border: 2px solid var(--bg);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    
    display: flex; align-items: center; justify-content: center;
    font-size: 20px;
    z-index: 2;
    overflow: hidden;
    position: relative;
}
.log-node img { width: 100%; height: 100%; object-fit: cover; }

/* Die gestrichelte Linie */
.log-line {
    width: 2px; 
    background: repeating-linear-gradient(to bottom, var(--btn) 0, var(--btn) 6px, transparent 6px, transparent 12px);
    flex: 1; 
    margin-top: -2px; /* Dockt an Kreis an */
    min-height: 20px;
    z-index: 1;
}
/* Beim letzten Element Linie ausblenden (optional, hier lassen wir sie f√ºr "Fortsetzung"-Look) */
.log-entry:last-child .log-line { 
    background: linear-gradient(to bottom, var(--btn), transparent); /* Fade out */
}

/* MITTE (Die Papier-Karte) */
.log-card {
    flex: 1;
    background: #fffbf0; /* Papier Creme */
    color: #2c2c2e;
    border-radius: 4px 12px 12px 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    padding: 12px;
    position: relative;
    border: 1px solid rgba(0,0,0,0.05);
    cursor: pointer;
    transition: transform 0.1s;
    min-width: 0; /* Text-Overflow Fix */
}
.log-card:active { transform: scale(0.98); background: #fdf5d3; }

/* Das Dreieck links */
.log-card::before {
    content: ''; position: absolute; left: -8px; top: 14px;
    width: 0; height: 0;
    border-top: 8px solid transparent; 
    border-bottom: 8px solid transparent;
    border-right: 8px solid #fffbf0;
}

/* Dark Mode Papier */
/* Papier bleibt Papier, auch im Dunkeln */
body.dark .log-card { 
    background: #fffbf0 !important; 
    color: #2c2c2e !important; /* Dunkle Schrift auf hellem Papier */
    border: 1px solid #ccc;
}
/* Header-Linie und Text auch im Dark Mode dunkel machen */
body.dark .log-title { color: #2c2c2e !important; }
body.dark .log-text { color: #333 !important; }
body.dark .log-header { border-bottom-color: rgba(0,0,0,0.15) !important; }
body.dark .log-card::before { border-right-color: #2c2c2e; }

/* Inhalt */
.log-header {
    display: flex; justify-content: space-between; align-items: baseline;
    border-bottom: 1px dashed rgba(0,0,0,0.15);
    padding-bottom: 6px; margin-bottom: 6px;
}
body.dark .log-header { border-bottom-color: rgba(255,255,255,0.2); }

.log-title { font-family: 'Fredoka', sans-serif; font-weight: 700; font-size: 14px; }
.log-meta { font-size: 10px; font-weight: bold; opacity: 0.6; text-transform: uppercase; }

.log-text {
    font-family: 'Courier New', Courier, monospace;
    font-size: 13px; line-height: 1.4;
    opacity: 0.9;
    font-weight: 600;
    word-wrap: break-word;
}

.log-loc {
    display: inline-block; margin-top: 6px;
    font-size: 10px; font-weight: bold; color: var(--accent);
    background: rgba(33, 150, 243, 0.1); padding: 2px 6px; border-radius: 4px;
}

/* RECHTS (Deadzone & Menu) */
.log-right {
    display: flex; align-items: flex-start; /* Oben b√ºndig */
    padding-top: 10px; /* B√ºndig mit Karte */
}

.log-deadzone {
    width: 15px; /* Sicherheitsabstand */
    height: 100%;
    cursor: default; /* Zeigt "Hier nicht klicken" */
}

.log-menu-btn {
    width: 40px; height: 40px;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; color: var(--sub);
    cursor: pointer;
    border-radius: 50%;
    transition: background 0.2s;
}
.log-menu-btn:active { background: var(--btn); color: var(--text); }
/* === DEAD ZONE FIX F√úR NOTE MODAL === */

/* Wir nutzen das Pseudo-Element ::after, um die Klickfl√§che zu vergr√∂√üern */
.paper-close::after {
    content: '';
    position: absolute;
    
    /* Erweitere den Klickbereich um 15px in jede Richtung */
    top: -15px; 
    bottom: -15px; 
    left: -15px; 
    right: -15px;
    
    /* Debugging: Mach das hier 'red', um es zu sehen */
    background: transparent; 
    
    border-radius: 50%;
    cursor: pointer;
    z-index: 10; /* Muss √ºber dem Bild liegen */
}

/* Optional: Optisches Feedback, wenn man die Deadzone ber√ºhrt */
.paper-close:hover {
    background: rgba(0,0,0,0.2) !important;
}

/* === LIBRARY SEARCH UI (V3) === */

/* 1. Die Tabs unter der Suche */
.lib-search-tabs {
    display: flex; gap: 10px; margin-bottom: 15px;
    animation: fadeIn 0.3s ease-out;
}

.lib-tab {
    flex: 1;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px;
    padding: 10px;
    font-size: 13px; font-weight: 700;
    color: var(--sub);
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    display: flex; align-items: center; justify-content: center; gap: 6px;
}

.lib-tab.active {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    box-shadow: 0 4px 12px var(--accent-glow);
}

.lib-tab-count {
    background: rgba(0,0,0,0.2);
    padding: 2px 8px; border-radius: 8px;
    font-size: 11px;
}

/* 2. Die Tier-Ergebnis-Zeile (Klickbar) */
.lib-animal-row {
    display: flex; align-items: center; gap: 15px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 12px 15px;
    border-radius: 16px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: transform 0.1s, background 0.1s;
}
.lib-animal-row:active { transform: scale(0.98); background: rgba(255,255,255,0.08); }

.lib-row-icon {
    width: 40px; height: 40px;
    background: var(--card);
    border-radius: 12px;
    display: flex; align-items: center; justify-content: center;
    font-size: 22px;
    border: 1px solid rgba(255,255,255,0.1);
}

.lib-row-arrow {
    margin-left: auto; font-size: 18px; opacity: 0.5; color: var(--accent);
}

/* 3. Der Filter Chip (Drill Down Status) */
.filter-chip-container {
    margin-bottom: 15px; display: none; /* JS schaltet das an */
    animation: fadeIn 0.3s;
}

.filter-chip {
    display: inline-flex; align-items: center; gap: 10px;
    background: var(--accent);
    color: #fff;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold; font-size: 13px;
    cursor: pointer;
    box-shadow: 0 4px 15px var(--accent-glow);
}
/* === OLED FIX: FOOTER BUTTON SICHTBARKEIT === */
body.dark .fact-footer-btn {
    /* 1. Hintergrund: Bleibt tiefschwarz f√ºr OLED */
    background: #000000; 
    
    /* 2. Der Rahmen: Deutlich heller (20% Wei√ü), damit man die Form sieht */
    border: 1px solid rgba(255, 255, 255, 0.2);
    
    /* 3. Die Lichtkante oben: Noch etwas heller (30%), wirkt wie Lichteinfall */
    border-top: 1px solid rgba(255, 255, 255, 0.35);
    
    /* 4. Subtiler Glow: Hebt den Button optisch vom Hintergrund ab */
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);
}

/* Klick-Effekt im Dark Mode: Kurz aufleuchten */
body.dark .fact-footer-btn:active {
    background: #111; /* Ganz leicht grau beim Dr√ºcken */
    border-color: var(--accent); /* Rand wird blau */
}

/* === LEVEL UP OVERLAY === */
#levelUpOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.92); /* Fast schwarz */
    z-index: 15000; /* √úber allem */
    display: none; /* JS schaltet an */
    align-items: center; justify-content: center;
    overflow: hidden;
    animation: fadeIn 0.5s;
}

/* Der Strahlenkranz */
.lvl-sunburst {
    position: absolute;
    width: 200vw; height: 200vw;
    background: repeating-conic-gradient(
        from 0deg, 
        rgba(255, 215, 0, 0.05) 0deg 15deg, 
        transparent 15deg 30deg
    );
    animation: rotateBurst 60s linear infinite;
    z-index: 0;
}

@keyframes rotateBurst { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

/* Inhalt Container */
.lvl-content {
    position: relative; z-index: 1;
    display: flex; flex-direction: column; align-items: center;
    text-align: center;
    width: 80%; max-width: 400px;
}

/* Die kleine Krone oben */
.lvl-crown {
    font-size: 40px; margin-bottom: 10px;
    animation: bounceIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.lvl-up-title {
    font-family: 'Fredoka', sans-serif;
    font-size: 24px; font-weight: 900;
    color: #ffd700; /* Gold */
    letter-spacing: 4px; text-transform: uppercase;
    margin-bottom: 30px;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    animation: slideDown 0.8s ease-out;
}

/* Das gro√üe Rang-Icon */
.lvl-rank-icon {
    width: 140px; height: 140px;
    background: linear-gradient(135deg, #ffd700, #ffa502);
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 70px;
    box-shadow: 0 0 60px rgba(255, 215, 0, 0.4);
    border: 5px solid #fff;
    margin-bottom: 30px;
    animation: zoomPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.lvl-rank-name {
    font-size: 32px; font-weight: 800; color: #fff;
    margin-bottom: 10px;
    text-shadow: 0 4px 10px rgba(0,0,0,0.5);
    animation: fadeIn 1s ease-out 0.5s backwards; /* Verz√∂gert */
}

.lvl-rank-desc {
    font-size: 14px; color: rgba(255,255,255,0.7);
    margin-bottom: 40px; line-height: 1.5;
    animation: fadeIn 1s ease-out 0.8s backwards;
}

.lvl-claim-btn {
    background: transparent;
    color: #ffd700;
    border: 2px solid #ffd700;
    padding: 12px 40px;
    font-size: 16px; font-weight: bold;
    border-radius: 30px;
    cursor: pointer;
    transition: all 0.2s;
    animation: fadeIn 1s ease-out 1s backwards;
}
.lvl-claim-btn:active { background: #ffd700; color: #000; transform: scale(0.95); }

/* Animationen */
@keyframes bounceIn { 0%{transform:scale(0);} 60%{transform:scale(1.2);} 100%{transform:scale(1);} }
@keyframes slideDown { from{transform:translateY(-50px);opacity:0;} to{transform:translateY(0);opacity:1;} }
@keyframes zoomPop { 0%{transform:scale(0) rotate(-45deg);} 80%{transform:scale(1.1) rotate(5deg);} 100%{transform:scale(1) rotate(0);} }

/* === FIX: CLOSE BUTTON NOTE VIEW (Frosted Glass) === */
.paper-close {
    /* 1. Positionierung & Gr√∂√üe */
    position: absolute;
    top: 15px;
    right: 15px;
    width: 36px;
    height: 36px;
    
    /* 2. Der Look: Dunkles Milchglas */
    background: rgba(0, 0, 0, 0.5) !important; /* Halbtransparenter schwarzer Kreis */
    backdrop-filter: blur(5px);                /* Weichzeichner dahinter */
    -webkit-backdrop-filter: blur(5px);
    
    /* 3. Rand & Schatten f√ºr Tiefe */
    border: 1px solid rgba(255, 255, 255, 0.3) !important; /* Feiner wei√üer Ring */
    border-radius: 50% !important;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3) !important;
    
    /* 4. Das "X" Icon */
    color: #ffffff !important; /* Immer Wei√ü (bester Kontrast auf Schwarz) */
    font-weight: bold;
    font-size: 16px;
    
    /* 5. Flexbox f√ºr Zentrierung */
    display: flex !important;
    align-items: center;
    justify-content: center;
    
    z-index: 50; /* √úber dem Bild */
    transition: transform 0.2s, background 0.2s;
    cursor: pointer;
}

/* Klick-Effekt */
.paper-close:active {
    transform: scale(0.9);
    background: rgba(0, 0, 0, 0.7) !important;
}

/* Optional: Klickfl√§che vergr√∂√üern (unsichtbar), damit man leichter trifft */
.paper-close::after {
    content: '';
    position: absolute;
    top: -10px; bottom: -10px; left: -10px; right: -10px;
    background: transparent;
    border-radius: 50%;
}
/* === MEMORY DECK: PAPER STYLE FIX === */

/* Die Karte selbst (Papier-Look) */
.deck-card {
    /* Papier Farbe & Text */
    background-color: #fffbf0 !important;
    color: #2c2c2e !important;
    
    /* Kein Tech-Border, sondern feiner Papier-Rand */
    border: 1px solid rgba(0,0,0,0.1) !important;
    border-radius: 4px !important; /* Weniger rund, mehr wie Notizzettel */
    
    /* Tiefer Schatten f√ºr 3D-Effekt */
    box-shadow: 0 5px 25px rgba(0,0,0,0.2) !important;
    
    /* Wichtig f√ºr den Stapel */
    position: absolute !important;
    top: 0; left: 0;
    width: 100%; height: 100%;
    
    display: flex; flex-direction: column;
    overflow: hidden;
    transform-origin: 50% 120%; /* Drehpunkt unten */
    user-select: none;
    
    /* Weiche Bewegung beim Nachr√ºcken */
    transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.3s;
}

/* Dunkelmodus ignorieren (Papier bleibt Papier) */
body.dark .deck-card {
    background-color: #fffbf0 !important;
    border-color: #ccc !important;
    color: #2c2c2e !important;
}

/* Bildbereich: Polaroid Style */
.dc-img-area {
    background: #000; /* Schwarz hinterm Bild */
    height: 55%; 
    border-bottom: 2px dashed rgba(0,0,0,0.1); /* Abrisskante */
    position: relative;
}

/* Badge oben rechts */
.dc-badge {
    background: rgba(255,255,255,0.9) !important;
    color: #333 !important;
    border: 1px solid #999 !important;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    font-family: 'Fredoka', sans-serif;
}

/* Der Titel (Name) */
.dc-title {
    font-family: 'Fredoka', sans-serif;
    color: #2c2c2e !important;
    font-weight: 800;
    margin-top: 5px;
    padding-bottom: 5px;
    border-bottom: 2px solid var(--accent); /* Farbiger Unterstrich */
    display: inline-block;
    width: fit-content;
}

/* Der Notiz-Text (Schreibmaschine) */
.dc-note {
    font-family: 'Courier New', Courier, monospace !important;
    color: #333 !important;
    font-weight: 600;
    line-height: 1.4;
    font-style: normal; /* Kein Italic per default */
    opacity: 1 !important;
    margin-top: 5px;
}

/* Das Datum unten */
.dc-date {
    border-top: 1px dashed rgba(0,0,0,0.15) !important;
    color: #888 !important;
    font-weight: bold;
    padding-top: 8px;
    margin-top: auto; /* Ganz nach unten schieben */
}
   /* === FIX: STORY RING KLICKBARKEIT === */
.tag-story-item {
    cursor: pointer !important;
    pointer-events: auto !important; /* Zwingend klickbar */
    z-index: 100 !important;         /* √úber alles andere */
    position: relative;
    
    /* Fix f√ºr Mobile Tap */
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

/* Sicherstellen, dass der Scroll-Container Klicks erlaubt */
.tag-scroll {
    pointer-events: auto !important;
    z-index: 5;
}

/* === FIX: FAKTEN DECK MANAGER UI === */
.dm-grid {
    display: flex; 
    flex-direction: column; 
    gap: 12px;
    margin-top: 10px; 
    margin-bottom: 20px;
    max-height: 350px; 
    overflow-y: auto;
    padding: 5px;
}

.dm-item {
    position: relative !important; /* WICHTIG: √úberschreibt absolute Positionierung */
    background: var(--card-solid) !important;
    border: 1px solid var(--btn) !important;
    border-radius: 16px !important; 
    padding: 15px !important;
    display: flex !important; 
    align-items: center !important; 
    justify-content: space-between !important;
    gap: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    transform: none !important; /* Verhindert Rotation vom Memory-Deck */
}

.dm-info { 
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    text-align: left;
}

.dm-title { 
    font-weight: 800; 
    font-size: 14px; 
    color: var(--text);
    margin-bottom: 2px;
}

.dm-meta { 
    font-size: 11px; 
    opacity: 0.6; 
    color: var(--sub);
}

/* Der Switch im Manager */
.dm-switch { 
    position: relative; 
    display: inline-block; 
    width: 44px; 
    height: 24px; 
    flex-shrink: 0;
}

/* === CLOUD SYNC STYLES === */
.sync-card {
    border: 1px solid rgba(0, 184, 148, 0.3);
    background: linear-gradient(to bottom right, var(--card), rgba(0, 184, 148, 0.05));
}

.sync-topic-input-group {
    display: flex; gap: 8px; margin-bottom: 15px;
}

.sync-topic-input {
    flex: 1; 
    font-family: monospace; 
    font-size: 11px; 
    background: var(--bg);
    border: 1px solid var(--btn);
    color: var(--accent);
    padding: 10px;
    border-radius: 12px;
}

.sync-list {
    margin-top: 15px;
    border-top: 1px solid var(--btn);
    padding-top: 10px;
    max-height: 200px;
    overflow-y: auto;
}

.sync-item {
    background: var(--bg);
    border: 1px solid var(--btn);
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    animation: fadeIn 0.3s ease-out;
}

.sync-item-info {
    font-size: 12px;
}
.sync-date { font-weight: bold; color: var(--text); }
.sync-meta { font-size: 10px; opacity: 0.7; }

/* Fortschritts-Modal Overlay */
#syncProgressModal {
    display: none;
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85);
    z-index: 25000; /* GANZ oben */
    align-items: center; justify-content: center;
    flex-direction: column;
}

.sync-progress-box {
    background: var(--card-solid);
    padding: 30px;
    border-radius: 20px;
    width: 80%; max-width: 300px;
    text-align: center;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    border: 2px solid var(--accent);
}

.sync-bar-bg {
    width: 100%; height: 10px; background: var(--btn);
    border-radius: 5px; margin: 20px 0; overflow: hidden;
}
.sync-bar-fill {
    height: 100%; background: var(--accent); width: 0%;
    transition: width 0.3s linear;
}

/* === SYNC MANAGER STYLES === */
.sync-card {
    border: 1px solid rgba(0, 184, 148, 0.3);
    background: linear-gradient(to bottom right, var(--card), rgba(0, 184, 148, 0.05));
}

.sync-controls-row {
    display: flex; gap: 8px; margin-bottom: 15px; align-items: center;
}

.sync-select {
    flex: 1;
    padding: 10px;
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--btn);
    border-radius: 12px;
    font-weight: bold;
    font-size: 13px;
    outline: none;
}

.sync-icon-btn {
    width: 40px; height: 40px;
    display: flex; align-items: center; justify-content: center;
    background: var(--btn);
    border-radius: 12px;
    cursor: pointer;
    font-size: 18px;
    border: 1px solid transparent;
}
.sync-icon-btn:active { transform: scale(0.95); }

.sync-action-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
}

.sync-main-btn {
    padding: 15px; border-radius: 16px; border: none;
    font-weight: bold; font-size: 13px;
    display: flex; flex-direction: column; align-items: center; gap: 5px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    transition: transform 0.2s;
}
.sync-main-btn:active { transform: scale(0.96); }

/* Progress Modal */
#syncProgressModal {
    display: none;
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); z-index: 25000;
    align-items: center; justify-content: center; backdrop-filter: blur(5px);
}
.sync-progress-box {
    background: var(--card-solid); padding: 30px; border-radius: 24px;
    width: 85%; max-width: 320px; text-align: center;
    box-shadow: 0 20px 50px rgba(0,0,0,0.6); border: 2px solid var(--accent);
}
.sync-bar-bg {
    width: 100%; height: 12px; background: var(--btn);
    border-radius: 6px; margin: 20px 0; overflow: hidden;
}
.sync-bar-fill {
    height: 100%; background: linear-gradient(90deg, var(--accent), #00b894); 
    width: 0%; transition: width 0.3s linear;
}

/* === TIME FILTER PANEL (Slide Down) === */
#timeFilterPanel {
    background: var(--card);
    border-bottom: 1px solid var(--btn);
    padding: 15px;
    display: none; /* Standardm√§√üig zu */
    animation: slideDown 0.2s ease-out;
    margin-bottom: 15px;
    border-radius: 0 0 20px 20px;
    box-shadow: 0 10px 20px rgba(0,0,0,0.05);
}

.tf-row {
    display: flex; gap: 10px; align-items: center; margin-bottom: 10px;
}

.tf-input {
    flex: 1;
    padding: 10px;
    border: 1px solid var(--btn);
    border-radius: 12px;
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-weight: bold;
}

/* === RANGER HEADER CLICKABLE === */
.rf-header-clickable {
    flex: 1; 
    cursor: pointer; 
    padding: 5px 10px; 
    border-radius: 12px; 
    transition: background 0.2s;
    /* Damit man sieht, dass es klickbar ist */
    display: flex; flex-direction: column; justify-content: center;
}
.rf-header-clickable:active {
    background: rgba(255,255,255,0.1);
}

/* === RANGER SIDEBAR ITEMS === */
.rf-channel-item {
    padding: 12px; 
    margin-bottom: 8px; 
    border-radius: 12px; 
    cursor: pointer; 
    display: flex; 
    align-items: center; 
    gap: 10px;
    transition: background 0.2s;
    border: 1px solid transparent;
}

.rf-channel-info {
    flex: 1; 
    overflow: hidden; /* Wichtig f√ºr ... */
}

.rf-channel-name {
    font-weight: bold; 
    color: white; 
    font-size: 14px;
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis; /* Macht ... bei langem Text */
}

.rf-channel-topic {
    font-size: 10px; 
    opacity: 0.5; 
    color: white; 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis;
    font-family: monospace;
}

.rf-channel-menu-btn {
    width: 30px; height: 30px;
    display: flex; align-items: center; justify-content: center;
    border-radius: 50%;
    color: var(--sub);
    font-size: 18px;
    flex-shrink: 0;
}
.rf-channel-menu-btn:hover { background: rgba(255,255,255,0.1); color: white; }

/* === FIX: KONTEXT MEN√ú LEVEL (√úber Ranger Chat) === */
.context-menu {
    /* Muss h√∂her sein als Ranger Chat (20000) und Sync Modal (22000) */
    z-index: 30000 !important; 
}

.context-backdrop {
    z-index: 29999 !important;
}

/* === MICRO MENU STYLES === */

/* WICHTIG: Damit das Men√º aus der Leiste ragen kann */
.search-fusion-wrapper {
    overflow: visible !important; 
}

/* Container f√ºr Button + Men√º */
.micro-btn-wrap {
    position: relative;
    height: 100%;
    display: flex; align-items: center;
}

/* Der Button selbst */
.micro-btn {
    background: transparent;
    border: none;
    font-size: 11px; font-weight: 800;
    color: var(--sub);
    padding: 0 8px;
    height: 32px;
    border-radius: 8px;
    cursor: pointer;
    display: flex; align-items: center; gap: 4px;
    transition: all 0.2s;
    user-select: none;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.micro-btn:active, .micro-btn.is-open {
    background: var(--btn);
    color: var(--text);
}

/* Aktiver Zustand (z.B. wenn Filter an ist) */
.micro-btn.active-state {
    color: var(--accent);
}

/* Das Dropdown Men√º */
.micro-menu {
    position: absolute;
    top: 40px; /* Abstand von oben */
    right: 0;  /* Rechtsb√ºndig */
    
    background: var(--card-solid);
    border: 1px solid var(--btn);
    border-radius: 16px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    
    display: none; /* Standard: unsichtbar */
    flex-direction: column;
    min-width: 150px;
    padding: 6px;
    z-index: 10000; /* Ganz oben! */
    
    animation: popMenu 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.micro-menu.show { display: flex; }

/* Men√º Eintr√§ge */
.mm-item {
    padding: 10px 12px;
    font-size: 13px; font-weight: 600;
    color: var(--text);
    border-radius: 10px;
    cursor: pointer;
    display: flex; align-items: center; gap: 10px;
    transition: background 0.1s;
}

.mm-item:active { background: var(--btn); }

/* Ausgew√§hlter Eintrag */
.mm-item.selected { 
    color: var(--accent); 
    background: rgba(33, 150, 243, 0.1); 
    font-weight: 800;
}

/* Trennstrich zwischen Buttons */
.micro-sep {
    width: 1px; height: 16px; background: var(--btn); margin: 0 2px;
}

@keyframes popMenu { 
    from { opacity: 0; transform: translateY(-10px) scale(0.95); } 
    to { opacity: 1; transform: translateY(0) scale(1); } 
}

</style>
</head>
<body>

<!-- Global Toast & Undo -->
<div id="errorToast" class="error-toast"></div>
<div id="undoToast" class="undo-toast">
    <span id="undoText">Gez√§hlt: L√∂we (+1)</span>
    <button class="undo-btn" onclick="safeRun(performUndo)">R√ºckg√§ngig</button>
</div>

<!-- HEADER LOGO FINAL -->
<h1 class="app-brand">
    <span class="brand-tier">
        Tier
        <!-- WICHTIG: Die Tatzen liegen HIER DRIN -->
        <span class="paw paw-br">üêæ</span>
        <span class="paw paw-tl">üêæ</span>
    </span>
    <span class="brand-ticker">Ticker</span>
    <span class="brand-icon-pop">+1</span>
</h1>


<div id="scrollTopBtn" onclick="window.scrollTo({top:0, behavior:'smooth'})">‚¨ÜÔ∏è</div>


<!-- === VIEW: LIST (Startseite) === -->
<div id="view-list" class="view-section active">
    
  <!-- VIEW LIST HEADER (Micro-Menu Version) -->
<div class="list-header">
    
    <!-- SEARCH FUSION -->
    <div class="search-fusion-wrapper" id="sfWrapper">
        <input id="listSearch" class="sf-input" placeholder="Suche..." oninput="safeRun(debouncedRender)">
        
        <!-- Status Feedback Element -->
        <div class="status-overlay" id="sfStatus">...</div>

        <!-- RECHTE SEITE: MICRO MENUS -->
        <div class="sem-controls" style="gap:0; padding-left:4px;">
            
            <!-- 1. VIEW MENU (List/Grid) -->
            <div class="micro-btn-wrap">
                <div id="btn-view" class="micro-btn" onclick="toggleMicroMenu('menu-view')">
                    <span id="lbl-view">LIST</span> ‚ñæ
                </div>
                <div id="menu-view" class="micro-menu">
                    <div class="mm-item" onclick="setMicroView('list')"><span style="font-size:16px">üìÑ</span> Liste</div>
                    <div class="mm-item" onclick="setMicroView('grid')"><span style="font-size:16px">Áî∞</span> Raster</div>
                </div>
            </div>

            <div class="micro-sep"></div>

            <!-- 2. MODE MENU (Animals/Notes/Photos) -->
            <div class="micro-btn-wrap">
                <div id="btn-mode" class="micro-btn active-state" onclick="toggleMicroMenu('menu-mode')">
                    <span id="lbl-mode">TIERE</span> ‚ñæ
                </div>
                <div id="menu-mode" class="micro-menu" style="min-width:160px;">
                    <div class="mm-item" onclick="setMicroMode('animals')"><span style="font-size:16px">üêæ</span> Tiere</div>
                    <div class="mm-item" onclick="setMicroMode('notes')"><span style="font-size:16px">üìù</span> Notizen</div>
                    <div class="mm-item" onclick="setMicroMode('gallery')"><span style="font-size:16px">üì∑</span> Fotos</div>
                </div>
            </div>

            <div class="micro-sep"></div>

            <!-- 3. SORT MENU -->
            <div class="micro-btn-wrap">
                <div id="btn-sort" class="micro-btn active-state" onclick="toggleMicroMenu('menu-sort')">
                    <span id="lbl-sort">‚òÖ</span> ‚ñæ
                </div>
                <div id="menu-sort" class="micro-menu">
                    <div class="mm-item" onclick="setMicroSort('fav')"><span style="font-size:16px">‚≠ê</span> Favoriten</div>
                    <div class="mm-item" onclick="setMicroSort('last')"><span style="font-size:16px">üìÖ</span> Neueste</div>
                    <div class="mm-item" onclick="setMicroSort('name')"><span style="font-size:16px">üî§</span> Name (A-Z)</div>
                    <div class="mm-item" onclick="setMicroSort('count')"><span style="font-size:16px">üìä</span> Anzahl</div>
                </div>
            </div>

        </div>    
    </div>
</div>

    <!-- 1. TAG FILTER LEISTE -->
    <div id="tagFilterContainer" class="tag-scroll"></div>

    <!-- 2. NEU: ZEITRAUM FILTER PANEL (Versteckt) -->
    <div id="timeFilterPanel" style="display:none; background:var(--card); border-bottom:1px solid var(--btn); padding:15px; margin-bottom:15px; border-radius:0 0 20px 20px; animation:slideDown 0.2s ease-out;">
        <div style="font-size:11px; font-weight:bold; opacity:0.6; text-transform:uppercase; margin-bottom:8px;">Zeitraum w√§hlen</div>
        <div class="tf-row" style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
            <input type="date" id="tfStart" class="tf-input" onchange="safeRun(saveTimeFilter)" style="flex:1; padding:10px; border-radius:12px; border:1px solid var(--btn); background:var(--bg); color:var(--text);">
            <span style="opacity:0.5">bis</span>
            <input type="date" id="tfEnd" class="tf-input" onchange="safeRun(saveTimeFilter)" style="flex:1; padding:10px; border-radius:12px; border:1px solid var(--btn); background:var(--bg); color:var(--text);">
        </div>
        <div style="display:flex; gap:10px;">
            <button onclick="applyTimeFilterPreset('today')" style="flex:1; font-size:12px;">Heute</button>
            <button onclick="applyTimeFilterPreset('month')" style="flex:1; font-size:12px;">Monat</button>
            <button onclick="applyTimeFilterPreset('year')" style="flex:1; font-size:12px;">Jahr</button>
            <button onclick="toggleTimePanel()" style="background:var(--accent); color:white; width:40px;">OK</button>
        </div>
    </div>

    <!-- 3. EINKLAPPEN BUTTON (Erscheint hier dynamisch) -->
    <div id="listToggleContainer" style="margin-bottom: 10px; min-height: 5px;"></div>

    <!-- 4. DIE LISTE (Sneak Peek Wrapper) - DAS HATTE GEFEHLT! -->
    <div id="sneakPeekContainer" class="sneak-peek-wrapper collapsed">
        <!-- Overlay zum Ausklappen -->
        <div class="sneak-peek-overlay" onclick="safeRun(expandList)"></div>
        
        <!-- WICHTIG: Das ist das Element, das JS gesucht hat! -->
        <div id="list" style="padding-bottom: 20px;"></div>
    </div>
  
    <!-- Hinweis Text (nur sichtbar wenn zugeklappt) -->
    <div id="sneakHint" class="sneak-peek-hint">‚ñº Tippe auf die Liste zum Ausklappen ‚ñº</div>

    <!-- 5. Favoriten Container (Darunter) -->
    <div id="favContainer" style="margin-top: 20px;"></div>

    <!-- Empty State -->
    <div id="emptyState" style="text-align:center; padding:60px 20px; color:var(--sub); display:none;">
        <div style="font-size:60px; margin-bottom:15px; opacity:0.5">üêæ</div>
        <h3>Keine Tiere gefunden</h3>
        <p>Klicke auf das <b> + </b> um neue Tiere anzulegen.</p>
    </div>
</div>


<!-- === VIEW: ADMIN (Verwalten) === -->
 <!-- === VIEW: ADMIN (Verwalten) === -->
<div id="view-admin" class="view-section">
  
<!-- NEUE ADMIN HEADER BUTTONS -->
  <div class="admin-tools-grid">
      <div class="tool-card" onclick="safeRun(openSettings)">
          <span class="tc-icon">‚öôÔ∏è</span>
          <span class="tc-label">Einstellungen</span>
      </div>
      <div class="tool-card" onclick="safeRun(openInfoModal)">
          <span class="tc-icon">‚ÑπÔ∏è</span>
          <span class="tc-label">Hilfe & Info</span>
      </div>
  </div>

  <!-- BUBBLE 1: NEUES TIER (Kein Akkordeon, bleibt statisch offen) -->
  <div class="card-section">
    <h3>üêæ Neues Tier anlegen</h3>
    <div class="edit-tools" style="margin-bottom:0">
      <label class="file-label">
          <span style="font-size:24px">üñºÔ∏è</span> Galerie
          <input type="file" id="fileUpload" hidden accept="image/*" onchange="safeRun(handleImageUpload, this)">
      </label>
      <label class="file-label">
          <span style="font-size:24px">üì∑</span> Kamera
          <input type="file" id="cameraUpload" hidden accept="image/*" capture="environment" onchange="safeRun(handleImageUpload, this)">
      </label>
    </div>
    
    <div style="display:flex; gap:10px; margin:15px 0;">
        <input id="emojiInput" placeholder="ü¶Å" size="3" style="width:60px; text-align:center; font-size:24px">
        <input id="nameInput" placeholder="Name des Tiers (z.B. Rotfuchs)" style="flex:1">
    </div>
    
    <div style="margin-bottom:15px">
        <input id="tagInput" placeholder="Kategorie (z.B. Katze, V√∂gel)..." list="tagSuggestions">
        <datalist id="tagSuggestions">
            <option value="Katze"><option value="Hund"><option value="Fuchs">
            <option value="Hase"><option value="Igel"><option value="Marder">
            <option value="V√∂gel"><option value="Insekten">
        </datalist>
    </div>
    
    <div id="imgPreview" style="display:none; margin-bottom:15px; position:relative; width:fit-content; margin: 0 auto 15px auto;">
        <img id="previewEl" src="" style="width:80px; height:80px; border-radius:20px; object-fit:cover; border:2px solid var(--accent)">
        <div onclick="safeRun(clearImage)" style="position:absolute; top:-5px; right:-5px; background:red; color:white; border-radius:50%; width:24px; height:24px; display:flex; align-items:center; justify-content:center; cursor:pointer">‚úñ</div>
    </div>

    <button onclick="safeRun(addAnimal)" style="width:100%; background:var(--accent); color:#fff; padding:14px;">Tier Speichern ‚ú®</button>
  </div>


  <!-- BUBBLE 2: ORTE (Akkordeon) -->
  <div class="card-section">
    <!-- ONCLICK JETZT NUR HIER IM HEADER -->
    <div class="accordion-header" onclick="toggleAccordion(this)">
        <h3>üìç Orte & Suche</h3>
        <span class="acc-chevron">‚ñº</span>
    </div>
    <div class="accordion-content">
        <div class="accordion-inner">
            <p style="font-size:12px; opacity:0.7; margin-bottom:10px">Suche Orte oder nutze GPS, um die Adresse automatisch zu finden.</p>
            <div style="display:flex; gap:8px; align-items:flex-start;">
                <div class="autocomplete-container" style="flex:1">
                  <input id="osmInput" placeholder="Ort suchen (Enter)...">
                  <div id="osmResults" class="autocomplete-results"></div>
                </div>
                <button onclick="safeRun(locateMe)" title="Mein Standort" style="background:var(--card-solid); border:1px solid var(--btn); min-width:44px">üìç</button>
                <button onclick="safeRun(addManualLocation)" style="min-width:44px;">üíæ</button>
            </div>
            <div style="margin-top:15px; border-top:1px solid var(--btn); padding-top:10px;">
                <span style="font-size:12px; opacity:0.7">Gespeicherte Orte (zum L√∂schen antippen):</span>
                <div id="locationListDisplay" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; max-height:120px; overflow-y:auto;"></div>
            </div>
        </div>
    </div>
  </div>

<!-- BUBBLE: CLOUD SYNC MANAGER -->
<div class="card-section sync-card">
    <div class="accordion-header" onclick="toggleAccordion(this)">
        <h3 style="color:#00b894;">‚òÅÔ∏è Cloud Sync</h3>
        <span class="acc-chevron">‚ñº</span>
    </div>
    
    <div class="accordion-content">
        <div class="accordion-inner">
            
            <!-- HEADER MIT HILFE-TOGGLE -->
            <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:15px;">
                <p style="font-size:12px; opacity:0.8; margin:0; max-width:70%;">
                    Synchronisiere deine Ger√§te √ºber einen geheimen Kanal.
                </p>
                <button onclick="document.getElementById('syncHelpBox').style.display = document.getElementById('syncHelpBox').style.display==='none'?'block':'none'" 
                        style="font-size:11px; background:var(--bg); border:1px solid var(--accent); color:var(--accent); padding:4px 8px; border-radius:12px; cursor:pointer; font-weight:bold;">
                    ‚ÑπÔ∏è Anleitung & Info
                </button>
            </div>

            <!-- VERSTECKTE HILFE BOX -->
            <div id="syncHelpBox" style="display:none; background:var(--bg); padding:15px; border-radius:12px; margin-bottom:20px; border:1px solid var(--btn); font-size:12px; line-height:1.5;">
                <h4 style="margin:0 0 10px 0; color:var(--text);">So funktioniert's:</h4>
                <ul style="margin:0; padding-left:15px; opacity:0.9;">
                    <li style="margin-bottom:8px;">
                        <b>üì° Der Briefkasten:</b> Wir nutzen <i>ntfy.sh</i> als tempor√§ren Speicher. Deine Daten liegen dort f√ºr <b>12 Stunden</b> bereit.
                    </li>
                    <li style="margin-bottom:8px;">
                        <b>üîê Maximale Sicherheit:</b> Wenn du ein <b>Passwort</b> setzt, werden deine Daten auf deinem Handy verschl√ºsselt (AES-GCM). Der Server sieht nur Buchstabensalat.
                    </li>
                    <li style="margin-bottom:8px;">
                        <b>üîÑ Der Ablauf:</b>
                        1. Erstelle hier einen Kanal (mit Passwort!).<br>
                        2. Gib <b>exakt denselben</b> Kanal & Passwort auf deinem anderen Ger√§t ein.<br>
                        3. Klicke hier auf <b>"Hochladen"</b> und dr√ºben auf <b>"Pr√ºfen" &rarr; "Laden"</b>.
                    </li>
                </ul>
            </div>

            <!-- TEIL 1: KANAL WAHL & MANAGEMENT (Das gefixte St√ºck) -->
            <div class="sync-controls-row">
                <select id="syncChannelSelect" class="sync-select" onchange="safeRun(onSyncChannelChange)">
                    <option value="" disabled selected>-- Kein Kanal --</option>
                </select>
                
                <!-- Immer sichtbar: Neu erstellen -->
                <div class="sync-icon-btn" onclick="openAddSyncModal()" title="Neuer Kanal" style="background:var(--accent); color:white;">+</div>
                
                <!-- Kontext Men√º f√ºr den aktiven Kanal -->
                <div class="sync-icon-btn" onclick="openSyncChannelMenu(event)" title="Kanal Optionen" style="font-weight:900;">‚ãÆ</div>
            </div>

            <!-- TEIL 2: HAUPT-AKTIONEN -->
            <div class="sync-action-grid">
                <button onclick="safeRun(startCloudPush)" class="sync-main-btn" style="background:linear-gradient(135deg, var(--accent), #2980b9); color:white;">
                    <span style="font-size:24px">üì§</span> 
                    <span>Hochladen</span>
                </button>
                <button onclick="safeRun(checkForCloudBackups)" class="sync-main-btn" style="background:var(--card-solid); border:1px solid var(--btn); color:var(--text);">
                    <span style="font-size:24px">üîÑ</span> 
                    <span>Pr√ºfen</span>
                </button>
            </div>

            <!-- TEIL 3: LISTE GEFUNDENER BACKUPS -->
            <div id="syncListContainer" style="display:none; margin-top:15px; border-top:1px solid var(--btn); padding-top:10px;">
                <div style="font-size:11px; font-weight:bold; margin-bottom:5px; opacity:0.5;">GEFUNDENE BACKUPS (Letzte 12h):</div>
                <div id="syncListItems"></div>
            </div>
        </div>
    </div>
</div>

<!-- MODAL: NEUER KANAL (Updated) -->
<div id="syncAddModal" class="modal" style="display:none; z-index:22000; align-items:center; justify-content:center;">
    <div class="modal-content" style="max-width:350px;">
        <h3>Neuer Sync-Kanal</h3>
        
        <label style="font-size:12px; font-weight:bold;">Name (f√ºr dich):</label>
        <input id="newSyncName" placeholder="z.B. Mein Desktop" style="margin-bottom:15px;">
        
        <label style="font-size:12px; font-weight:bold;">Topic-Schl√ºssel:</label>
        <div style="display:flex; gap:8px; margin-bottom:5px;">
            <input id="newSyncTopic" placeholder="Generieren..." style="font-family:monospace; font-size:11px;">
            <button onclick="generateRandomTopic()" style="padding:0 10px;">üé≤</button>
        </div>
        
        <!-- NEU: PASSWORT FELD -->
        <hr style="border:0; border-top:1px dashed var(--btn); margin:15px 0;">
        <label style="font-size:12px; font-weight:bold;">üîí Verschl√ºsselung (Optional):</label>
        <input id="newSyncPass" type="password" placeholder="Passwort festlegen..." style="margin-bottom:5px;">
        <p style="font-size:10px; opacity:0.6; margin-bottom:20px;">
            Wenn gesetzt, wird alles unlesbar verschl√ºsselt.<br>
            ‚ö†Ô∏è Passwort muss auf allen Ger√§ten gleich sein!
        </p>
        
        <div style="display:flex; gap:10px;">
            <button onclick="saveNewSyncChannel()" style="flex:1; background:var(--accent); color:white;">Speichern</button>
            <button onclick="closeModal('syncAddModal')" style="flex:1; background:transparent; border:1px solid var(--sub);">Abbrechen</button>
        </div>
    </div>
</div>

<!-- MODAL: FORTSCHRITT -->
<div id="syncProgressModal">
    <div class="sync-progress-box">
        <div style="font-size:40px; margin-bottom:10px;" id="syncIcon">üöÄ</div>
        <h3 id="syncTitle" style="margin:0;">Sync l√§uft...</h3>
        <p id="syncStatus" style="font-size:12px; opacity:0.7; margin-top:5px;">Verbinde...</p>
        
        <div class="sync-bar-bg">
            <div id="syncBar" class="sync-bar-fill"></div>
        </div>
        
        <button onclick="abortSync()" style="font-size:11px; padding:5px 10px; background:transparent; color:var(--err-text); border:1px solid var(--err-text); border-radius:8px; cursor:pointer;">Vorgang abbrechen</button>
    </div>
</div>


  <!-- BUBBLE 3: DATEN (Akkordeon) -->
  <div id="backupCard" class="card-section">
    <!-- ONCLICK JETZT NUR HIER IM HEADER -->
    <div class="accordion-header" onclick="toggleAccordion(this)">
        <h3>üíæ Daten & Sicherung</h3>
        <div id="backupHeaderBadge" class="header-warning-badge">‚ö†Ô∏è Backup f√§llig!</div>
        <span class="acc-chevron">‚ñº</span>
    </div>

    <div class="accordion-content">
        <div class="accordion-inner">
            <!-- Warnbox -->
            <div id="backupWarningBox" class="backup-alert" style="display:none;">
                <div>
                    ‚ö†Ô∏è Dein letztes Backup ist <strong id="backupDaysCount">lange</strong> her.<br>
                    <span style="opacity:0.8; font-size:11px;">Sichere deine Sammlung lieber mal!</span>
                </div>
                <button onclick="document.getElementById('backupWarningBox').style.display='none'" title="Ausblenden">‚úï</button>
            </div>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px;">
                <button onclick="safeRun(downloadBackup)">üì¶ Backup</button>
                <button onclick="safeRun(exportCSV)">üìÑ CSV Export</button>
                <button onclick="document.getElementById('importFile').click()">üì• Import</button>
<!-- In der "Daten & Sicherung" Sektion einf√ºgen -->
<button onclick="openStorageExplorer()" solid var(--accent-glow);">
    üîç Datenbank Explorer √∂ffnen
</button>
                <input type="file" id="importFile" accept="application/json" hidden onchange="safeRun(importBackup, event)">
            </div>

            <div style="margin-top:20px; font-size:12px; opacity:0.8;">
                <div style="display:flex; justify-content:space-between"><span>Bild-Datenbank (IndexedDB):</span><span id="storageText">Lade...</span></div>
                <div class="xp-bar-bg" style="height:6px; margin-top:5px; background:var(--btn)"><div id="storageBar" class="xp-bar-fill" style="width:0%; background:var(--accent)"></div></div>
            </div>
        </div>
    </div>
  </div>

  <!-- BUBBLE 4: PAPIERKORB (Akkordeon) -->
  <div id="trashSection" class="card-section" style="border-color:var(--err-bg);">
      <!-- ONCLICK JETZT NUR HIER IM HEADER -->
      <div class="accordion-header" onclick="toggleAccordion(this)">
        <h3 style="color:var(--err-text)">üóëÔ∏è Papierkorb</h3>
        <span class="acc-chevron">‚ñº</span>
      </div>
      <div class="accordion-content">
        <div class="accordion-inner">
          <p style="font-size:12px; opacity:0.7; margin-bottom:10px">Gel√∂schte Elemente werden nach 30 Tagen automatisch entfernt.</p>
          <div id="trashList" style="max-height:200px; overflow-y:auto; margin-bottom:15px; background:var(--bg); border-radius:12px;"></div>
          <button onclick="safeRun(emptyTrash)" style="width:100%; background:var(--err-bg); color:var(--err-text); border:1px solid var(--err-text)">
              Papierkorb jetzt leeren
          </button>
        </div>
      </div>
  </div>    

  <div style="text-align:center; margin-top:40px; padding-top:20px; border-top:1px dashed var(--btn);">
      <p style="color:var(--err-text); font-weight:bold; font-size:12px; margin-bottom:10px">‚ö†Ô∏è GEFAHRENZONE</p>
      <button onclick="safeRun(hardReset)" style="background:transparent; color:var(--err-text); border:1px solid var(--err-text); font-size:12px">‚ö†Ô∏è App vollst√§ndig zur√ºcksetzen</button>
  </div>
</div>

<!-- === VIEW: MAP (Karte) === -->
<div id="view-map" class="view-section">
    <div id="map"></div>
    <div style="text-align:center; opacity:0.7; font-size:13px">Zeigt Orte deiner Sichtungen aller Jahre.</div>
<!-- TIME TRAVEL SLIDER -->
    <div class="map-slider-container">
        <div class="ms-header">
            <span>JAN</span>
            <span id="mapTimeDisplay" style="color:#fff; font-size:14px;">GANZES JAHR</span>
            <span>DEZ</span>
        </div>
        <input type="range" min="0" max="12" value="12" class="ms-range" oninput="safeRun(filterMapTime, this.value)">
    </div>

</div>

<!-- === VIEW: STATS (Statistik) === -->
<div id="view-stats" class="view-section">
  
<!-- SOLAR WIDGET (Interactive) -->
  <div class="solar-wrapper" id="solarWidget">
      <div class="solar-info">
          <div>
              <div class="sol-label" id="solPhase">Lade...</div>
              <div class="sol-time-big" id="solClock">--:--</div>
          </div>
          <div style="text-align:right">
              <div class="sol-label">‚òÄÔ∏è <span id="solSunrise">--:--</span></div>
              <div class="sol-label">üåô <span id="solSunset">--:--</span></div>
          </div>
      </div>

      <!-- Bogen & Sonne -->
      <div class="solar-animation-box"> <!-- Neuer Wrapper f√ºr Clipping -->
          <div class="solar-arc-container">
              <div class="solar-horizon"></div>
              <div class="solar-arc">
                  <div class="solar-body" id="solarOrbit">
                      <div class="solar-icon" id="solarIcon">‚òÄÔ∏è</div>
                  </div>
              </div>
          </div>
      </div>

      <!-- STANDORT BUTTON & SUCHE -->
      <div style="position:relative; margin-top:10px;">
          
          <!-- Der Button (Klickbar) -->
          <div class="sol-loc-btn" onclick="toggleSolarInput()">
              <span id="solLocName">üìç Standort w√§hlen</span> 
              <span style="font-size:10px; opacity:0.5; margin-left:4px;">‚úé</span>
          </div>

          <!-- Das Such-Overlay (Versteckt) -->
          <div id="solInputWrap" class="sol-search-overlay">
              <input id="solWidgetInput" placeholder="Stadt suchen (oder 'GPS')..." autocomplete="off">
              <div id="solWidgetResults" class="autocomplete-results" style="max-height:150px; border:none;"></div>
              
              <!-- Schlie√üen Button (kleines X rechts) -->
              <div onclick="toggleSolarInput()" style="position:absolute; right:10px; top:10px; color:#333; cursor:pointer; font-weight:bold;">‚úï</div>
          </div>

      </div>
  </div>


<!-- DAILY FACT WIDGET (Fixed Layout) -->
<div class="card-section widget-docked-top" id="factWidget" style="display:none; position:relative;">
    
    <div class="fact-widget-header">
        <h3 style="margin:0; font-size:14px; text-transform:uppercase; color:var(--accent); letter-spacing:1px;">Wusstest du?</h3>
        
        <div class="fact-controls">
             <div id="factHeart" onclick="safeRun(toggleFactLike)" style="cursor:pointer; font-size:22px; transition:transform 0.2s;">ü§ç</div>
             <div onclick="safeRun(openFactMenu, event)" style="cursor:pointer; font-size:22px;">‚ãÆ</div>
        </div>
    </div>

    <div style="display:flex; gap:15px; align-items:flex-start;">
        <div id="factIcon" style="font-size:40px; background:var(--bg); width:60px; height:60px; display:flex; align-items:center; justify-content:center; border-radius:16px; border:1px solid var(--btn); flex-shrink:0;">üí°</div>
        
        <div class="fact-content-col">
            <!-- Scrollbarer Text -->
            <div class="fact-scroll-area">
                <p id="factText" style="margin:0; font-size:15px; line-height:1.5; font-weight:500; font-style:italic; color:var(--text);">
                    Lade Wissen...
                </p>
                <div id="factSource" style="margin-top:8px; font-size:10px; opacity:0.6; text-transform:uppercase;"></div>
            </div>

            <!-- Fester Button (Au√üerhalb vom Scroll!) -->
            <div class="fact-refresh-fixed" onclick="safeRun(loadRandomFact)">
                ‚Üª Neu
            </div>
        </div>
    </div>
</div>

<!-- Der Footer Button (Gr√∂√üer & besser lesbar) -->
<div id="factLibraryBtn" class="fact-footer-btn" onclick="safeRun(openLibraryModal)" style="display:none;">
    <span style="font-size:16px;">üìö</span>
    <span>MEINE SAMMLUNG</span>
    <span id="libCountBadge" class="lib-count-badge">0</span>
</div>

  <!-- Header: Nur der Button (Rechtsb√ºndig) -->
  <div style="display:flex; justify-content:flex-end; margin-bottom:20px; padding-top:5px;">
      <select id="statsYearSelect" onchange="safeRun(renderStats)" title="Zeitraum w√§hlen"></select>
  </div>

  <!-- Inhalt Container -->
  <div id="statsContainer">
    <div id="statsContent"></div>
  </div>
  
  <!-- Share Button -->
  <button onclick="safeRun(generateShareCard)" style="width:100%; margin-top:30px; background:var(--text); color:var(--bg); border-radius:20px; padding:15px; font-weight:bold; box-shadow: var(--shadow); display:flex; align-items:center; justify-content:center; gap:8px; transition:transform 0.2s;">
      <span style="font-size:18px;">üé®</span> Share Card erstellen
  </button>
  
  <div style="height:20px;"></div>
</div>

<!-- MAP BOTTOM SHEET (Navigator Style) -->
<div id="mapSheet" class="map-sheet">
    <!-- Icon links -->
    <div style="font-size:30px">üìç</div>
    
    <!-- Text Info -->
    <div class="sheet-info">
        <h4 id="sheetTitle">Ort Name</h4>
        <p id="sheetSub">Lade Infos...</p>
    </div>
    
    <!-- Die animierten Pfeile -->
    <div class="arrow-track">
        <div class="chevron"></div>
        <div class="chevron"></div>
        <div class="chevron"></div>
    </div>

    <!-- Der Action Button (mit alter ID f√ºr JS-Kompatibilit√§t) -->
    <button id="sheetJumpBtn" class="v2-btn">‚ûî</button>
</div>

<!-- === FLOATING ISLAND NAV === -->
<div class="nav-island-container">
    <div class="nav-island">
        
        <!-- 1. LISTE -->
        <button class="nav-item active" onclick="safeRun(switchView, 'view-list', this)">
            <span class="nav-icon">üìã</span>
            <span>Liste</span>
        </button>
        
        <!-- 2. STATS (Jetzt hier links) -->
        <button class="nav-item" onclick="safeRun(switchView, 'view-stats', this)">
            <span class="nav-icon">üìä</span>
            <span>Stats</span>
        </button>

        <!-- 3. ACTION (MITTE) -->
        <div class="nav-main-fab" onclick="safeRun(openQuickSighting)">
            +
        </div>

        <!-- 4. KARTE -->
        <button class="nav-item" onclick="safeRun(switchView, 'view-map', this)">
            <span class="nav-icon">üåç</span>
            <span>Karte</span>
        </button>
        
        <!-- 5. VERWALTUNG (Rechts au√üen) -->
        <button class="nav-item" onclick="safeRun(switchView, 'view-admin', this)">
            <span class="nav-icon">üõ†Ô∏è</span>
            <span>System</span>
        </button>

    </div>
</div>

<!-- CINEMATIC MEMORY MODAL -->
<div id="storyModal" class="modal">
    <!-- Schwebender Close Button -->
    <div class="cinematic-close" onclick="closeModal('storyModal')">‚úï</div>

    <div class="modal-content">
        <!-- Hier landet der Kartenstapel -->
        <div class="deck-section">
            <div class="deck-container" id="cardDeck">
                 <!-- Empty State -->
                 <div class="deck-empty">
                     <div style="font-size:60px; margin-bottom:15px; opacity:0.8;">üåå</div>
                     <div style="color:white; font-weight:bold; font-size:18px; letter-spacing:1px;">Alles gesehen</div>
                     <p style="color:rgba(255,255,255,0.5); font-size:13px; margin-top:5px;">Seite neu laden f√ºr mehr.</p>
                     
                     <button onclick="closeModal('storyModal')" 
                             style="margin-top:30px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:white; padding:12px 30px; border-radius:30px; font-weight:bold; cursor:pointer;">
                         Schlie√üen
                     </button>
                 </div>
            </div>
        </div>
    </div>
</div>

<!-- MODALS WITH SWIPE HANDLE -->
<div id="detailModal" class="modal">
    <div class="modal-content">
        <!-- SHEET HANDLE ENTFERNT, damit man nicht denkt, man kann swipen -->
        <div class="close-btn" onclick="closeModal('detailModal')">‚úï</div>
        <div style="display:flex; align-items:center; gap:10px; margin-bottom:20px; padding-bottom:10px; border-bottom:1px solid var(--btn)">
             <div class="modal-icon" id="detailIcon" style="font-size:50px; line-height:1"></div>
             <div>
                 <h2 id="detailTitle" style="margin:0">Tier</h2>
                 <select id="detailYearSelect" onchange="safeRun(updateDetailChart)" style="padding:4px; font-size:13px; margin-top:4px"></select>
             </div>
        </div>
        <div id="modalBody"></div>
    </div>
</div>


<!-- VIEW NOTE MODAL (Lese-Ansicht) -->
<div id="noteViewModal" class="modal">
  <div class="modal-content paper-modal">
<!-- NEU: Das Helden-Bild --> <img id="nvHeroImg" class="paper-hero-img" onclick="safeRun(openLightboxFromNote)"> <div class="close-btn paper-close" onclick="closeModal('noteViewModal')">‚úï</div> <!-- Header: Datum & Ort (Bleibt wie es war) --> <div class="paper-header"> <div id="nvDate" class="paper-date">Datum</div> <div id="nvLoc" class="paper-loc">Ort</div> </div>

    <!-- Der Inhalt -->
    <div class="paper-body">
        <div id="nvText" class="paper-text">Lade Notiz...</div>
    </div>

    
<!-- ... code davor ... -->

    <!-- Footer: Aktionen -->
    <div class="paper-footer" style="justify-content: space-between; align-items: center;">
        <!-- NEU: Share Button (Links) -->
        <button onclick="safeRun(shareSingleNote)" class="paper-action-btn" style="border-color:var(--accent); color:var(--accent);">
            üì§ Teilen
        </button>

        <!-- Edit Button (Rechts) -->
        <button id="nvEditBtn" class="paper-action-btn">‚úèÔ∏è Bearbeiten</button>
    </div>
    
  </div> <!-- 1. FEHLENDES DIV: Schlie√üt modal-content -->
</div>     <!-- 2. FEHLENDES DIV: Schlie√üt noteViewModal -->



<div id="noteModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('noteModal')">‚úï</div>
    
    <h3 id="noteModalTitle">‚ûï Sichtung</h3>

    <!-- NEU: Tier-Auswahl (Nur sichtbar bei "Schnell-Sichtung") -->
    <div id="noteAnimalWrapper" style="display:none; margin-bottom:15px; position:relative;">
        <label style="font-size:12px; font-weight:bold; opacity:0.7; margin-bottom:4px; display:block;">Welches Tier?</label>
        <input id="noteAnimalInput" placeholder="üîç Tiername tippen (z.B. Wolf)..." style="font-weight:bold; border:2px solid var(--accent);">
        <!-- Autocomplete Liste -->
        <div id="noteAnimalResults" class="autocomplete-results"></div>
    </div>

    <!-- Bestehende Inputs -->
    <input type="date" id="noteDate" style="margin-bottom:10px">
    
<!-- ZEIT & ORT (Nebeneinander) -->
    <div style="display:flex; gap:10px; margin-bottom:10px; align-items:flex-start;">
        <!-- Zeit -->
        <input type="time" id="noteTime" style="width:110px; flex-shrink:0;">
        
        <!-- Ort (Jetzt als Smart Input) -->
        <div style="position:relative; flex:1;">
            <input id="noteLoc" placeholder="üìç Ort (tippen/w√§hlen)..." autocomplete="off">
            <!-- Container f√ºr Vorschl√§ge -->
            <div id="noteLocResults" class="autocomplete-results"></div>
        </div>
    </div>

<!-- BILD UPLOAD & VORSCHAU -->
<div class="edit-tools" style="margin-bottom: 10px; margin-top: 0;">
   <label class="file-label" style="padding: 10px; flex-direction:row; gap:10px;">
       <span>üì∑</span> Foto
       <input type="file" id="noteCamInput" hidden accept="image/*" capture="environment" onchange="safeRun(handleNoteImgUpload, this)">
   </label>
   <label class="file-label" style="padding: 10px; flex-direction:row; gap:10px;">
       <span>üñºÔ∏è</span> Galerie
       <input type="file" id="noteGalInput" hidden accept="image/*" onchange="safeRun(handleNoteImgUpload, this)">
   </label>
</div>

<!-- VORSCHAU CONTAINER -->
<div id="noteImgPreviewBox" class="note-img-preview-container">
    <img id="noteImgEl" class="note-img-preview">
    <div class="note-img-remove" onclick="safeRun(removeNoteImg)">‚úï</div>
</div>

    <textarea id="noteText" placeholder="Was hast du beobachtet?" rows="4" style="margin-bottom:15px"></textarea>
    <button id="noteSaveBtn" style="width:100%; background:var(--accent); color:#fff; padding:15px">Speichern</button>
  </div>
</div>

<div id="importModal" class="modal">
  <div class="modal-content" style="text-align:center">
    <div class="sheet-handle"></div>
    <h3>Backup Importieren</h3>
    <p style="opacity:0.7">Wie m√∂chtest du die Daten importieren?</p>
    <div class="import-actions">
        <button class="btn-merge" onclick="safeRun(confirmImport, 'merge')">‚ú® Zusammenf√ºgen (Smart Merge)<br><small>F√ºgt neue Daten hinzu, beh√§lt alte</small></button>
        <button class="btn-overwrite" onclick="safeRun(confirmImport, 'overwrite')" style="background:var(--err-bg); color:var(--err-text); border:1px solid var(--err-text)">‚ö†Ô∏è Alles √úberschreiben<br><small>L√∂scht ALLE aktuellen Daten</small></button>
        <button onclick="safeRun(confirmImport, 'cancel')">Abbrechen</button>
    </div>
  </div>
</div>

<div id="iconModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('iconModal')">‚úï</div>
    
    <h3>‚úèÔ∏è Tier bearbeiten</h3>
    
    <!-- Bilder Upload -->
    <div class="edit-tools">
       <label class="file-label">üñºÔ∏è Galerie<input type="file" id="editFileInput" hidden accept="image/*" onchange="safeRun(handleEditFile, this)"></label>
       <label class="file-label">üì∑ Foto<input type="file" id="editCameraInput" hidden accept="image/*" capture="environment" onchange="safeRun(handleEditFile, this)"></label>
    </div>

    <!-- Bild Vorschau -->
    <div id="editPreviewContainer" style="text-align:center; display:none; margin-bottom:15px">
        <img id="editPreviewImg" src="" style="width:100px; height:100px; border-radius:20px; object-fit:cover; border:3px solid var(--accent); box-shadow:0 5px 15px rgba(0,0,0,0.2);">
        <br><button onclick="safeRun(removeEditImage)" style="margin-top:8px; font-size:12px; padding:6px 12px; background:var(--err-bg); color:var(--err-text); border:none; border-radius:15px; font-weight:bold;">üóëÔ∏è Bild entfernen</button>
    </div>

    <!-- NEU: Name √§ndern -->
    <label style="font-size:12px; font-weight:bold; opacity:0.7; margin-bottom:4px; display:block;">Name:</label>
    <div style="display:flex; gap:10px; margin-bottom:15px">
       <input id="editEmoji" style="width:60px; font-size:24px; text-align:center" placeholder="Icon">
       <input id="editName" placeholder="Tiername (z.B. Wolf)" style="font-weight:bold;">
    </div>

    <!-- Kategorien -->
    <label style="font-size:12px; font-weight:bold; opacity:0.7; margin-bottom:4px; display:block;">Kategorie / Tags:</label>
    <input id="editTag" placeholder="z.B. S√§ugetiere, Wald (Komma getrennt)" style="margin-bottom:20px;">

    <button onclick="safeRun(saveIconEdit)" style="width:100%; background:var(--accent); color:#fff; padding:15px; font-size:16px;">üíæ √Ñnderungen speichern</button>
  </div>
</div>

<!-- SETTINGS MODAL (FIXED STRUCTURE) -->
<div id="notifyModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('notifyModal')">‚úï</div>
    
    <h3>‚öôÔ∏è Einstellungen</h3>

    <!-- GRUPPE 1: ERSCHEINUNGSBILD -->
    <h4 style="margin-top:20px; margin-bottom:10px; opacity:0.7; font-size:12px; text-transform:uppercase;">Design & Ansicht</h4>
    
    <!-- Dark Mode -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
        <span>üåô Dark Mode</span>
        <label class="switch">
            <input type="checkbox" id="settingDarkToggle" onchange="safeRun(toggleDarkMode)">
            <span class="slider"></span>
        </label>
    </div>

    <!-- Kompakt Modus -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
        <span>üì± Kompakt-Ansicht (klein)</span>
        <label class="switch">
            <input type="checkbox" id="compactToggle" onchange="safeRun(toggleCompactMode)">
            <span class="slider"></span>
        </label>
    </div>

    <!-- Solar Standort -->
    <h4 style="margin-top:20px; margin-bottom:10px; opacity:0.7; font-size:12px; text-transform:uppercase;">üåû Astro-Standort</h4>
    <div style="background:var(--bg); padding:15px; border-radius:12px; margin-bottom:10px;">
        <div class="autocomplete-container" style="position:relative;">
            <input id="solarLocInput" placeholder="Stadt f√ºr Sonnenzeiten..." style="width:100%; border:1px solid var(--btn); padding:10px; border-radius:8px;">
            <div id="solarLocResults" class="autocomplete-results"></div>
        </div>
        <p style="font-size:10px; opacity:0.5; margin:8px 0 0 0;">F√ºr Sonnenaufgang/-untergang im Widget.</p>
    </div>

    <!-- GRUPPE 2: TON & BENACHRICHTIGUNG -->
    <h4 style="margin-top:20px; margin-bottom:10px; opacity:0.7; font-size:12px; text-transform:uppercase;">Ton & Alarm</h4>

    <!-- Stummschalten -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
        <span>üîá Stummschalten</span>
        <label class="switch">
            <input type="checkbox" id="settingMuteToggle" onchange="safeRun(toggleMuteState)">
            <span class="slider"></span>
        </label>
    </div>

    <!-- Inaktivit√§ts-Alarm -->
    <div style="background:var(--bg); padding:15px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:15px">
        <span>‚è∞ Inaktivit√§ts-Alarm</span>
        <label class="switch"><input type="checkbox" id="notifyToggle"><span class="slider"></span></label>
    </div>
    
    <!-- Alarm Details -->
    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px; padding:0 10px;">
        <span style="font-size:14px;">Erinnern nach Tagen:</span> 
        <input type="number" id="notifyDays" value="7" style="width:80px; padding:8px; border-radius:8px; border:1px solid var(--btn);">
    </div>
    
    <div style="display:flex; gap:10px; margin-bottom:20px">
        <button onclick="safeRun(saveNotifySettings)" style="flex:1; background:var(--accent); color:#fff; padding:12px; border-radius:12px;">Speichern</button>
        <button onclick="safeRun(testNotification)" style="flex:1; padding:12px; border-radius:12px;">Testen</button>
    </div>

    <hr style="opacity:0.2; margin: 20px 0;">
    
    <!-- KALENDER -->
    <h4 style="margin-bottom:10px; opacity:0.7; font-size:12px; text-transform:uppercase;">üìÖ Kalender-Export</h4>
    <div style="display:flex; gap:5px; margin-bottom:10px">
        <select id="icsFreq" style="flex:1;"><option value="WEEKLY">W√∂chentlich</option><option value="DAILY">T√§glich</option></select>
        <input type="time" id="icsTime" value="19:00" style="flex:1;">
    </div>
    <select id="icsDay" style="margin-bottom:10px; width:100%;"><option value="SA">Samstag</option><option value="SU">Sonntag</option></select>
    <button onclick="safeRun(downloadICS)" style="width:100%; padding:12px; border-radius:12px;">üìÖ ICS Datei laden</button>
  </div>
</div>

<!-- PAPIERKORB DETAILS MODAL -->
<div id="trashDetailModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('trashDetailModal')">‚úï</div>
    <h3>üóëÔ∏è Gel√∂schtes Element</h3>
    
    <div style="background:var(--bg); padding:15px; border-radius:12px; margin-bottom:15px; font-size:14px; line-height:1.6">
        <div style="margin-bottom:8px"><strong>Art:</strong> <span id="tdType">...</span></div>
        <div style="margin-bottom:8px"><strong>Name:</strong> <span id="tdName" style="color:var(--accent); font-weight:bold">...</span></div>
        <div style="margin-bottom:8px"><strong>Datum:</strong> <span id="tdDate">...</span></div>
        <div style="margin-bottom:8px"><strong>Zeit:</strong> <span id="tdTime">...</span></div>
        <div style="margin-bottom:8px"><strong>Ort:</strong> <span id="tdLoc">...</span></div>
        <div><strong>Notiz:</strong> <div id="tdNote" style="background:var(--card); padding:8px; border-radius:8px; margin-top:4px; font-style:italic; opacity:0.8">...</div></div>
    </div>

    <button id="tdRestoreBtn" style="width:100%; background:var(--accent); color:#fff; padding:15px">‚ôªÔ∏è Wiederherstellen</button>
  </div>
</div>

<!-- HEUTE DETAILS MODAL -->
<div id="todayModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('todayModal')">‚úï</div>
    <h3>üìÖ Heute entdeckt</h3>
    <p style="font-size:13px; opacity:0.6; margin-top:-10px; margin-bottom:20px">Chronologische Liste deiner heutigen Sichtungen.</p>
    
    <div id="todayListContainer" class="today-list-container">
        <!-- Hier wird die Liste reingeladen -->
    </div>
  </div>
</div>

<!-- MEMORY DECK SECTION -->
  <div id="memoryDeckWrapper" style="display:none; animation:fadeIn 0.5s;">
      <div style="text-align:center; margin-bottom:5px; margin-top:10px;">
          <h3 style="font-size:14px; text-transform:uppercase; letter-spacing:2px; opacity:0.6; margin:0;">Random Memories</h3>
          <div style="font-size:11px; opacity:0.4;">Deine Zufalls-Fundst√ºcke</div>
      </div>
      
      <div class="deck-section">
          <div class="deck-container" id="cardDeck">
               <div class="deck-empty">
                   <div style="font-size:40px; margin-bottom:10px;">‚ú®</div>
                   <div>Alle Erinnerungen gesehen!</div>
               </div>
               <!-- Karten werden hier generiert -->
          </div>
      </div>
  </div>

<!-- LIGHTBOX F√úR BILDER -->
<div id="lightboxModal" onclick="closeImageLightbox()">
    <img id="lightboxImg" src="" alt="Gro√üansicht">
</div>

<!-- LEAFLET JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>




<!-- === INFO MODAL (ULTIMATE EDITION) === -->
<div id="infoModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('infoModal')">‚úï</div>
    
    <div style="text-align:center; margin-bottom:20px; border-bottom:1px solid var(--btn); padding-bottom:15px;">
        <div style="font-size:40px; margin-bottom:5px;">üìñ</div>
        <h2 style="margin:0;">Dein Ranger-Handbuch</h2>
        <p style="opacity:0.6; font-size:13px; margin:5px 0 0 0;">Alle Funktionen im √úberblick</p>
    </div>

    <div style="height:60vh; overflow-y:auto; padding-right:5px;">
        
        <!-- KAPITEL 1: BEOBACHTEN -->
        <div style="background:var(--bg); padding:15px; border-radius:16px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:var(--accent);">üêæ Beobachten & Z√§hlen</h4>
          Nutze den gro√üen <b>+ Button</b> in der Mitte, um schnell ein Tier zu erfassen. 
            Tippe in der Liste auf ein Tier f√ºr <b>Details & Verlauf</b> oder auf das kleine <b>+</b> f√ºr eine schnelle Z√§hlung. 
Klicke auf ein Tier in der Liste oder auf eine Kachel um das Tier zu bearbeiten und Details zu sehen.
        </div>

        <!-- KAPITEL 2: WISSEN & SPASS -->
        <div style="background:var(--bg); padding:15px; border-radius:16px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#9c27b0;">üß† Wissen & Quiz</h4>
            <ul style="padding-left:15px; margin:0; font-size:13px; opacity:0.9; line-height:1.6;">
                <li><b>Fakten-Widget:</b> Jeden Tag spannendes Wissen. Tippe auf ‚ù§Ô∏è zum Speichern oder auf <b>‚ãÆ</b> f√ºr mehr Optionen.</li>
                <li><b>Quiz-Master:</b> Teste dein Wissen! Es gibt verschiedene Modi (L√ºgendetektor, Foto-R√§tsel...). Du verdienst damit XP!</li>
                <li><b>Decks:</b> Du kannst eigene Wissens-Sammlungen importieren (z.B. "V√∂gel Europas").</li>
            </ul>
        </div>

        <!-- KAPITEL 3: LEVEL & STATS -->
        <div style="background:var(--bg); padding:15px; border-radius:16px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#f1c40f;">üèÜ Level & Statistik</h4>
            <ul style="padding-left:15px; margin:0; font-size:13px; opacity:0.9; line-height:1.6;">
                <li><b>XP System:</b> Jede Sichtung und jedes Quiz bringt Punkte. Steige auf vom "Ameisen-Z√§hler" zur Legende!</li>
                <li><b>Astro-Wetter:</b> Das Widget zeigt dir Sonnenaufgang und D√§mmerung f√ºr deinen Standort.</li>
                <li><b>Karte:</b> Mit dem "Zeitreise-Schieberegler" siehst du, wo du im Sommer oder Winter unterwegs warst.</li>
            </ul>
        </div>

        <!-- KAPITEL 4: CLOUD & SYNC -->
        <div style="background:var(--bg); padding:15px; border-radius:16px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:#00b894;">‚òÅÔ∏è Cloud Sync & Funk</h4>
            <ul style="padding-left:15px; margin:0; font-size:13px; opacity:0.9; line-height:1.6;">
                <li><b>Ranger Funk:</b> Ein Chat f√ºr dich und deine Freunde. Tauscht Bilder und Nachrichten aus (ben√∂tigt Internet).</li>
                <li><b>Cloud Sync (Neu!):</b> Synchronisiere deine App zwischen Handy und PC.
                    <br><i>Sicherheit:</i> Nutze ein Passwort, dann werden deine Daten <b>verschl√ºsselt</b> √ºbertragen. Niemand au√üer dir kann sie lesen.
                </li>
            </ul>
        </div>

        <!-- KAPITEL 5: DATEN -->
        <div style="background:var(--bg); padding:15px; border-radius:16px; margin-bottom:15px;">
            <h4 style="margin:0 0 10px 0; color:var(--text);">üíæ Deine Daten</h4>
            <p style="font-size:13px; margin:0;">
                Alle Daten liegen <b>offline</b> auf deinem Ger√§t. Nichts wird automatisch ins Internet gesendet.<br>
                ‚ö†Ô∏è <b>Wichtig:</b> Mache regelm√§√üig Backups (unter System > Daten), damit bei einem Handyverlust nichts verloren geht.
            </p>
        </div>

    </div>

    <!-- ACTION BUTTON -->
    <button onclick="startTutorial(true)" style="width:100%; background:var(--card); border:2px solid var(--accent); color:var(--accent); font-weight:bold; padding:15px; border-radius:16px; font-size:15px; margin-top:10px;">
        üéì Interaktive Tour starten
    </button>
    
    <p style="text-align:center; font-size:11px; opacity:0.3; margin-top:15px;">Tier Ticker Ultimate ‚Ä¢ Version 7.0</p>
  </div>
</div>









<!-- === NEU: ONBOARDING CONTAINER === -->
<!-- 1. Der dunkle Hintergrund (Klicksperre) -->
<div id="onboardingOverlay"></div>

<!-- 2. Die Sprechblase (Separat, damit sie immer oben ist) -->
<div id="onboardingBubble" class="onboarding-box" style="display:none;">
    <h3 id="tourTitle">Willkommen!</h3>
    <p id="tourText">Sch√∂n, dass Du da bist.</p>
    <div class="onboarding-btn-row">
        <button onclick="endTutorial()" style="background:transparent; border:1px solid var(--sub); font-size:12px; padding:8px;">Beenden</button>
        <button id="tourNextBtn" onclick="nextStep()" style="background:var(--accent); color:#fff; flex:1">Weiter ‚ûî</button>
    </div>
</div>
<!-- LIBRARY / DISCOVERY MODAL (V3 - TABS & DRILL DOWN) -->
<div id="libraryModal" class="modal">
  <div class="modal-content" style="height: 85vh; display:flex; flex-direction:column; padding-bottom:0;">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('libraryModal')">‚úï</div>
    
    <!-- Header Area -->
    <div style="flex-shrink:0; padding-bottom:5px;">
        <h3 style="margin-bottom:15px">üìö Wissens-Zentrale</h3>
        
        <!-- Haupt-Navigation (Oben) -->
        <div class="tab-nav">
            <div id="tabSaved" class="tab-btn active" onclick="switchLibTab('saved')">
                Meine Sammlung <span id="badgeSaved" style="opacity:0.6">(0)</span>
            </div>
            <div id="tabDiscover" class="tab-btn" onclick="switchLibTab('discover')">
                üåç Alle Fakten
            </div>
        </div>

        <!-- Filter Chip (Erscheint nur beim Drill-Down) -->
        <div id="libFilterContainer" class="filter-chip-container">
            <div class="filter-chip" onclick="safeRun(removeAnimalFilter)">
                <span id="libActiveFilterName">Tiername</span> <span>‚úï</span>
            </div>
        </div>

        <!-- Search Bar -->
        <div class="search-fusion-wrapper" style="margin-bottom:10px;">
            <input id="libSearchInput" class="sf-input" placeholder="Suchen..." oninput="safeRun(handleLibInput)">
        </div>
        
        <!-- HIER KOMMEN DIE TABS HIN (Dynamisch per JS) -->
        <div id="libSearchTabs"></div>

    </div>

    <!-- Scrollable Content Area -->
    <div style="flex:1; overflow-y:auto; min-height:0; padding-bottom:20px;" id="libScrollArea">
        
        <!-- Hier landet die Liste (Tiere ODER Fakten Grid) -->
        <div id="libraryContent"></div>
        
        <!-- Button "Mehr laden" (Nur bei Global) -->
        <button id="libLoadMoreBtn" onclick="safeRun(loadMoreGlobalFacts)" style="display:none; width:100%; margin-top:10px; opacity:0.7;">Mehr laden üëá</button>

        <!-- Empty States -->
        <div id="libEmptyState" style="text-align:center; padding:40px; display:none; opacity:0.6;">
            Keine Treffer.
        </div>
    </div>
  </div>
</div>


<!-- FLAVOR MODAL (TAG SEARCH ENGINE) -->
<div id="flavorModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('flavorModal')">‚úï</div>
    
    <h3>üéõÔ∏è Themen-Filter</h3>
    <p style="opacity:0.7; font-size:13px; margin-bottom:15px;">
        Suche und w√§hle Themen, die du im Widget sehen m√∂chtest.
    </p>

    <!-- 1. Aktive Filter (Schnellansicht) -->
    <div id="flavorActiveWrapper" style="display:none; margin-bottom:15px;">
        <div class="flavor-section-title">DEINE AUSWAHL</div>
        <div id="flavorActiveList" class="flavor-grid"></div>
    </div>

    <!-- 2. Suche -->
    <div class="search-fusion-wrapper" style="margin-bottom:15px; height:44px;">
        <input id="flavorSearchInput" class="sf-input" placeholder="Thema suchen..." oninput="safeRun(renderFlavorAllList)">
        <div style="padding-right:12px; opacity:0.5;">üîç</div>
    </div>

    <!-- 3. Alle Tags Liste (Scrollbar) -->
    <div class="flavor-section-title">ALLE THEMEN</div>
    <div id="flavorListContainer" class="flavor-grid flavor-scroll-area">
        <!-- Wird per JS gef√ºllt -->
    </div>

    <button onclick="saveFlavorSettings()" style="width:100%; background:var(--accent); color:#fff; padding:15px; margin-top:20px; border-radius:16px;">Speichern & Anwenden</button>
  </div>
</div>

<!-- QUIZ MODAL -->
<div id="quizModal" class="modal">
  <div class="modal-content">
    <div class="close-btn" onclick="closeModal('quizModal')">‚úï</div>
    
    <div style="text-align:center; margin-bottom:15px;">
        <div style="font-size:40px; margin-bottom:5px;">üß†</div>
        <h3 style="margin:0;">Quiz-Master</h3>
        <div id="quizScoreHeader" class="quiz-score-display">Gesamt-XP: 0</div>
    </div>

    <div class="quiz-container">
        <!-- Hier landet die Frage -->
        <div id="quizQuestionBox" class="quiz-question-box">
            Lade Frage...
        </div>

        <!-- Hier landen die 3 Buttons -->
        <div id="quizOptionsBox" class="quiz-options-grid"></div>
        
        <!-- Next Button (erst unsichtbar) -->
        <button id="quizNextBtn" onclick="nextQuizQuestion()" style="display:none; width:100%; margin-top:20px; background:var(--accent); color:white; padding:15px; box-shadow:0 5px 15px var(--accent-glow);">
            N√§chste Frage ‚ûî
        </button>
    </div>
  </div>
</div>
<!-- QUIZ MENU MODAL -->
<div id="quizMenuModal" class="modal">
  <div class="modal-content">
    <div class="close-btn" onclick="closeModal('quizMenuModal')">‚úï</div>
    
    <div style="text-align:center; margin-bottom:20px;">
        <div style="font-size:50px; margin-bottom:5px;">üéÆ</div>
        <h3 style="margin:0;">W√§hle deinen Modus</h3>
    </div>

   <div class="quiz-mode-grid">
        <!-- 1. L√ºckentext -->
        <div class="quiz-mode-card" onclick="selectQuizMode('cloze')" style="border-color: #bd93f9;">
            <div class="qmc-icon">üß©</div>
            <div class="qmc-info">
                <span class="qmc-title">L√ºckentext</span>
                <span class="qmc-desc">Errate das fehlende Tier.</span>
            </div>
        </div>

        <!-- 2. L√ºgendetektor -->
        <div class="quiz-mode-card" onclick="selectQuizMode('lie')" style="border-color: #bd93f9;">
            <div class="qmc-icon">ü§•</div>
            <div class="qmc-info">
                <span class="qmc-title">Wahr oder Quatsch?</span>
                <span class="qmc-desc">Stimmt der Fakt zum Tier?</span>
            </div>
        </div>

        <!-- 3. Mix Mode -->
        <div class="quiz-mode-card" onclick="selectQuizMode('mixed')" style="border-color: #bd93f9;">
            <div class="qmc-icon">üîÄ</div>
            <div class="qmc-info">
                <span class="qmc-title">Alles Gemischt</span>
                <span class="qmc-desc">√úberraschung bei jeder Frage!</span>
            </div>
        </div>

        <!-- 4. Foto R√§tsel -->
        <div class="quiz-mode-card" onclick="window.openPixelQuiz()" style="border-color: #bd93f9;">
            <div class="qmc-icon">üì∏</div>
            <div class="qmc-info">
                <span class="qmc-title">Foto-R√§tsel</span>
                <span class="qmc-desc">Erkennst du deine eigenen Fotos?</span>
            </div>
        </div>
    </div> <!-- Schlie√üt quiz-mode-grid -->

  </div> <!-- ‚ö†Ô∏è DIESES DIV FEHLTE: Schlie√üt modal-content -->
</div>   <!-- ‚ö†Ô∏è DIESES DIV FEHLTE: Schlie√üt quizMenuModal -->


<!-- DECK MANAGER MODAL -->
<div id="deckModal" class="modal">
  <div class="modal-content">
    <div class="sheet-handle"></div>
    <div class="close-btn" onclick="closeModal('deckModal')">‚úï</div>
    
    <h3>üóÇÔ∏è Fakten-Decks</h3>
    <p style="opacity:0.7; font-size:13px; margin-bottom:15px;">
        W√§hle deine Wissens-Quellen oder importiere eigene JSON-Dateien.
    </p>

    <!-- Liste der Decks -->
    <div id="deckListContainer" class="dm-grid">
        <!-- Wird per JS gef√ºllt -->
    </div>

    <!-- Import & Anleitung -->
    <div style="margin-top:15px; padding-top:15px; border-top:1px solid var(--btn);">
        <button onclick="document.getElementById('deckImportInput').click()" style="width:100%; background:var(--accent); color:#fff; padding:15px; border-radius:16px; font-weight:bold;">
            üì• JSON Deck importieren
        </button>
        <input type="file" id="deckImportInput" accept=".json" hidden onchange="safeRun(importFactDeck, this)">
        
        <div style="margin-top:20px; background:var(--bg); padding:15px; border-radius:12px;">
            <p style="margin:0 0 10px 0; font-size:12px; font-weight:bold; opacity:0.7;">ü§ñ Anleitung f√ºr ChatGPT:</p>
            <textarea id="deckPromptOutput" readonly style="width:100%; height:80px; font-family:monospace; font-size:11px; padding:10px; border-radius:8px; resize:none; background:var(--card-solid); color:var(--text);"></textarea>
        </div>
    </div>
  </div>
</div>


<!-- LEVEL UP OVERLAY (Konzept 1: Troph√§e) -->
<div id="levelUpOverlay">
    <!-- Der rotierende Strahlenkranz -->
    <div class="lvl-sunburst"></div>
    
    <!-- Inhalt -->
    <div class="lvl-content">
        <div class="lvl-crown">üëë</div>
        <div class="lvl-up-title">AUFSTIEG!</div>
        
        <!-- Das Tier-Icon des neuen Rangs -->
        <div class="lvl-rank-icon" id="lvlUpIcon">ü¶Å</div>
        
        <div class="lvl-rank-name" id="lvlUpName">L√∂wen-Herz</div>
        <div class="lvl-rank-desc" id="lvlUpDesc">Du hast eine neue Stufe der Wildnis erreicht.</div>
        
        <button class="lvl-claim-btn" onclick="closeLevelOverlay()">Gro√üartig!</button>
    </div>
</div>

<!-- RANGER FUNK MODAL (V3 - PRO FEATURES) -->
<div id="rangerChatModal" class="modal" style="display:none; padding:0; background: #000; z-index: 20000;">
    <div class="modal-content" style="width:100%; height:100dvh; max-width:100%; margin:0; border-radius:0; padding:0; display:flex; flex-direction:column; overflow:hidden; background:#121212; border:none;">
        
        <!-- HEADER (Fix: Buttons sichtbar) -->
        <div style="height:60px; background:#1e1e1e; display:flex; align-items:center; padding:0 15px; border-bottom:1px solid rgba(255,255,255,0.1); flex-shrink:0; position:relative;">
            <div style="font-size:24px; cursor:pointer; margin-right:15px; color: white;" onclick="toggleRangerSidebar()">‚ò∞</div>
            <div style="flex:1">
                <div id="rfTitle" style="font-weight:700; color:white; font-family:'Fredoka', sans-serif;">Ranger Funk</div>
                <div style="font-size:10px; color:#00b894; display:flex; align-items:center; gap:4px;">
                    <div id="rfStatusDot" style="width:6px; height:6px; background:#00b894; border-radius:50%;"></div> 
                    <span id="rfStatusText">Bereit</span>
                </div>
            </div>
            <!-- Invite Button -->
            <div style="font-size:20px; cursor:pointer; padding:10px; color: white; margin-right: 5px;" onclick="shareRangerChannel()">üîó</div>
            <!-- Schlie√üen Button -->
            <div style="font-size:22px; cursor:pointer; padding:10px; color: #ff4757; font-weight: bold;" onclick="closeRangerChat()">‚úï</div>
        </div>

        <div style="display:flex; flex:1; overflow:hidden; position:relative;">
            <!-- SIDEBAR (Fix: Neuer Kanal Button repariert) -->
            <div id="rfSidebar" style="position:absolute; left:0; top:0; bottom:0; width:260px; background:#1e1e1e; z-index:100; transform:translateX(-100%); transition:0.3s cubic-bezier(0.4, 0, 0.2, 1); border-right:1px solid rgba(255,255,255,0.1); display:flex; flex-direction:column;">
                <div style="padding:15px; font-weight:800; color:white; border-bottom:1px solid rgba(255,255,255,0.1)">Frequenzen</div>
                <div id="rfChannelList" style="flex:1; overflow-y:auto; padding:10px;"></div>
                <div style="padding:15px;">
                    <!-- FIX: Ruft jetzt openRfAddModal() auf -->
                    <button onclick="openRfAddModal()" style="width:100%; background:#00b894; color:white; border-radius:12px; padding:12px; font-weight:bold; border:none; box-shadow: 0 4px 10px rgba(0,184,148,0.3);">+ Neuer Kanal</button>
                </div>
            </div>

            <!-- CHAT AREA -->
            <div style="flex:1; display:flex; flex-direction:column; background:#121212;">
                <div id="rfHistory" style="flex:1; overflow-y:auto; padding:15px; display:flex; flex-direction:column; gap:8px;">
                    <div style="text-align:center; margin-top:50px; opacity:0.3; color:white;">
                        <span style="font-size:50px;">üìª</span>
                        <p>Kanal w√§hlen oder Funkspruch absetzen.</p>
                    </div>
                </div>
                
                <!-- Quick Emoji Bar (New Feature) -->
                <div id="rfEmojiBar" style="padding: 5px 10px; background: #1e1e1e; display: flex; gap: 10px; overflow-x: auto; border-top: 1px solid rgba(255,255,255,0.05); scrollbar-width: none;">
                    <span onclick="addRfEmoji('üêæ')" style="cursor:pointer; font-size:20px;">üêæ</span>
                    <span onclick="addRfEmoji('ü¶Å')" style="cursor:pointer; font-size:20px;">ü¶Å</span>
                    <span onclick="addRfEmoji('ü¶â')" style="cursor:pointer; font-size:20px;">ü¶â</span>
                    <span onclick="addRfEmoji('üå≤')" style="cursor:pointer; font-size:20px;">üå≤</span>
                    <span onclick="addRfEmoji('üì∏')" style="cursor:pointer; font-size:20px;">üì∏</span>
                    <span onclick="addRfEmoji('üî•')" style="cursor:pointer; font-size:20px;">üî•</span>
                    <span onclick="addRfEmoji('üìç')" style="cursor:pointer; font-size:20px;">üìç</span>
                    <span onclick="addRfEmoji('üÜò')" style="cursor:pointer; font-size:20px;">üÜò</span>
                </div>

                <div id="rfFilePreview" style="display:none; padding:8px 15px; background:#1e1e1e; font-size:12px; color:#00b894; border-top:1px solid rgba(255,255,255,0.1);">üìé <span id="rfFileName"></span></div>
                
                <div style="padding:10px; background:#1e1e1e; display:flex; align-items:flex-end; gap:8px; padding-bottom:calc(15px + env(safe-area-inset-bottom));">
                    <button class="icon-btn-header" onclick="document.getElementById('rfFileInput').click()" style="background:#333; color:white; width:44px; height:44px; border-radius:12px; border:none;">üìé</button>
                    <input type="file" id="rfFileInput" hidden onchange="handleRfFileSelect(this)">
                    <textarea id="rfInput" placeholder="Senden..." style="flex:1; background:#121212; border:1px solid #333; color:white; border-radius:15px; padding:10px; height:44px; resize:none; font-family:inherit; outline:none;"></textarea>
                    <button onclick="sendRfMessage()" style="background:#00b894; color:white; width:44px; height:44px; border-radius:12px; border:none; font-size:18px; display:flex; align-items:center; justify-content:center;">‚û§</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- RANGER FUNK: ADD CHANNEL SUB-MODAL (Fix: Z-Index & Sichtbarkeit) -->
<div id="rfAddModal" class="modal" style="display:none; z-index: 21000; background: rgba(0,0,0,0.9); align-items:center; justify-content:center;">
    <div class="modal-content" style="background: #1e1e1e; color: white; width: 90%; max-width: 400px; padding: 25px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 20px 50px rgba(0,0,0,0.5);">
        <h3 style="margin-top:0; font-family:'Fredoka', sans-serif; color:#00b894;">Neuer Funk-Kanal</h3>
        
        <div style="margin-bottom:15px;">
            <label style="font-size:11px; color:#b2bec3; font-weight:bold; text-transform:uppercase;">Server</label>
            <select id="rfServerSelect" onchange="toggleRfServerInput()" style="width:100%; padding:12px; background:#121212; color:white; border:1px solid #333; border-radius:12px; margin-top:5px;">
                <option value="ntfy.sh">üåê ntfy.sh (Standard)</option>
                <option value="custom">‚öôÔ∏è Eigener Server...</option>
            </select>
            <input id="rfCustomServerInput" style="display:none; width:100%; padding:12px; background:#121212; color:white; border:1px solid #333; border-radius:12px; margin-top:10px;" placeholder="z.B. ntfy.mein-server.de">
        </div>

        <div style="margin-bottom:15px;">
            <label style="font-size:11px; color:#b2bec3; font-weight:bold; text-transform:uppercase;">Kanal-ID (Frequenz)</label>
            <div style="display:flex; gap:8px; margin-top:5px;">
                <input id="rfNewTopic" style="flex:1; padding:12px; background:#121212; color:white; border:1px solid #333; border-radius:12px; font-family:monospace;" placeholder="Code..." oninput="updateRfLinkPreview()">
                <button onclick="generateRfTopic()" style="padding:10px; background:#333; border:none; border-radius:12px; color:white; width:44px;">üé≤</button>
            </div>
            <p id="rfServerPreview" style="font-size:10px; color:#00b894; margin:5px 0 0 0; opacity:0.7;">Link: https://ntfy.sh/...</p>
        </div>

        <div style="margin-bottom:15px;">
            <label style="font-size:11px; color:#b2bec3; font-weight:bold; text-transform:uppercase;">Anzeigename (Team)</label>
            <input id="rfNewChName" style="width:100%; padding:12px; background:#121212; color:white; border:1px solid #333; border-radius:12px; margin-top:5px;" placeholder="z.B. Ranger Team Nord">
        </div>

        <div style="margin-bottom:25px;">
            <label style="font-size:11px; color:#b2bec3; font-weight:bold; text-transform:uppercase;">Dein Rufzeichen</label>
            <input id="rfNewUser" style="width:100%; padding:12px; background:#121212; color:white; border:1px solid #333; border-radius:12px; margin-top:5px;" placeholder="z.B. Adler_1">
        </div>

        <div style="display:flex; gap:10px;">
            <button onclick="saveRfNewChannel()" style="flex:1; padding:14px; background:#00b894; color:white; border:none; border-radius:15px; font-weight:bold; font-size:15px;">Beitreten</button>
            <button onclick="closeRfAddModal()" style="flex:1; padding:14px; background:#333; color:white; border:none; border-radius:15px; font-size:15px;">Abbrechen</button>
        </div>
    </div>
</div>

<!-- STORAGE EXPLORER MODAL -->
<div id="storageModal" class="modal">
    <div class="modal-content" style="max-width: 600px; height: 80vh; display:flex; flex-direction:column;">
        <div class="close-btn" onclick="closeModal('storageModal')">‚úï</div>
        <h3>üì¶ Datenbank-Explorer</h3>
        <p style="font-size:12px; opacity:0.6; margin-bottom:15px;">Alle physisch in der IndexedDB gespeicherten Elemente.</p>
        
        <div id="storageGrid" style="flex:1; overflow-y:auto; display:grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap:10px; padding:5px;">
            <!-- Hier landen alle Bilder & Decks -->
        </div>
        
        <div style="margin-top:15px; padding-top:15px; border-top:1px solid var(--btn); font-size:11px; display:flex; justify-content:space-between; opacity:0.7;">
            <span id="storageStatsCount">0 Elemente</span>
            <button onclick="cleanupOrphanedImages()" style="background:none; color:var(--err-text); font-weight:bold; font-size:11px;">üßπ Verwaiste Bilder l√∂schen</button>
        </div>
    </div>
</div>

<script>

async function openStorageExplorer() {
    const grid = getEl('storageGrid');
    grid.innerHTML = '<div class="loader-spinner"></div>';
    getEl('storageModal').style.display = 'block';
    
    const db = await dbPromise;
    const tx = db.transaction(STORE_IMGS, 'readonly');
    const store = tx.objectStore(STORE_IMGS);
    
    const allKeys = await new Promise(r => {
        const req = store.getAllKeys();
        req.onsuccess = () => r(req.result);
    });

    getEl('storageStatsCount').innerText = `${allKeys.length} Dateien gespeichert`;
    grid.innerHTML = '';

    for (let key of allKeys) {
        const div = document.createElement('div');
        div.style.cssText = "position:relative; aspect-ratio:1; background:var(--bg); border-radius:10px; overflow:hidden; border:1px solid var(--btn);";
        
        const imgData = await dbGetImg(key);
        
        // Vorschaubild (falls es ein Bild ist)
        if(imgData && imgData.startsWith('data:image')) {
            div.innerHTML = `<img src="${imgData}" style="width:100%; height:100%; object-fit:cover;">`;
        } else {
            div.innerHTML = `<div style="font-size:10px; padding:10px; word-break:break-all;">üìÑ ${key}</div>`;
        }

        // Info-Overlay beim Halten (Key Name anzeigen)
        div.title = key;
        
        // L√∂sch-Button f√ºr jedes einzelne Element (Vorsicht!)
        const delBtn = document.createElement('div');
        delBtn.innerHTML = '‚úï';
        delBtn.style.cssText = "position:absolute; top:2px; right:2px; background:rgba(255,0,0,0.7); color:white; width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:12px; cursor:pointer;";
        delBtn.onclick = async (e) => {
            e.stopPropagation();
            if(confirm("Dieses Element wirklich physisch aus der Datenbank l√∂schen?")) {
                await dbDelImg(key);
                openStorageExplorer(); // Refresh
                updateStorageUI();
            }
        };
        
        div.appendChild(delBtn);
        grid.appendChild(div);
    }
}

// PROFIFEATURE: L√∂scht Bilder, die keine Verkn√ºpfung mehr zu einem Tier oder einer Notiz haben
async function cleanupOrphanedImages() {
    if(!confirm("M√∂chtest du die Datenbank bereinigen? Bilder ohne Verkn√ºpfung zu Tieren oder Notizen werden gel√∂scht.")) return;
    
    const usedIds = new Set();
    animals.forEach(a => { if(a.imageId) usedIds.add(a.imageId); });
    
    // Alle Jahre durchsuchen
    getAvailableYears().forEach(y => {
        const h = getHistory(y);
        Object.values(h).forEach(day => {
            if(day.perAnimal) Object.values(day.perAnimal).forEach(entries => {
                entries.forEach(e => { if(e.noteImageId) usedIds.add(e.noteImageId); });
            });
        });
    });

    const db = await dbPromise;
    const allKeys = await new Promise(r => {
        const req = db.transaction(STORE_IMGS, 'readonly').objectStore(STORE_IMGS).getAllKeys();
        req.onsuccess = () => r(req.result);
    });

    let deleted = 0;
    for (let key of allKeys) {
        if (!usedIds.has(key)) {
            await dbDelImg(key);
            deleted++;
        }
    }
    
    showErrorToast(`${deleted} verwaiste Bilder gel√∂scht!`, true);
    openStorageExplorer();
    updateStorageUI();
}

/* === RANGER FUNK INTEGRATION ENGINE V3 (PRO) === */
let rfChannels = JSON.parse(localStorage.getItem('ranger_channels')) || [];
let rfActiveId = localStorage.getItem('ranger_active_id') || null;
let rfEventSource = null;
let rfCurrentFile = null;

/* === RANGER FUNK DATABASE persistence === */
const RF_DB_NAME = 'RangerFunkDB_V1';
const RF_STORE = 'messages';

const rfDbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open(RF_DB_NAME, 1);
    req.onupgradeneeded = e => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(RF_STORE)) {
            const store = db.createObjectStore(RF_STORE, { keyPath: 'id' });
            store.createIndex('topic', 'topic', { unique: false });
        }
    };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e);
});

async function dbRfSaveMsg(msg) {
    const db = await rfDbPromise;
    const tx = db.transaction(RF_STORE, 'readwrite');
    tx.objectStore(RF_STORE).put(msg);
    return tx.complete;
}

async function dbRfGetMsgs(topic) {
    const db = await rfDbPromise;
    return new Promise(resolve => {
        const tx = db.transaction(RF_STORE, 'readonly');
        const index = tx.objectStore(RF_STORE).index('topic');
        const req = index.getAll(topic);
        req.onsuccess = () => resolve(req.result);
    });
}

function openRangerChat() {
    getEl('rangerChatModal').style.display = 'block';
    // Body Scroll lock
    document.body.style.overflow = 'hidden';
    
    if (rfChannels.length === 0) {
        setTimeout(openRfAddModal, 300);
    } else {
        renderRfChannels();
        if (rfActiveId) switchRfChannel(rfActiveId);
        else switchRfChannel(rfChannels[0].id);
    }
}

function closeRangerChat() {
    getEl('rangerChatModal').style.display = 'none';
    document.body.style.overflow = 'auto';
    if(rfEventSource) rfEventSource.close();
}

function toggleRangerSidebar() {
    const sb = getEl('rfSidebar');
    const isOpen = sb.style.transform === 'translateX(0%)';
    sb.style.transform = isOpen ? 'translateX(-100%)' : 'translateX(0%)';
}

// --- NEW FEATURES ---

function addRfEmoji(emoji) {
    const inp = getEl('rfInput');
    inp.value += emoji;
    inp.focus();
}

function shareRangerChannel() {
    const ch = rfChannels.find(c => c.id === rfActiveId);
    if(!ch) return;
    const shareText = `Komm in meinen Ranger-Kanal! üìª\nKanal: ${ch.topic}\nServer: ${ch.server}\nLink: ${ch.server}/${ch.topic}`;
    
    if (navigator.share) {
        navigator.share({ title: 'Ranger Funk Einladung', text: shareText });
    } else {
        copyToClipboard(ch.topic);
        showErrorToast("Kanal-ID kopiert!", true);
    }
}

function rfHapticFeedback(type) {
    if (!navigator.vibrate) return;
    if (type === 'send') navigator.vibrate(15);
    if (type === 'receive') navigator.vibrate([20, 50, 20]);
}

// --- KANAL LOGIK ---

function openRfAddModal() {
    getEl('rfAddModal').style.display = 'flex';
    generateRfTopic();
}

function closeRfAddModal() {
    getEl('rfAddModal').style.display = 'none';
}

function generateRfTopic() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const randomBytes = new Uint8Array(40);
    crypto.getRandomValues(randomBytes);
    const randomPart = Array.from(randomBytes, byte => chars[byte % chars.length]).join('');
    getEl('rfNewTopic').value = 'ranger_' + randomPart;
    updateRfLinkPreview();
}   


function toggleRfServerInput() {
    const sel = getEl('rfServerSelect');
    getEl('rfCustomServerInput').style.display = (sel.value === 'custom') ? 'block' : 'none';
    updateRfLinkPreview();
}

function updateRfLinkPreview() {
    const server = getEl('rfServerSelect').value === 'custom' ? getEl('rfCustomServerInput').value : 'ntfy.sh';
    const topic = getEl('rfNewTopic').value;
    getEl('rfServerPreview').innerText = `Link: https://${server || '...'}/${topic || '...'}`;
}

function saveRfNewChannel() {
    const name = getEl('rfNewChName').value.trim();
    const topic = getEl('rfNewTopic').value.trim();
    const user = getEl('rfNewUser').value.trim();
    const server = getEl('rfServerSelect').value === 'custom' ? getEl('rfCustomServerInput').value.trim() : 'ntfy.sh';

    if (!name || !topic || !user || !server) return alert("Bitte alle Felder ausf√ºllen!");

    const newCh = { id: Date.now().toString(), name, topic, user, server };
    rfChannels.push(newCh);
    localStorage.setItem('ranger_channels', JSON.stringify(rfChannels));
    
    renderRfChannels();
    switchRfChannel(newCh.id);
    closeRfAddModal();
    // Sidebar schlie√üen falls offen
    getEl('rfSidebar').style.transform = 'translateX(-100%)';
}

/* === UPDATE: RANGER CHAT SWITCH (Name statt ID + Edit Button) === */
/* === UPDATE: RANGER CHAT SWITCH (Safe Mode) === */
async function switchRfChannel(id) {
    rfActiveId = id;
    localStorage.setItem('ranger_active_id', id);
    const ch = rfChannels.find(c => c.id === id);
    if (!ch) return;

    // Header manipulieren (mit Sicherheits-Checks)
    const headerTitle = document.getElementById('rfTitle');
    const headerStatus = document.getElementById('rfStatusText');
    
    if (headerTitle) {
        const headerContainer = headerTitle.parentNode; 
        
        // 1. Text setzen
        headerTitle.innerText = ch.name; 
        
        // 2. Klick-Zone einrichten
        if(headerContainer) {
            headerContainer.className = 'rf-header-clickable';
            headerContainer.onclick = () => {
                editSyncChannel(id);
                const modal = document.getElementById('syncAddModal');
                if(modal) modal.style.zIndex = "22000";
            };
        }
    }

    if(headerStatus) headerStatus.innerText = "Bereit";

    // --- LISTE LADEN (HIER WAR DER FEHLER) ---
    const list = document.getElementById('rfHistory');
    
    // NUR WEITERMACHEN, WENN DIE LISTE AUCH DA IST:
    if (list) {
        list.innerHTML = ''; 
        
        const history = await dbRfGetMsgs(ch.topic);
        history.sort((a, b) => a.time - b.time);
        
        if (history.length > 0) {
            history.forEach(msg => renderRfMessage(msg, ch));
        } else {
            list.innerHTML = '<div style="text-align:center; padding:50px; opacity:0.5; color:white;">Funkstille auf dieser Frequenz...</div>';
        }
    }
    
    renderRfChannels();
    startRfStream(ch);
}


/* === RENDER SIDEBAR (Name + Context Menu) === */
function renderRfChannels() {
    const list = document.getElementById('rfChannelList');
    if(!list) return;
    list.innerHTML = '';
    
    rfChannels.forEach(ch => {
        const isActive = (ch.id === rfActiveId);
        const div = document.createElement('div');
        
        // Styling Klasse nutzen
        div.className = 'rf-channel-item';
        
        // Active State Styling inline (f√ºr dynamische Farben)
        if(isActive) {
            div.style.background = 'rgba(0,184,148,0.15)';
            div.style.borderColor = '#00b894';
        } else {
            div.style.background = 'rgba(255,255,255,0.03)';
            div.style.borderColor = 'rgba(255,255,255,0.05)';
        }

        // HTML Aufbau: Name oben, ID unten klein, Men√º rechts
        div.innerHTML = `
            <div class="rf-channel-info">
                <div class="rf-channel-name">${ch.name}</div>
                <div class="rf-channel-topic">#${ch.topic}</div>
            </div>
            
            <!-- 3 Punkte Men√º -->
            <div class="rf-channel-menu-btn" onclick="openRfSidebarMenu('${ch.id}', event)">
                ‚ãÆ
            </div>
        `;
        
        // Klick auf das Item wechselt den Kanal
        div.onclick = (e) => { 
            // Verhindern, dass Klick auf Men√º den Kanal wechselt (Bubbling)
            if(!e.target.classList.contains('rf-channel-menu-btn') && !e.target.parentElement.classList.contains('rf-channel-menu-btn')) {
                switchRfChannel(ch.id); 
                toggleRangerSidebar(); 
            }
        };
        
        list.appendChild(div);
    });
}

/* === RANGER SIDEBAR CONTEXT MENU === */

/* === RANGER SIDEBAR CONTEXT MENU (Fixed) === */

// Globale Variable f√ºr den Edit-Modus (bitte oben zu den anderen "let" hinzuf√ºgen oder hier lassen)
let editingRfId = null;

/* === 1. MEN√ú √ñFFNEN (Korrigierte Action) === */
function openRfSidebarMenu(id, event) {
    if(event && typeof event.stopPropagation === 'function') event.stopPropagation();
    
    const items = [
        { 
            label: 'Bearbeiten', 
            icon: '‚úèÔ∏è', 
            // Ruft jetzt die richtige Funktion auf!
            action: `openRfEditModal('${id}')` 
        },
        { 
            label: 'Kanal l√∂schen', 
            icon: 'üóëÔ∏è', 
            action: `deleteRfChannel('${id}', null)`, 
            danger: true 
        }
    ];

    let x = event.clientX || 0;
    let y = event.clientY || 0;
    openContextMenu(x + 10, y, items);
}

/* === 2. MODAL √ñFFNEN & F√úLLEN (Bearbeiten) === */
function openRfEditModal(id) {
    const ch = rfChannels.find(c => c.id === id);
    if(!ch) return;

    // Modus setzen
    editingRfId = id;

    // Inputs mit den alten Werten f√ºllen
    document.getElementById('rfNewChName').value = ch.name;
    document.getElementById('rfNewTopic').value = ch.topic;
    document.getElementById('rfNewUser').value = ch.user;
    
    // Server-Auswahl logik
    const sel = document.getElementById('rfServerSelect');
    const customInp = document.getElementById('rfCustomServerInput');
    
    if (ch.server === 'ntfy.sh') {
        sel.value = 'ntfy.sh';
        customInp.style.display = 'none';
    } else {
        sel.value = 'custom';
        customInp.style.display = 'block';
        customInp.value = ch.server;
    }

    // Modal anzeigen (√úber dem Chat!)
    const modal = document.getElementById('rfAddModal');
    modal.querySelector('h3').innerText = "Kanal bearbeiten"; // Titel √§ndern
    modal.style.zIndex = "22000";
    modal.style.display = 'flex';
}

/* === 3. MODAL √ñFFNEN (Neu erstellen - Reset) === */
// Bitte sicherstellen, dass dein "+ Neuer Kanal" Button diese Funktion aufruft!
function openRfAddModal() {
    editingRfId = null; // Reset: Wir erstellen neu
    
    document.getElementById('rfNewChName').value = '';
    document.getElementById('rfNewTopic').value = '';
    document.getElementById('rfNewUser').value = '';
    
    // Standard Server Reset
    document.getElementById('rfServerSelect').value = 'ntfy.sh';
    document.getElementById('rfCustomServerInput').style.display = 'none';
    
    generateRfTopic(); // Neuen Code generieren
    
    const modal = document.getElementById('rfAddModal');
    modal.querySelector('h3').innerText = "Neuer Funk-Kanal";
    modal.style.zIndex = "22000";
    modal.style.display = 'flex';
}

/* === 4. SPEICHERN (Ersetzt saveRfNewChannel komplett) === */
function saveRfNewChannel() {
    const name = document.getElementById('rfNewChName').value.trim();
    const topic = document.getElementById('rfNewTopic').value.trim();
    const user = document.getElementById('rfNewUser').value.trim();
    const serverSelect = document.getElementById('rfServerSelect').value;
    const serverCustom = document.getElementById('rfCustomServerInput').value.trim();
    const server = serverSelect === 'custom' ? serverCustom : 'ntfy.sh';

    if (!name || !topic || !user || !server) return alert("Bitte alle Felder ausf√ºllen!");

    if (editingRfId) {
        // === UPDATE MODUS ===
        const idx = rfChannels.findIndex(c => c.id === editingRfId);
        if (idx !== -1) {
            rfChannels[idx].name = name;
            rfChannels[idx].topic = topic;
            rfChannels[idx].user = user;
            rfChannels[idx].server = server;
            
            // Falls wir den aktiven Kanal bearbeitet haben, Header updaten
            if (rfActiveId === editingRfId) {
                document.getElementById('rfTitle').innerText = name;
                // Live Stream neu starten, falls Topic sich ge√§ndert hat
                startRfStream(rfChannels[idx]); 
            }
        }
        editingRfId = null; // Reset
    } else {
        // === NEU ERSTELLEN MODUS ===
        const newCh = { id: Date.now().toString(), name, topic, user, server };
        rfChannels.push(newCh);
        switchRfChannel(newCh.id); // Direkt hinwechseln
    }

    localStorage.setItem('ranger_channels', JSON.stringify(rfChannels));
    renderRfChannels();
    
    // Modal schlie√üen
    document.getElementById('rfAddModal').style.display = 'none';
    
    // Sidebar schlie√üen (optional, wirkt sauberer)
    toggleRangerSidebar();
}

/* === EDIT HELPER (Muss global verf√ºgbar sein) === */
function editRfChannelFromChat(id) {
    // 1. Die normale Edit-Funktion aufrufen (f√ºllt die Inputs)
    if(typeof editSyncChannel === 'function') {
        editSyncChannel(id);
    } else {
        console.error("Funktion editSyncChannel nicht gefunden!");
        return;
    }
    
    // 2. Das Modal √ºber den Chat legen (Z-Index Fix)
    const modal = document.getElementById('syncAddModal');
    if(modal) {
        modal.style.zIndex = "22000"; // Muss h√∂her sein als Chat (20000)
        modal.style.display = "flex"; // Sicherstellen, dass es sichtbar ist
    }
}

// Wrapper um das Edit-Modal √ºber den Chat zu legen
function editRfChannelFromChat(id) {
    // 1. Standard Edit Funktion aufrufen (f√ºllt die Werte)
    editSyncChannel(id);
    
    // 2. Modal Z-Index erh√∂hen (Chat ist 20000, AddModal muss h√∂her sein)
    const modal = document.getElementById('syncAddModal');
    if(modal) {
        modal.style.zIndex = "22000";
    }
}

// Update der delete Funktion, damit sie auch ohne Event-Objekt funktioniert
// (Falls du die alte noch hast, ersetze sie hiermit, sonst einfach hinzuf√ºgen)
function deleteRfChannel(id, e) {
    if(e) e.stopPropagation();
    
    const ch = rfChannels.find(c => c.id === id);
    // Sicherheitsabfrage mit Name statt ID
    if (!confirm(`Kanal "${ch ? ch.name : id}" wirklich l√∂schen?`)) return;
    
    rfChannels = rfChannels.filter(c => c.id !== id);
    localStorage.setItem('ranger_channels', JSON.stringify(rfChannels));
    
    if (rfActiveId === id) {
        rfActiveId = null;
        localStorage.removeItem('ranger_active_id'); // Auch aus Storage l√∂schen
        if(rfEventSource) rfEventSource.close();
        
        const historyList = document.getElementById('rfHistory');
        const title = document.getElementById('rfTitle');
        if(historyList) historyList.innerHTML = '<div style="text-align:center; padding:50px; opacity:0.3; color:white;">Kein Kanal gew√§hlt.</div>';
        if(title) title.innerText = 'Funkstille';
    }
    
    renderRfChannels();
}


/* === SAFE DELETE FUNCTION === */
function deleteRfChannel(id, e) {
    // FIX: Nur stoppen, wenn e wirklich ein Event ist
    if(e && typeof e.stopPropagation === 'function') {
        e.stopPropagation();
    }
    
    const ch = rfChannels.find(c => c.id === id);
    // Sicherheitsabfrage
    if (!confirm(`Kanal "${ch ? ch.name : id}" wirklich l√∂schen?`)) return;
    
    rfChannels = rfChannels.filter(c => c.id !== id);
    localStorage.setItem('ranger_channels', JSON.stringify(rfChannels));
    
    // Wenn der aktive Kanal gel√∂scht wurde -> Reset
    if (rfActiveId === id) {
        rfActiveId = null;
        localStorage.removeItem('ranger_active_id');
        if(typeof rfEventSource !== 'undefined' && rfEventSource) rfEventSource.close();
        
        const historyList = document.getElementById('rfHistory');
        const title = document.getElementById('rfTitle');
        if(historyList) historyList.innerHTML = '<div style="text-align:center; padding:50px; opacity:0.3; color:white;">Kein Kanal gew√§hlt.</div>';
        if(title) title.innerText = 'Funkstille';
    }
    
    renderRfChannels();
}

// --- MESSAGING ---

function startRfStream(ch) {
    if (rfEventSource) rfEventSource.close();
    const server = ch.server || 'ntfy.sh';
    rfEventSource = new EventSource(`https://${server}/${ch.topic}/sse`);
    
    rfEventSource.onopen = () => { getEl('rfStatusText').innerText = "Online"; getEl('rfStatusDot').style.background = "#00b894"; };
    rfEventSource.onerror = () => { getEl('rfStatusText').innerText = "Rauschen..."; getEl('rfStatusDot').style.background = "#ff4757"; };

   rfEventSource.onmessage = async (e) => {
        const data = JSON.parse(e.data);
        if (data.event === 'message') {
            const isMe = data.title && data.title.includes(ch.user);
            
            // Objekt f√ºr die Datenbank vorbereiten
            const msgObj = {
                id: data.id,
                time: data.time * 1000,
                user: data.title || 'Ranger',
                text: data.message || '',
                topic: ch.topic, // Wichtig f√ºr den Index!
                attachment: data.attachment
            };

            // 1. In Datenbank speichern (Persistenz!)
            await dbRfSaveMsg(msgObj);
            
            if (!isMe) rfHapticFeedback('receive');
            
            // 2. Im UI anzeigen
            renderRfMessage(msgObj, ch);
        }
    };
}

function renderRfMessage(msg, ch) {
    const list = getEl('rfHistory');
    
    // 1. Loader entfernen & Doppelte Nachrichten verhindern
    if (list.innerText.includes('Empfange')) list.innerHTML = '';
    if (document.getElementById('rfm_' + msg.id)) return;

    // 2. Wer sendet?
    const isMe = msg.user.includes(ch.user);
    const div = document.createElement('div');
    div.id = 'rfm_' + msg.id;
    div.style.cssText = `max-width:85%; margin-bottom:12px; align-self:${isMe ? 'flex-end' : 'flex-start'}`;
    
    // 3. SICHERHEIT: Text escapen (XSS Schutz)
    let safeText = rfEscape(msg.text); 

    // 4. Links anklickbar machen (nach dem Escapen!)
    let content = safeText.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color:#00b894; text-decoration:underline;">Link</a>');
    
    // 5. Anh√§nge verarbeiten (Bilder oder Dateien)
    if (msg.attachment) {
        if (msg.attachment.type && msg.attachment.type.startsWith('image/')) {
            content = `<img src="${msg.attachment.url}" style="width:100%; border-radius:12px; margin-bottom:5px; border: 1px solid rgba(255,255,255,0.1);" onclick="openImageLightbox('${msg.attachment.url}')"><br>` + content;
        } else {
            content = `<div style="background:rgba(0,0,0,0.2); padding:8px; border-radius:8px; font-size:12px; margin-bottom:5px;">üìé <a href="${msg.attachment.url}" target="_blank" style="color:#00b894; text-decoration:none;">Datei √∂ffnen</a></div>` + content;
        }
    }

    // 6. Das finale HTML zusammenbauen
    div.innerHTML = `
        ${!isMe ? `<div style="font-size:10px; color:#00b894; margin-bottom:4px; font-weight:bold; margin-left:5px;">${rfEscape(msg.user).replace('üí¨ ','')}</div>` : ''}
        <div style="background:${isMe ? '#00b894' : '#2d3436'}; color:white; padding:12px 16px; border-radius:20px; border-bottom-${isMe?'right':'left'}-radius:4px; font-size:14px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); line-height:1.4;">
            ${content}
        </div>
        <div style="font-size:9px; opacity:0.3; color:white; margin-top:5px; text-align:${isMe?'right':'left'}; padding:0 8px;">
            ${new Date(msg.time).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
        </div>
    `;

    list.appendChild(div);
    list.scrollTop = list.scrollHeight;
}

async function sendRfMessage() {
    const ch = rfChannels.find(c => c.id === rfActiveId);
    const inp = getEl('rfInput');
    if (!ch || (!inp.value.trim() && !rfCurrentFile)) return;

    rfHapticFeedback('send');
    const safeTitle = encodeURIComponent(`üí¨ ${ch.user}`);
    const server = ch.server || 'ntfy.sh';
    let url = `https://${server}/${ch.topic}?title=${safeTitle}`;
    
    try {
        await fetch(url, { method: 'POST', body: rfCurrentFile || inp.value });
        inp.value = ''; rfCurrentFile = null;
        getEl('rfFilePreview').style.display = 'none';
        inp.style.height = '44px';
    } catch(e) { showErrorToast("Funkst√∂rung: Senden fehlgeschlagen."); }
}

function handleRfFileSelect(input) {
    if (input.files[0]) {
        rfCurrentFile = input.files[0];
        getEl('rfFilePreview').style.display = 'block';
        getEl('rfFileName').innerText = rfCurrentFile.name;
    }
}
/* === END RANGER FUNK === */


/** 
 * === TIER TICKER CORE ===
 * Fixes: Disabled Swipe for Details View
 */

/* === QUIZ ENGINE V2 (MULTI-MODE) === */

let currentQuizAnswer = null; // Speichert die L√∂sung (String f√ºr Cloze, Boolean f√ºr Lie)
let isQuizLocked = false;     // Verhindert Mehrfach-Klicks
let activeQuizMode = 'mixed'; // 'cloze', 'lie', 'mixed'

// 1. Start: √ñffnet das Men√º
function startQuiz() {
    closeContextMenu(); 
    document.getElementById('quizMenuModal').style.display = 'block';
}

// 2. Modus gew√§hlt -> Start Game
function selectQuizMode(mode) {
    activeQuizMode = mode;
    closeModal('quizMenuModal');
    document.getElementById('quizModal').style.display = 'block';
    updateQuizHeader();
    nextQuizQuestion();
}

function updateQuizHeader() {
    document.getElementById('quizScoreHeader').innerText = `Quiz XP: ${quizXP}`;
}

// 3. Frage generieren (Router)
function nextQuizQuestion() {
    // UI Reset
    isQuizLocked = false;
    document.getElementById('quizNextBtn').style.display = 'none';
    const qBox = document.getElementById('quizQuestionBox');
    const oBox = document.getElementById('quizOptionsBox');
    
    // Grid Reset (falls vorher Lie-Mode war)
    oBox.className = 'quiz-options-grid'; 
    oBox.innerHTML = '';
    qBox.innerHTML = '<div class="loader-spinner" style="width:20px; height:20px; border-width:2px;"></div>';

    // Modus entscheiden (bei Mixed wird gew√ºrfelt)
    let currentRoundMode = activeQuizMode;
    if (activeQuizMode === 'mixed') {
        currentRoundMode = Math.random() < 0.5 ? 'cloze' : 'lie';
    }

    // Passende Funktion aufrufen
    if (currentRoundMode === 'lie') {
        renderLieDetector(qBox, oBox);
    } else {
        renderClozeTest(qBox, oBox);
    }
}

// --- MODUS A: L√úCKENTEXT (CLOZE) ---
function renderClozeTest(qBox, oBox) {
    const candidate = findValidFact();
    if (!candidate) { qBox.innerText = "Fehler: Keine Fragen mehr."; return; }

    currentQuizAnswer = candidate.animal; // L√∂sung ist der Name

    // Text zensieren
    const regex = new RegExp(candidate.animal, "gi");
    const questionText = candidate.text.replace(regex, "___________");
    qBox.innerHTML = `<div style="font-size:12px;opacity:0.6;margin-bottom:5px;text-transform:uppercase;">üß© Welches Tier passt?</div>"${questionText}"`;

    // Falsche Antworten
    const wrongs = new Set();
    while (wrongs.size < 2) {
        const w = allGlobalFacts[Math.floor(Math.random() * allGlobalFacts.length)].animal;
        if (w !== candidate.animal) wrongs.add(w);
    }

    const options = [candidate.animal, ...Array.from(wrongs)].sort(() => 0.5 - Math.random());

    options.forEach(opt => {
        const btn = document.createElement('div');
        btn.className = 'quiz-btn';
        btn.innerText = opt;
        // Wir √ºbergeben 'cloze' als Typ
        btn.onclick = () => solveQuiz(btn, opt, 'cloze');
        oBox.appendChild(btn);
    });
}

// --- MODUS B: L√úGENDETEKTOR (TRUE/FALSE) ---
function renderLieDetector(qBox, oBox) {
    const candidate = findValidFact();
    if (!candidate) { qBox.innerText = "Fehler: Keine Fragen mehr."; return; }

    // M√ºnzwurf: Zeigen wir das richtige oder ein falsches Tier?
    const isTrueStatement = Math.random() < 0.5;
    currentQuizAnswer = isTrueStatement; // L√∂sung ist Boolean

    let displayAnimal = candidate.animal;
    let displayIcon = candidate.icon;

    if (!isTrueStatement) {
        // Wir brauchen ein FALSCHES Tier
        let fake = null;
        while (!fake || fake.animal === candidate.animal) {
            fake = allGlobalFacts[Math.floor(Math.random() * allGlobalFacts.length)];
        }
        displayAnimal = fake.animal;
        displayIcon = fake.icon;
    }

    // Text zensieren (damit der Name im Text nicht verr√§t, dass es falsch ist!)
    // Wir ersetzen den ECHTEN Namen im Text durch "Dieses Tier"
    const regex = new RegExp(candidate.animal, "gi");
    const cleanText = candidate.text.replace(regex, "dieses Tier");

    qBox.innerHTML = `
        <div style="font-size:12px;opacity:0.6;margin-bottom:10px;text-transform:uppercase;">ü§• Wahr oder Quatsch?</div>
        <div style="font-size:40px;margin-bottom:5px;">${displayIcon}</div>
        <div style="font-weight:900;margin-bottom:10px;color:var(--accent);">${displayAnimal}</div>
        "${cleanText}"
    `;

    // Buttons (Layout √§ndern)
    oBox.classList.add('lie-mode');

    // Wahr Button
    const btnTrue = document.createElement('div');
    btnTrue.className = 'quiz-btn';
    btnTrue.innerHTML = '<span style="font-size:24px">‚úÖ</span> WAHR';
    btnTrue.onclick = () => solveQuiz(btnTrue, true, 'lie');
    oBox.appendChild(btnTrue);

    // Falsch Button
    const btnFalse = document.createElement('div');
    btnFalse.className = 'quiz-btn';
    btnFalse.innerHTML = '<span style="font-size:24px">‚ùå</span> QUATSCH';
    btnFalse.onclick = () => solveQuiz(btnFalse, false, 'lie');
    oBox.appendChild(btnFalse);
}

// Helper: Findet einen Fakt, der den Tiernamen enth√§lt
function findValidFact() {
    let candidate = null;
    let attempts = 0;
    while (!candidate && attempts < 50) {
        const rand = allGlobalFacts[Math.floor(Math.random() * allGlobalFacts.length)];
        if (rand.text.toLowerCase().includes(rand.animal.toLowerCase())) {
            candidate = rand;
        }
        attempts++;
    }
    return candidate;
}

// 4. Aufl√∂sung
function solveQuiz(btnElement, userChoice, mode) {
    if (isQuizLocked) return;
    isQuizLocked = true;

    // Check Logic
    const isCorrect = (userChoice === currentQuizAnswer);
    
    if (isCorrect) {
        // RICHTIG
        btnElement.classList.add('correct');
        playSound('pop');
        
        // XP
        const reward = 40;
        quizXP += reward;
        localStorage.setItem('quizXP', quizXP);
        updateQuizHeader();

        
        // Feedback Text je nach Modus
        const msg = mode === 'lie' ? (userChoice ? "Stimmt genau!" : "Gut erkannt, das war gelogen!") : "Richtig!";
        showErrorToast(`${msg} +${reward} XP`, true);
        
        if(typeof spawnParticle === 'function') {
            const rect = btnElement.getBoundingClientRect();
            spawnParticle(rect.left + rect.width/2, rect.top, "üéâ");
        }
checkLevelProgress(); 
    } else {
        // FALSCH
        btnElement.classList.add('wrong');
        if(navigator.vibrate) navigator.vibrate(200);
        
        // L√∂sung anzeigen
        if (mode === 'cloze') {
            // Bei Cloze: Richtigen Button gr√ºn machen
            document.querySelectorAll('.quiz-btn').forEach(b => {
                if (b.innerText === currentQuizAnswer) {
                    b.classList.add('correct');
                    b.style.opacity = '1';
                }
            });
        } else {
            // Bei Lie: Einfach Text anzeigen
            showErrorToast(currentQuizAnswer ? "Das war eigentlich wahr!" : "Das war eigentlich Quatsch!");
        }
    }

    document.getElementById('quizNextBtn').style.display = 'block';
}
/* === END QUIZ ENGINE === */


// === 1. SWIPE GESTURE HANDLER (FIXED VERSION) ===
function initSwipeGestures() {
    let startY = 0;
    let currentModalContent = null;

    document.addEventListener('touchstart', (e) => {
        const handle = e.target.closest('.sheet-handle');
        const content = e.target.closest('.modal-content');
        
        if (!content) return;

        // === HIER IST DER FIX ===
        // Diese Modals d√ºrfen NICHT gewischt werden (nur Scrollen erlaubt):
        const lockedModals = ['detailModal', 'libraryModal', 'flavorModal', 'deckModal', 'noteViewModal', 'storageModal'];
        
        // Wenn wir in einem dieser Modals sind -> Abbrechen!
        if (lockedModals.includes(content.parentElement.id)) return;
        // ========================

        // F√ºr alle anderen Modals (z.B. Quick Note): Swipe erlaubt
        if (handle || content.scrollTop === 0) {
            currentModalContent = content;
            startY = e.touches[0].clientY;
            currentModalContent.style.transition = 'none';
        }
    }, {passive: true});

    document.addEventListener('touchmove', (e) => {
        if (!currentModalContent) return;
        const currentY = e.touches[0].clientY;
        const delta = currentY - startY;

        if (delta > 0) {
            e.preventDefault(); 
            currentModalContent.style.transform = `translateY(${delta}px)`;
        }
    }, {passive: false});

    document.addEventListener('touchend', (e) => {
        if (!currentModalContent) return;
        const delta = e.changedTouches[0].clientY - startY;

        currentModalContent.style.transition = 'transform 0.3s ease-out';

        if (delta > 120) { 
            const modalId = currentModalContent.parentElement.id;
            closeModal(modalId);
            setTimeout(() => { 
                currentModalContent.style.transform = ''; 
                currentModalContent.style.transition = '';
            }, 300);
        } else {
            currentModalContent.style.transform = '';
        }
        currentModalContent = null;
    });
}

// === 2. INDEXED DB WRAPPER (V2: Images & Decks) ===
const DB_NAME = 'TierAppDB';
const STORE_IMGS = 'images';
const STORE_DECKS = 'decks'; // NEU

const dbPromise = new Promise((resolve, reject) => {
    // WICHTIG: Version auf 2 erh√∂ht!
    const req = indexedDB.open(DB_NAME, 3); 
    
    req.onupgradeneeded = e => { 
        const db = e.target.result;
        // Store f√ºr Bilder (falls noch nicht da)
        if (!db.objectStoreNames.contains(STORE_IMGS)) {
            db.createObjectStore(STORE_IMGS);
        }
        // NEU: Store f√ºr Decks
        if (!db.objectStoreNames.contains(STORE_DECKS)) {
            db.createObjectStore(STORE_DECKS, { keyPath: "id" });
        }
    };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e);
});


// Neue DB Helper f√ºr Decks
async function dbSaveDeck(deckObj) {
    const db = await dbPromise;
    const tx = db.transaction(STORE_DECKS, 'readwrite');
    tx.objectStore(STORE_DECKS).put(deckObj);
    return tx.complete;
}
async function dbGetDecks() {
    const db = await dbPromise;
    return new Promise(resolve => {
        const tx = db.transaction(STORE_DECKS, 'readonly');
        const req = tx.objectStore(STORE_DECKS).getAll();
        req.onsuccess = () => resolve(req.result);
    });
}
async function dbDelDeck(id) {
    const db = await dbPromise;
    const tx = db.transaction(STORE_DECKS, 'readwrite');
    tx.objectStore(STORE_DECKS).delete(id);
    return tx.complete;
}
// ... (Die alten dbSaveImg Funktionen bleiben hier drunter erhalten!) ...


async function dbSaveImg(id, dataUrl) {
    const db = await dbPromise;
    return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_IMGS, 'readwrite');
        tx.objectStore(STORE_IMGS).put(dataUrl, id);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject();
    });
}
async function dbGetImg(id) {
    const db = await dbPromise;
    return new Promise(resolve => {
        const tx = db.transaction(STORE_IMGS, 'readonly');
        const req = tx.objectStore(STORE_IMGS).get(id);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(null);
    });
}
async function dbDelImg(id) {
    const db = await dbPromise;
    const tx = db.transaction(STORE_IMGS, 'readwrite');
    tx.objectStore(STORE_IMGS).delete(id);
}
async function dbCount() {
    const db = await dbPromise;
    return new Promise(resolve => {
        const req = db.transaction(STORE_IMGS, 'readonly').objectStore(STORE_IMGS).count();
        req.onsuccess = () => resolve(req.result);
    });
}


// === 3. GLOBALS & CONFIG ===
const currentSystemYear = new Date().getFullYear();
// === ZEIT FILTER STATE ===
let timeFilter = JSON.parse(localStorage.getItem('timeFilter')) || { start: '', end: '' };

// Helper: Pr√ºft ob ein Datum im Filter liegt
function isDateInFilter(dateStr) {
    if (!timeFilter.start && !timeFilter.end) return true; // Filter aus
    
    // String Vergleich reicht bei YYYY-MM-DD format (ISO)
    if (timeFilter.start && dateStr < timeFilter.start) return false;
    if (timeFilter.end && dateStr > timeFilter.end) return false;
    
    return true;
}

// Helper: Formatiert Datum f√ºr Chip (DD.MM.YY)
function fmtDateShort(iso) {
    if(!iso) return "";
    const parts = iso.split('-');
    return `${parts[2]}.${parts[1]}.${parts[0].slice(2)}`;
}
let animals = []; 
let locations = [];
let locCoords = {};
let quizXP = parseInt(localStorage.getItem('quizXP')) || 0;
let savedFacts = JSON.parse(localStorage.getItem('savedFacts')) || []; 
let currentNoteImg = null; // Speichert das Bild tempor√§r f√ºr Notizen
let dark = false;
let trashBin = [];
let currentTempImg = null;
let currentFilter = 'ALL';
let storyPreviewData = null; // Speichert Daten f√ºr den Mini-Ring
// L√§dt den Status aus dem Speicher. Wenn nichts gespeichert ist, ist es false (eingeklappt).
let listExpanded = localStorage.getItem('listExpandedState') === 'true';
let sortMode = 'fav'; 
let appMode = 'animals'; // 'animals', 'notes', 'gallery'
let editingSyncId = null; 
let viewMode = 'list';
let libSearchMode = 'animals'; // 'animals' | 'facts'
let searchMode = 'animals'; // 'animals' oder 'notes'
let isMuted = localStorage.getItem('muted') !== 'false';
let notifyConfig = JSON.parse(localStorage.getItem('notifyConfig')) || { enabled: false, days: 7 };
let undoStack = [];
let undoTimeout = null;
let mapInstance = null;
let tempImportData = null;
let detailAnimalIdx = null;

// KOMPAKT MODUS STATUS LADEN
let isCompact = localStorage.getItem('compactMode') === 'true';
if(isCompact) document.body.classList.add('compact-view');

function toggleCompactMode() {
    isCompact = !isCompact;
    localStorage.setItem('compactMode', isCompact);
    document.body.classList.toggle('compact-view', isCompact);
    render(); // Liste neu zeichnen, damit Abst√§nde passen
}

// LEVEL CONFIG
/* === NEUE LEVEL DEFINITION (4 WELTEN) === */
/* === NEUE LEVEL DEFINITION (5 TIER-ZONEN) === */
const levels = [
    // ZONE 1: GARTEN & WIESE (Der Anfang)
    { xp: 0, name: "Ameisen-Z√§hler" }, 
    { xp: 100, name: "Schmetterlings-Freund" }, 
    { xp: 300, name: "Spatzen-Beobachter" },
    { xp: 600, name: "Igel-Besch√ºtzer" }, 

    // ZONE 2: WALD & HEIMAT (Die Wildnis)
    { xp: 1000, name: "Eichh√∂rnchen-Sp√§her" },
    { xp: 1500, name: "Fuchs-F√§hrte" }, 
    { xp: 2200, name: "Eulen-Auge" }, 
    { xp: 3000, name: "Hirsch-W√§chter" }, 

    // ZONE 3: WASSER & MEER (Die Tiefe)
    { xp: 4000, name: "Teich-Frosch" }, 
    { xp: 5200, name: "Biber-Baumeister" }, 
    { xp: 6600, name: "Delfin-Schwimmer" }, 
    { xp: 8200, name: "Wal-Wanderer" }, 

    // ZONE 4: SAVANNE & DSCHUNGEL (Die Exoten)
    { xp: 10000, name: "Affen-Kletterer" }, 
    { xp: 12500, name: "Elefanten-Ged√§chtnis" }, 
    { xp: 15500, name: "Leoparden-Schleicher" }, 
    { xp: 19000, name: "L√∂wen-Herz" }, 

    // ZONE 5: APEX LEGENDEN (Die Spitze der Nahrungskette)
    { xp: 23000, name: "Adler-K√∂nig" }, 
    { xp: 28000, name: "B√§ren-Kraft" }, 
    { xp: 35000, name: "Wolfsrudel-Alpha" }, 
    { xp: 50000, name: "Meister der Wildnis" }
];

// Helper
const getEl = id => document.getElementById(id);
const todayStr = () => new Date().toISOString().slice(0,10);
const nowTimeStr = () => new Date().toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'});
function safeRun(fn, ...args){ try{fn(...args)}catch(e){console.error(e); showErrorToast(e.message)}}
function showErrorToast(msg, isInfo=false){
    const t=getEl('errorToast'); t.innerText=(isInfo?"‚ÑπÔ∏è ":"‚ö†Ô∏è ")+msg; 
    t.style.background=isInfo?"var(--accent)":"var(--err-bg)"; t.style.color=isInfo?"#fff":"var(--err-text)";
    t.style.display='block'; setTimeout(()=>t.style.display='none',4000);
}


// HELPER: Debounce f√ºr die Suche
let debounceTimer;
function debouncedRender() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
        render();
    }, 250);
}

function toggleMute(){ isMuted=!isMuted; localStorage.setItem('muted',isMuted); getEl('muteBtn').innerText=isMuted?'üîá':'üîä'; }

/* === HIER EINF√úGEN: RIPPLE EFFEKT LOGIK === */
 function createRipple(event) { const button = event.currentTarget; const circle = document.createElement("span"); const diameter = Math.max(button.clientWidth, button.clientHeight); const radius = diameter / 2; 
// Position berechnen 
const rect = button.getBoundingClientRect(); circle.style.width = circle.style.height = `${diameter}px`; circle.style.left = `${event.clientX - rect.left - radius}px`; circle.style.top = `${event.clientY - rect.top - radius}px`; circle.classList.add("ripple");
// Falls schon ein Ripple da ist, entfernen 
const ripple = button.getElementsByClassName("ripple")[0]; if (ripple) { ripple.remove(); } button.appendChild(circle); }
 /* === ENDE EINF√úGEN === */ 



// === 4. AUDIO ENGINE ===
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function playSound(type){
    if(isMuted) return;
    if(!audioCtx) audioCtx = new AudioContext();
    if(audioCtx.state==='suspended') audioCtx.resume();
    const now=audioCtx.currentTime; const osc=audioCtx.createOscillator(); const g=audioCtx.createGain();
    osc.connect(g); g.connect(audioCtx.destination);
    if(type==='pop'){
        osc.frequency.setValueAtTime(800,now); osc.frequency.exponentialRampToValueAtTime(1200,now+0.1);
        g.gain.setValueAtTime(0.05,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.1);
        osc.start(now); osc.stop(now+0.1);
    } else if(type==='fanfare'){
        [440,554,659].forEach((f,i)=>{
             const o=audioCtx.createOscillator(); const gn=audioCtx.createGain(); o.connect(gn); gn.connect(audioCtx.destination);
             o.frequency.value=f; gn.gain.setValueAtTime(0.05,now+i*0.1); gn.gain.linearRampToValueAtTime(0,now+i*0.1+0.5);
             o.start(now+i*0.1); o.stop(now+i*0.1+0.5);
        });
    }
}

// === 5. DATA ENGINE ===
function getHistory(y) { try{return JSON.parse(localStorage.getItem('history-'+y))||{}}catch(e){return{}} }
function saveHistory(y, h) { localStorage.setItem('history-'+y, JSON.stringify(h)); }
function getAvailableYears() {
    let ys = new Set([currentSystemYear]);
    for(let i=0; i<localStorage.length; i++) {
        const k = localStorage.key(i);
        if(k.startsWith('history-')) ys.add(parseInt(k.split('-')[1]));
    }
    return Array.from(ys).sort((a,b)=>b-a);
}

function writeEntry(date, idx, data){
    const y = parseInt(date.split('-')[0]);
    let h = getHistory(y);
    h[date] = h[date] || { total:0, perAnimal:{} };
    h[date].perAnimal[idx] = h[date].perAnimal[idx] || [];
    h[date].perAnimal[idx].push(data);
    h[date].total++;
    saveHistory(y, h);
    return { year:y, date, idx, arrIdx: h[date].perAnimal[idx].length-1 };
}

function removeEntry(date, idx, arrIdx){
    const y = parseInt(date.split('-')[0]);
    let h = getHistory(y);
    if(h[date]?.perAnimal?.[idx]){
        h[date].perAnimal[idx].splice(arrIdx, 1);
        h[date].total--;
        if(h[date].perAnimal[idx].length===0) delete h[date].perAnimal[idx];
        if(h[date].total<=0) delete h[date];
        saveHistory(y, h);
    }
}

// === 30-TAGE CLEANUP ===
function checkTrashAge(){
    const now = Date.now();
    const limit = 30 * 24 * 60 * 60 * 1000; // 30 Tage in ms
    const initialLen = trashBin.length;
    
    // Behalte nur Elemente, die j√ºnger als 30 Tage sind (oder kein Datum haben -> Legacy Schutz)
    trashBin = trashBin.filter(item => {
        if(!item.deletedAt) return true; 
        return (now - item.deletedAt) < limit;
    });
    
    if(trashBin.length !== initialLen) {
        saveGlobals();
        console.log("Papierkorb automatisch bereinigt.");
    }
}

function loadGlobals(){
    try {
        // 1. Tiere laden
        const a = localStorage.getItem('animals-'+currentSystemYear) || localStorage.getItem('animals-'+(currentSystemYear-1));
        animals = a ? JSON.parse(a) : [];
        
        // Datenbank-Migration (optional, falls noch alte Bilder da sind)
        animals.forEach(async (an, i) => {
            if(an.image && !an.imageId && an.image.startsWith('data:')) {
                const newId = 'img_'+Date.now()+'_'+i;
                await dbSaveImg(newId, an.image);
                an.imageId = newId; delete an.image;
                saveGlobals();
            }
        });
        
        // 2. Orte laden
        locations = JSON.parse(localStorage.getItem('locations')||'[]');
        let lc = localStorage.getItem('locCoords');
        if(!lc) lc = localStorage.getItem('locCoords-'+currentSystemYear);
        locCoords = lc ? JSON.parse(lc) : {};

        // 3. PAPIERKORB LADEN (Das fehlte wahrscheinlich!)
        trashBin = JSON.parse(localStorage.getItem('trashBin') || '[]');

        // 4. Einstellungen
        dark = localStorage.getItem('darkmode')==='true';
        if(dark) document.body.classList.add('dark');
        viewMode = localStorage.getItem('viewMode') || 'list';
        sortMode = localStorage.getItem('sortMode') || 'fav';

        // 5. START-AKTIONEN
        // Automatisch alte Sachen l√∂schen (>30 Tage)
        if(typeof checkTrashAge === "function") checkTrashAge();
        
        // Anzeige sofort aktualisieren!
        updateStorageUI(); 
        updateTrashUI(); // <--- Sorgt daf√ºr, dass die Eintr√§ge sofort sichtbar sind
  
       checkBackupHealth();
       setTimeout(initMemoryDeck, 1000); // Kurz warten damit DB bereit ist
// ... in loadGlobals ...
loadRandomFact();

checkLevelProgress();
    } catch(e){ 
        console.error("Fehler beim Laden:", e); 
        // Falls was schief geht, nicht alles l√∂schen, nur Fehler loggen
        showErrorToast("Fehler beim Laden der Daten");
    }
}

function saveGlobals(){
    localStorage.setItem('animals-'+currentSystemYear, JSON.stringify(animals));
    localStorage.setItem('locations', JSON.stringify(locations));
    localStorage.setItem('locCoords', JSON.stringify(locCoords));
    localStorage.setItem('trashBin', JSON.stringify(trashBin));
}

async function updateStorageUI(){
    const count = await dbCount();
    getEl('storageText').innerText = count + " Bilder gespeichert";
    const pct = Math.min((count * 0.5) / 500 * 100, 100);
    getEl('storageBar').style.width = pct + '%';
    getEl('storageBar').style.background = pct > 90 ? 'var(--err-text)' : 'var(--accent)';
}


// === 6. IMAGE COMPRESSION (Updated) ===
function resizeImage(base64, maxW, cb, quality = 0.7){ // Default 0.7 Quality
    const img = new Image();
    img.src = base64;
    img.onload = () => {
        const c = document.createElement('canvas');
        const scale = Math.min(1, maxW / img.width); // Nur verkleinern, nie vergr√∂√üern
        c.width = img.width * scale;
        c.height = img.height * scale;
        const ctx = c.getContext('2d');
        ctx.drawImage(img, 0, 0, c.width, c.height);
        cb(c.toDataURL('image/jpeg', quality));
    };
}


// === 7. CORE LOGIC ===
async function addAnimal(){
    const nm = getEl('nameInput').value.trim();
    if(!nm) return showErrorToast("Name fehlt");
    let imgId = null;
    if(currentTempImg) {
        imgId = 'img_' + Date.now();
        await dbSaveImg(imgId, currentTempImg);
    }
    const tags = getEl('tagInput').value.trim() ? getEl('tagInput').value.split(',').map(s=>s.trim()) : [];
    animals.push({ name:nm, emoji:getEl('emojiInput').value||'üêæ', imageId: imgId, tags, isFav: false });
    getEl('nameInput').value=''; getEl('emojiInput').value=''; getEl('tagInput').value='';
    clearImage();
    saveGlobals(); render(); updateStorageUI();
    showErrorToast("Tier angelegt!", true);
}

function handleImageUpload(input){
    if(input.files && input.files[0]){
        const reader = new FileReader();
        reader.onload = e => resizeImage(e.target.result, 800, res => { // Max 800px width
            currentTempImg = res;
            getEl('previewEl').src = res;
            getEl('imgPreview').style.display='block';
        });
        reader.readAsDataURL(input.files[0]);
    }
}
function clearImage(){ currentTempImg=null; getEl('imgPreview').style.display='none'; }

// === UNDO SYSTEM ===
function showUndoToast(actionDesc, undoFn) {
    const t = getEl('undoToast');
    getEl('undoText').innerText = actionDesc;
    t.classList.add('show');
    clearTimeout(undoTimeout);
    undoStack.push(undoFn);
    undoTimeout = setTimeout(() => {
        t.classList.remove('show');
        undoStack = []; 
    }, 4000);
}

function performUndo() {
    if(undoStack.length > 0) {
        const fn = undoStack.pop(); fn();
        getEl('undoToast').classList.remove('show');
        render(); showErrorToast("R√ºckg√§ngig gemacht", true);
    }
}

function change(i, delta, e){
    if(delta > 0) {
        const locSel = getEl(viewMode === 'grid' ? 'locSelectGrid'+i : 'locSelect'+i);
        const locVal = locSel ? locSel.value : '';
        const entry = { location: locVal, time: nowTimeStr() };
        const date = todayStr();
        const info = writeEntry(date, i, entry);
        playSound('pop');
        if(e && navigator.vibrate) navigator.vibrate(15);
        if(e) spawnParticle(e.clientX, e.clientY, "+1");
        showUndoToast(`Gez√§hlt: ${animals[i].name} (+1)`, () => removeEntry(date, i, info.arrIdx));
        checkLevelProgress(); 
render();
    }
}

function toggleFav(i, e) {
    if(e) e.stopPropagation();
    animals[i].isFav = !animals[i].isFav;
    saveGlobals();
    if(navigator.vibrate) navigator.vibrate(5);
    render();
}

function spawnParticle(x, y, text) {
    const p = document.createElement('div');
    p.className = 'particle'; p.innerText = text; p.style.color = 'var(--accent)';
    p.style.left = x + 'px'; p.style.top = y + 'px';
    document.body.appendChild(p);
    setTimeout(() => p.remove(), 800);
}

// === FIX: EIGENE FUNKTION F√úR ORTE ===
function renderLocations() {
    const locContainer = document.getElementById('locationListDisplay');
    // Falls wir gerade nicht auf der Admin-Seite sind oder das Element fehlt
    if(!locContainer) return;

    locContainer.innerHTML = '';
    
    if(!locations.length) {
        locContainer.innerHTML = '<span style="font-size:13px; opacity:0.5; padding:5px;">Keine Orte gespeichert.</span>';
    } else {
        locations.forEach((l, i) => {
            const pill = document.createElement('div');
            pill.style.cssText = "background:var(--btn); padding:6px 10px; border-radius:15px; font-size:12px; cursor:pointer; display:flex; align-items:center; gap:5px; border:1px solid transparent;";
            pill.innerHTML = `<span>üìç ${l}</span> <span style="color:var(--err-text); font-weight:bold; margin-left:2px;">&times;</span>`;
            
            // WICHTIG: stopPropagation verhindert, dass Klicks auf das X irgendwas anderes ausl√∂sen
            pill.onclick = (e) => { 
                e.stopPropagation(); 
                safeRun(deleteLocation, i); 
            };
            
            locContainer.appendChild(pill);
        });
    }
}

// Hilfsfunktion um Fav-Counts zu berechnen
function favsWithCount(favArray, historyData) {
    return favArray.map(f => {
        let c = 0; 
        Object.values(historyData).forEach(day => { 
            if(day.perAnimal?.[f.idx]) c += day.perAnimal[f.idx].length; 
        });
        return {...f, count: c};
    });
}

/* === RENDER (LISTE, SNEAK PEEK & FAVORITEN) === */

/* === ULTIMATE RENDER ENGINE (Animals, Notes, Gallery) === */

/* === ULTIMATE RENDER ENGINE (Fixed: Toggle & Expand) === */


function render() {
    // ... deine bestehenden Checks ...
    if(typeof renderLocations === 'function') renderLocations();
    const list = document.getElementById('list'); 
    if (!list) return; 

    // NEU: UI Buttons aktualisieren
    if(typeof updateMicroUI === 'function') updateMicroUI();
    
    const favCont = document.getElementById('favContainer');
    const toggleCont = document.getElementById('listToggleContainer');
    const sneakCont = document.getElementById('sneakPeekContainer');
    const sneakHint = document.getElementById('sneakHint');
    const emptyState = document.getElementById('emptyState');
    const tagCont = document.getElementById('tagFilterContainer');
    
    // Reset der Container
    list.innerHTML = '';
    if(favCont) favCont.innerHTML = '';
    if(toggleCont) toggleCont.innerHTML = '';

    // --- FIX 1: BUTTON TEXT AKTUALISIEREN ---
    const modeBtn = document.getElementById('modeToggleBtn');
    if (modeBtn) {
        modeBtn.classList.remove('active'); // Reset Farbe
        if (appMode === 'animals') {
            modeBtn.innerText = 'TIERE';
        } else if (appMode === 'notes') {
            modeBtn.innerText = 'NOTIZ';
            modeBtn.classList.add('active');
        } else if (appMode === 'gallery') {
            modeBtn.innerText = 'FOTOS';
            modeBtn.classList.add('active');
        }
    }

    const searchInput = document.getElementById('listSearch');
    const searchVal = searchInput ? searchInput.value.toLowerCase().trim() : '';
    const isSearching = searchVal.length > 0;

    // --- FIX 2: LISTE AUSKLAPPEN/EINKLAPPEN LOGIK ---
    // Wenn gesucht wird oder wir nicht bei Tieren sind -> Immer offen
    const forceExpand = isSearching || appMode !== 'animals';
    const isExpandedState = listExpanded || forceExpand;
    
    if (sneakCont) {
        if (isExpandedState) {
            sneakCont.classList.remove('collapsed'); // Aufklappen
            if(sneakHint) sneakHint.style.display = 'none';
        } else {
            sneakCont.classList.add('collapsed'); // Zuklappen (Overlay aktiv)
            if(sneakHint) sneakHint.style.display = 'block';
        }
    }

    // Toggle Button (Pille) anzeigen, wenn aufgeklappt
    if (toggleCont) {
        if (appMode === 'animals' && isExpandedState && !isSearching) {
            toggleCont.innerHTML = `<div class="list-toggle-btn is-open" onclick="safeRun(collapseList)">Liste einklappen <span class="arrow-icon">‚ñ≤</span></div>`;
        } else {
            toggleCont.innerHTML = '';
        }
    }

    // --- 3. DATEN AGGREGATION (MIT ZEIT-FILTER) ---
    const availableYears = getAvailableYears(); 
    let filteredCounts = new Array(animals.length).fill(0);
    let noteMatches = [];
    let galleryItems = [];
    
    // Check: Ist Zeitfilter aktiv?
    const isFilterActive = (timeFilter.start || timeFilter.end);

    // Durch alle Jahre loopen
    availableYears.forEach(year => {
        const h = getHistory(year);
        Object.entries(h).forEach(([dateStr, dayData]) => {
            // Zeit-Filter pr√ºfen
            if (!isDateInFilter(dateStr)) return; 

            if (dayData.perAnimal) {
                Object.entries(dayData.perAnimal).forEach(([idxStr, entries]) => {
                    const idx = parseInt(idxStr);
                    const animal = animals[idx];
                    if (!animal) return;

                    // Z√§hlen f√ºr Tier-Modus
                    filteredCounts[idx] += entries.length;

                    // Sammeln f√ºr Notiz/Galerie-Modus
                    entries.forEach((entry, arrIdx) => {
                        const textMatch = entry.note && entry.note.toLowerCase().includes(searchVal);
                        const locMatch = entry.location && entry.location.toLowerCase().includes(searchVal);
                        const animalNameMatch = animal.name.toLowerCase().includes(searchVal);
                        const tagMatch = animal.tags && animal.tags.some(t => t.toLowerCase().includes(searchVal));
                        
                        const isMatch = !isSearching || textMatch || locMatch || animalNameMatch || tagMatch;

                        if (isMatch) {
                            if (entry.note || isSearching) {
                                noteMatches.push({
                                    date: dateStr, time: entry.time, location: entry.location,
                                    note: entry.note, animalName: animal.name, animalEmoji: animal.emoji,
                                    animalIdx: idx, arrIdx: arrIdx, imageId: entry.noteImageId
                                });
                            }
                            if (entry.noteImageId) {
                                galleryItems.push({ 
                                    imgId: entry.noteImageId, title: animal.name, sub: dateStr, 
                                    type: 'Sichtung', idx: idx, date: dateStr, arrIdx: arrIdx 
                                });
                            }
                        }
                    });
                });
            }
        });
    });

    // Profilbilder zur Galerie (immer, wenn Tier zum Suchbegriff passt)
    animals.forEach(a => {
        if(a.imageId && (!isSearching || a.name.toLowerCase().includes(searchVal))) {
            galleryItems.push({ imgId: a.imageId, title: a.name, type: 'Profil', idx: animals.indexOf(a) });
        }
    });

    noteMatches.sort((a, b) => b.date.localeCompare(a.date) || b.time.localeCompare(a.time));
    galleryItems.reverse();

    // --- 4. FILTER CHIP GENERIEREN ---
    if(tagCont) {
        if(appMode !== 'animals') tagCont.style.display = 'none';
        else {
            tagCont.style.display = 'flex'; 
            let tagHTML = '';
            
            // Story Ring
            if (typeof storyPreviewData !== 'undefined' && storyPreviewData) {
               const innerContent = storyPreviewData.img ? `<img src="${storyPreviewData.img}">` : storyPreviewData.emoji;
               tagHTML += `<div class="tag-story-item" onclick="window.openStoryModal()"><div class="tsr-border"></div><div class="tsr-inner">${innerContent}</div><div class="tsr-badge">${storyPreviewData.count}</div></div>`;
            }
            
            // Ranger Funk
            tagHTML += `<div class="tag-pill" onclick="openRangerChat()" style="background: linear-gradient(135deg, #00b894, #008970); color: white; border: none; margin-right:8px; box-shadow: 0 2px 8px rgba(0, 184, 148, 0.3);"><span style="font-size:16px; margin-right:5px;">üìª</span><span>Funk</span></div>`;
            
            // Zeit Filter Chip
            let timeLabel = "Zeit: Alles";
            let activeClass = "";
            let resetBtn = "";
            
            if (isFilterActive) {
                activeClass = "active"; 
                const s = fmtDateShort(timeFilter.start) || "Anfang";
                const e = fmtDateShort(timeFilter.end) || "Heute";
                timeLabel = `${s} - ${e}`;
                resetBtn = `<span onclick="resetTimeFilter(event)" style="margin-left:8px; opacity:0.8; font-weight:bold; padding:2px 6px; background:rgba(0,0,0,0.2); border-radius:50%;">&times;</span>`;
            }

            tagHTML += `<div class="tag-pill ${activeClass}" onclick="toggleTimePanel()" style="border:1px solid var(--btn)">üìÖ ${timeLabel} ${resetBtn}</div>`;

            // Tag Filter
            tagHTML += `<div class="tag-pill ${currentFilter==='ALL'?'active':''}" onclick="safeRun(filterTags, 'ALL')" id="tag-ALL">Alle</div>`;
            const allTags = new Set(); animals.forEach(a => a.tags?.forEach(t => allTags.add(t)));
            allTags.forEach(t => { tagHTML += `<div class="tag-pill ${currentFilter===t?'active':''}" onclick="safeRun(filterTags, '${t}')" id="tag-${t}">${t}</div>`; });
            tagCont.innerHTML = tagHTML;
        }
    }

    // --- 5. LISTEN INHALT RENDERN ---

    // A) GALERIE
    if (appMode === 'gallery') {
        if (galleryItems.length === 0) {
            list.innerHTML = `<div style="text-align:center; padding:60px 20px; opacity:0.5;"><div style="font-size:50px; margin-bottom:10px;">üì∏</div>Keine Fotos im gew√§hlten Zeitraum.</div>`;
            return;
        }
        const galleryGrid = document.createElement('div'); galleryGrid.className = 'grid-container';
        galleryItems.forEach((item, i) => {
            const div = document.createElement('div'); div.className = 'grid-item fade-in'; div.style.height = '180px';
            const imgContainerId = `gal-img-${i}`;
            div.innerHTML = `<div id="${imgContainerId}" class="grid-bg-img" style="background:var(--btn); display:flex; align-items:center; justify-content:center;"><div class="loader-spinner" style="width:20px; height:20px;"></div></div><div class="grid-overlay"></div><div class="grid-info"><div class="grid-name" style="font-size:12px !important;">${item.title}</div><div class="grid-sub" style="font-size:9px !important;">${item.type} ${item.sub || ''}</div></div>`;
            div.onclick = () => { if(item.type === 'Profil') openDetail(item.idx); else viewNoteDetail(item.idx, item.date, item.arrIdx); };
            galleryGrid.appendChild(div);
            dbGetImg(item.imgId).then(src => { if(src) document.getElementById(imgContainerId).innerHTML = `<img src="${src}" class="grid-bg-img">`; });
        });
        list.appendChild(galleryGrid);
        return;
    }

    // B) NOTIZEN
    if (appMode === 'notes') {
        if (noteMatches.length === 0) {
            list.innerHTML = `<div style="text-align:center; padding:60px 20px; opacity:0.5;"><div style="font-size:50px; margin-bottom:10px;">üìù</div>Keine Notizen im gew√§hlten Zeitraum.</div>`;
            return;
        }
        noteMatches.forEach((match, loopIdx) => {
            const div = document.createElement('div'); div.className = 'log-entry fade-in'; div.style.animationDelay = `${loopIdx * 0.03}s`;
            const dateDisplay = match.date.split('-').reverse().slice(0,2).join('.');
            const nodeId = `node-img-${loopIdx}`;
            const hl = (txt) => { if(!txt) return ''; if(!isSearching) return txt; return txt.replace(new RegExp(`(${searchVal})`, 'gi'), '<mark style="background:rgba(255,235,59,0.4); color:inherit; border-radius:2px; padding:0 2px;">$1</mark>'); };
            div.innerHTML = `<div class="log-left"><div class="log-node" id="${nodeId}">${match.animalEmoji}</div><div class="log-line"></div></div><div class="log-card" onclick="safeRun(viewNoteDetail, ${match.animalIdx}, '${match.date}', ${match.arrIdx})"><div class="log-header"><span class="log-title">${hl(match.animalName)}</span><span class="log-meta">${dateDisplay} ‚Ä¢ ${match.time}</span></div><div class="log-text">${match.imageId ? 'üì∑ ' : ''}${hl(match.note) || 'Kein Text'}</div>${match.location ? `<div class="log-loc">üìç ${hl(match.location)}</div>` : ''}</div><div class="log-right"><div class="log-deadzone" onclick="event.stopPropagation()"></div><div class="log-menu-btn" onclick="openHistoryMenu(${match.animalIdx}, '${match.date}', ${match.arrIdx}, event)">‚ãÆ</div></div>`;
            list.appendChild(div);
            if (match.imageId) dbGetImg(match.imageId).then(src => { if(src) document.getElementById(nodeId).innerHTML = `<img src="${src}">`; document.getElementById(nodeId).style.border = "2px solid var(--accent)"; });
            else if (animals[match.animalIdx].imageId) dbGetImg(animals[match.animalIdx].imageId).then(src => { if(src) document.getElementById(nodeId).innerHTML = `<img src="${src}">`; });
        });
        return;
    }

    // C) TIERE (STANDARD)
    let animalMatches = animals.map((a, i) => {
        // Hier wenden wir die gez√§hlten Werte aus dem Zeitfilter an!
        return { ...a, idx: i, count: filteredCounts[i] }; 
    }).filter(a => {
        if(currentFilter !== 'ALL' && !a.tags?.includes(currentFilter)) return false;
        if(searchVal) return a.name.toLowerCase().includes(searchVal) || (a.tags && a.tags.some(t => t.toLowerCase().includes(searchVal)));
        return true;
    });

    if(animalMatches.length === 0) {
        list.innerHTML = `<div style="text-align:center; padding:60px 20px; opacity:0.5;">
            <div style="font-size:60px; margin-bottom:15px;">üîç</div>
            <h3>Nichts gefunden</h3>
            <p>Im Zeitraum "${timeFilter.start||'Anfang'} - ${timeFilter.end||'Heute'}" gab es keine Sichtungen.</p>
            ${isSearching ? `<button onclick="safeRun(quickCreate, '${document.getElementById('listSearch').value}')" style="margin-top:15px; background:var(--accent); color:#fff; padding:10px 20px; border-radius:20px; border:none;">Als Tier anlegen</button>` : ''}
        </div>`;
        return;
    }

    // Sortierung
    animalMatches.sort((a,b) => {
        if(sortMode === 'fav') { if (a.isFav !== b.isFav) return b.isFav - a.isFav; return a.name.localeCompare(b.name); }
        if(sortMode === 'name') return a.name.localeCompare(b.name);
        return b.count - a.count;
    });

    // Render Grid vs List
    if (viewMode === 'grid') {
        const gridCont = document.createElement('div'); gridCont.className = 'grid-container';
        animalMatches.forEach((item, loopIdx) => {
            const card = document.createElement('div'); card.className = 'grid-item fade-in'; card.style.animationDelay = `${loopIdx*0.04}s`;
            card.onclick = () => openDetail(item.idx);
            let bgHTML = `<div class="grid-bg-img" style="background:var(--btn); display:flex; align-items:center; justify-content:center; font-size:60px;">${item.emoji}</div>`;
            card.innerHTML = `${bgHTML}<div class="grid-overlay"></div><div class="grid-badge-top">${item.count}</div><div class="grid-info"><div class="grid-name">${item.name}</div><div class="grid-sub">${item.isFav?'‚≠ê Favorit':(item.tags[0]||'Tier')}</div></div><div class="grid-menu-btn" onclick="openItemMenu(${item.idx}, event)">‚ãÆ</div>`;
            if(item.imageId) { dbGetImg(item.imageId).then(src => { if(src) card.querySelector('.grid-bg-img').innerHTML = `<img src="${src}" class="grid-bg-img">`; }); }
            gridCont.appendChild(card);
        });
        list.appendChild(gridCont);
    } else {
        animalMatches.forEach((item, loopIdx) => {
            const div = document.createElement('div'); div.className = `row fade-in`; div.style.animationDelay = `${loopIdx*0.05}s`;
            
            const hlName = isSearching ? item.name.replace(new RegExp(`(${searchVal})`, 'gi'), '<mark style="background:rgba(255,235,59,0.5); border-radius:2px;">$1</mark>') : item.name;
            const colors = ['#e84393', '#0984e3', '#00b894', '#fdcb6e', '#6c5ce7', '#d63031'];
            const itemColor = colors[item.name.length % colors.length];
            const imgHTML = `<div class="list-thumb-placeholder" style="background:${itemColor}20; color:${itemColor}; border:1px solid ${itemColor}40;">${item.emoji}</div>`;

            div.innerHTML = `
                <div class="row-main" onclick="openDetail(${item.idx})">
                    <div class="list-visual">${imgHTML}</div>
                    <div class="list-content">
                        <div class="list-top-line"><span class="list-name">${hlName}</span>${item.isFav?'<span class="list-fav-star">‚òÖ</span>':''}</div>
                        <div class="list-sub-line">Anzahl im Zeitraum:</div>
                    </div>
                    <div class="count-badge"><span>${item.count}</span></div>
                </div>
                <div class="row-menu" onclick="openItemMenu(${item.idx}, event)">‚ãÆ</div>
            `;
            if(item.imageId) { dbGetImg(item.imageId).then(src => { if(src) div.querySelector('.list-visual').innerHTML = `<img src="${src}" class="list-thumb-img">`; }); }
            list.appendChild(div);
        });
    }
}


function filterTags(t) { currentFilter=t; render(); }

/* === SEMANTIC SORT & FEEDBACK LOGIC === */

// Hilfsfunktion f√ºr den Feedback-Effekt
let fbTimer;
function showFeedback(text) {
    const wrap = document.getElementById('sfWrapper');
    const stat = document.getElementById('sfStatus');
    
    if(!wrap || !stat) return;

    stat.innerText = text;
    wrap.classList.add('feedback-active');
    stat.classList.add('show');
    
    clearTimeout(fbTimer);
    fbTimer = setTimeout(() => {
        wrap.classList.remove('feedback-active');
        stat.classList.remove('show');
    }, 1200); // Zeigt den Text f√ºr 1.2 Sekunden
}

function cycleSort() { 
    // Reihenfolge: Fav (‚òÖ) -> Zeit (NEU) -> Name (A-Z) -> Anzahl (1-9)
    if(sortMode === 'fav') sortMode = 'last';
    else if(sortMode === 'last') sortMode = 'name';
    else if(sortMode === 'name') sortMode = 'count';
    else sortMode = 'fav'; 

    localStorage.setItem('sortMode', sortMode);
    
    // Feedback Text & Button Update
    let fbText = "";
    const btn = document.getElementById('sortBtn');
    
    switch(sortMode) {
        case 'fav':   btn.innerText = "‚òÖ";   fbText = "Sortiert: Favoriten"; break;
        case 'last':  btn.innerText = "NEU"; fbText = "Sortiert: Neueste"; break;
        case 'name':  btn.innerText = "A-Z"; fbText = "Sortiert: Name"; break;
        case 'count': btn.innerText = "1-9"; fbText = "Sortiert: Anzahl"; break;
    }
    
    showFeedback(fbText);
    render(); 
}

function toggleViewMode() { 
    // Wenn wir in Notizen/Galerie sind -> Zur√ºck zu Tieren
    if (appMode !== 'animals') {
        appMode = 'animals';
    } else {
        // Sonst wie gehabt umschalten
        viewMode = viewMode === 'list' ? 'grid' : 'list'; 
        localStorage.setItem('viewMode', viewMode);
    }
    
    const btn = document.getElementById('viewToggleBtn');
    if(btn) btn.innerText = viewMode === 'list' ? 'LIST' : 'GRID';
    
    showFeedback(viewMode === 'list' ? "Ansicht: Liste" : "Ansicht: Raster");
    render(); 
}

// === DETAILS & EDIT ===

/* === OPEN DETAIL (CINEMATIC + 3 PUNKTE) === */
async function openDetail(i) {
    detailAnimalIdx = i; 
    const modal = getEl('detailModal');
    const a = animals[i];
    
    // 1. Bild aus DB laden (f√ºr Hintergrund & Icon)
    let bgStyle = '';
    let imgSrc = '';
    
    if (a.imageId) {
        try {
            const src = await dbGetImg(a.imageId);
            if (src) {
                imgSrc = src;
                // Hintergrund mit Blur und Abdunklung
                bgStyle = `background-image: linear-gradient(to bottom, rgba(0,0,0,0.2), rgba(0,0,0,0.8)), url('${src}');`;
            }
        } catch (e) {
            console.log("Bild konnte nicht geladen werden", e);
        }
    }

    // 2. HTML f√ºr den Header bauen
    const headerHTML = `
    <div class="detail-header-wrapper">
        <!-- Blur Hintergrund -->
        <div class="detail-bg-blur" style="${bgStyle}"></div>
        
        <div class="detail-header-content">
            <!-- Das Icon/Bild -->
            <div style="width:70px; height:70px; font-size:40px; border-radius:20px; overflow:hidden; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.3); border:2px solid rgba(255,255,255,0.2); box-shadow:0 5px 15px rgba(0,0,0,0.3); flex-shrink:0;">
                ${imgSrc ? 
                    `<img src="${imgSrc}" style="width:100%; height:100%; object-fit:cover; cursor:zoom-in;" onclick="openImageLightbox('${imgSrc}')">` : 
                    a.emoji
                }
            </div>
            
            <!-- Titel & Buttons -->
            <div style="flex:1;">
                <h2 style="margin:0; font-size:24px; color:#fff; text-shadow:0 2px 10px rgba(0,0,0,0.5); line-height:1.2;">${a.name}</h2>
                
                <div style="display:flex; align-items:center; gap:10px; margin-top:10px;">
                    <!-- 1. Quick Add Button (Blaues Plus) -->
                    <button onclick="openNoteModal(${i})" class="action-btn-main" style="width:38px; height:38px; font-size:20px; margin:0;" title="Sichtung hinzuf√ºgen">+</button>

                    <!-- 2. Men√º Button (Drei Punkte, Glassy Look) -->
                    <button onclick="openAnimalMenu(${i}, event)" 
                            style="width:38px; height:38px; font-size:22px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.3); color:#fff; border-radius:12px; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(5px); cursor:pointer;" 
                            title="Optionen">
                        ‚ãÆ
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Jahr Auswahl -->
    <div style="padding:0 5px; margin-top:-10px; position:relative; z-index:2;">
        <select id="detailYearSelect" onchange="safeRun(updateDetailChart)" style="padding:6px 12px; font-size:12px; background:var(--card); border:1px solid var(--btn); color:var(--sub); border-radius:12px; font-weight:bold; box-shadow:0 4px 10px rgba(0,0,0,0.1); cursor:pointer; outline:none;">
            <!-- Wird unten gef√ºllt -->
        </select>
    </div>
    `;
    
    // 3. In Modal einf√ºgen
    const modalContent = modal.querySelector('.modal-content');
    
    // Container suchen oder erstellen
    let container = document.getElementById('detail-dynamic-header');
    if (!container) {
        container = document.createElement('div');
        container.id = 'detail-dynamic-header';
        
        const closeBtn = modalContent.querySelector('.close-btn');
        if (closeBtn) {
            closeBtn.parentNode.insertBefore(container, closeBtn.nextSibling);
            // Close Button Styling anpassen (damit er auf dem Bild sichtbar ist)
            closeBtn.style.background = "rgba(0,0,0,0.5)";
            closeBtn.style.color = "#fff";
            closeBtn.style.border = "1px solid rgba(255,255,255,0.3)";
        } else {
            modalContent.prepend(container);
        }
        
        // Alte Elemente verstecken
        const oldTitle = document.getElementById('detailTitle');
        if (oldTitle) {
            const oldHeaderContainer = oldTitle.closest('div[style*="display:flex"]'); 
            if (oldHeaderContainer) oldHeaderContainer.style.display = 'none';
        }
    }
    
    container.innerHTML = headerHTML;

    // 4. Dropdown f√ºllen
    const ys = getAvailableYears();
    const sel = document.getElementById('detailYearSelect');
    if (sel) {
        sel.innerHTML = ys.map(y => `<option value="${y}" ${y===currentSystemYear?'selected':''}>üìÖ Jahr ${y}</option>`).join('');
    }
    
    // 5. Statistik laden
    updateDetailChart();
    modal.style.display = 'block';
}

// === DETAIL DASHBOARD LOGIK ===
/* === UPDATE DETAIL CHART (Separater Verlauf) === */


/* === UPDATE DETAIL CHART (Komplett) === */
function updateDetailChart() {
    const i = detailAnimalIdx; 
    const y = parseInt(getEl('detailYearSelect').value);
    const h = getHistory(y);
    const body = getEl('modalBody');
    const a = animals[i];
    if(!a) return;

    // --- 1. DATEN SAMMELN ---
    let total = 0;
    let locs = {};
    let allEntries = [];
    let firstDate = null;
    let maxDayCount = 0;
    let dailyCounts = {};

    Object.entries(h).forEach(([dateStr, entry]) => {
        if(entry.perAnimal?.[i]){
            const list = entry.perAnimal[i];
            total += list.length;
            
            // Tagesrekord & DNA Daten
            if(!dailyCounts[dateStr]) dailyCounts[dateStr] = 0;
            dailyCounts[dateStr] += list.length;
            
            // Erster Eintrag
            if(!firstDate || dateStr < firstDate) firstDate = dateStr;

            list.forEach((item, arrIdx) => {
                allEntries.push({ date:dateStr, item, arrIdx });
                if(item.location) locs[item.location] = (locs[item.location]||0)+1;
            });
        }
    });
    
    // Sortieren (Neu nach Alt)
    allEntries.sort((a,b) => b.date.localeCompare(a.date) || (b.item.time||'').localeCompare(a.item.time||''));
    maxDayCount = Math.max(...Object.values(dailyCounts), 0);
    const sortedLocs = Object.entries(locs).sort((a,b)=>b[1]-a[1]);

    // --- 2. BERECHNUNGEN (Ranking, DNA etc.) ---
    const favLoc = sortedLocs.length > 0 ? `${sortedLocs[0][0]} (${sortedLocs[0][1]}x)` : '-';
    const myCat = (a.tags && a.tags.length > 0) ? a.tags[0] : 'Sonstige';
    
    let catRanking = [];
    animals.forEach((anim, idx) => {
        if((anim.tags && anim.tags.includes(myCat)) || (myCat==='Sonstige' && (!anim.tags || anim.tags.length===0))) {
            let c = 0; Object.values(h).forEach(d => { if(d.perAnimal?.[idx]) c += d.perAnimal[idx].length; });
            catRanking.push({ name: anim.name, count: c, isMe: (idx === i) });
        }
    });
    catRanking.sort((a,b) => b.count - a.count);
    
    // Helper DOY
    const getDOY = (dStr) => { 
        const now = new Date(dStr); 
        const start = new Date(now.getFullYear(), 0, 0); 
        return Math.floor((now - start) / (1000 * 60 * 60 * 24)); 
    };

    // Saison Logik
    const getSeason = (month) => {
        if(month <= 1 || month === 11) return 'Winter ‚ùÑÔ∏è';
        if(month >= 2 && month <= 4) return 'Fr√ºhling üå±';
        if(month >= 5 && month <= 7) return 'Sommer ‚òÄÔ∏è';
        return 'Herbst üçÇ';
    };
    let monthCounts = new Array(12).fill(0);
    allEntries.forEach(e => monthCounts[new Date(e.date).getMonth()]++);
    const bestMonthIdx = monthCounts.indexOf(Math.max(...monthCounts));
    const bestSeason = getSeason(bestMonthIdx);

    // Seltenheit
    let globalTotal = 0; Object.values(h).forEach(d => globalTotal += d.total);
    const rarityPct = globalTotal > 0 ? Math.round((total / globalTotal) * 100) : 0;
    
    let rarityLabel = "H√§ufig";
    let rarityDesc = "Du siehst dieses Tier st√§ndig.";
    if(rarityPct <= 1) { rarityLabel = "Legend√§r"; rarityDesc = "Ein echter Geist! Extrem selten."; }
    else if(rarityPct <= 5) { rarityLabel = "Episch"; rarityDesc = "Eine besondere Begegnung."; }
    else if(rarityPct <= 15) { rarityLabel = "Selten"; rarityDesc = "Man braucht etwas Gl√ºck."; }
    else if(rarityPct <= 30) { rarityLabel = "Ungew√∂hnlich"; rarityDesc = "Ab und zu zu sehen."; }
    
    // Timeline Events
    let timelineEvents = [];
    if (allEntries.length > 0) {
        const first = allEntries[allEntries.length-1]; 
        timelineEvents.push({ icon: 'üå±', title: 'Erste Begegnung', date: first.date, desc: first.item.location ? `Entdeckt in: ${first.item.location}` : 'Der Start deiner Beobachtungen.' });
    }
    if (maxDayCount > 2) {
        const recordDateStr = Object.keys(dailyCounts).find(key => dailyCounts[key] === maxDayCount);
        timelineEvents.push({ icon: 'üî•', title: 'Rekord-Tag', date: recordDateStr, desc: `Unglaubliche ${maxDayCount} Sichtungen an einem einzigen Tag!` });
    }
    if (allEntries.length > 1) {
        const last = allEntries[0];
        timelineEvents.push({ icon: 'üìç', title: 'Zuletzt gesehen', date: last.date, desc: last.item.note ? `Notiz: "${last.item.note}"` : (last.item.location ? `Ort: ${last.item.location}` : 'Keine Details eingetragen.') });
    }
    timelineEvents.sort((a,b) => a.date.localeCompare(b.date));


    // --- 3. VERLAUF LISTE GENERIEREN (NEUES LAYOUT) ---
    let historyHTML = '';
    if(allEntries.length === 0) {
        historyHTML = '<div style="opacity:0.5; text-align:center; padding:20px;">Noch keine Sichtungen.</div>';
    } else {
        let lastDate = '';
        const today = new Date().toISOString().slice(0,10);

        allEntries.forEach(row => {
            // Datum Header
            if(row.date !== lastDate) {
                let displayDate = row.date.split('-').reverse().slice(0,2).join('.');
                if(row.date === today) displayDate = "Heute";
                historyHTML += `<div style="margin:15px 0 5px 5px; font-size:11px; font-weight:bold; opacity:0.6; text-transform:uppercase; letter-spacing:1px;">üìÖ ${displayDate}</div>`;
                lastDate = row.date;
            }

            // NEU: Pr√ºfung auf Bild
            const hasImg = row.item.noteImageId ? '<span class="list-cam-icon">üì∑</span>' : '';

            // NEU: Row mit Dead Zone und Klick auf Lese-Ansicht
            historyHTML += `
            <div class="row" style="min-height:50px; margin-bottom:8px; align-items: stretch; background:var(--card-solid); border:1px solid var(--btn);">
                
                <!-- ZONE 1: Klickbar -> √ñffnet Lese-Ansicht (viewNoteDetail) -->
                <div class="row-main" 
                     style="cursor: pointer; display:flex; flex-direction:column; justify-content:center; align-items:flex-start; text-align:left; padding:10px 0 10px 15px;" 
                     onclick="safeRun(viewNoteDetail, ${i}, '${row.date}', ${row.arrIdx})">
                     
                    <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <span style="font-weight:bold; opacity:0.9; font-size:15px; white-space:nowrap;">
                            ‚åö ${row.item.time||'--:--'}
                        </span>
                        
                        <!-- Ort + Kamera Icon -->
                        ${row.item.location || hasImg ? 
                            `<span style="font-size:14px; opacity:0.8; display:flex; align-items:center;">
                                ${hasImg} ${row.item.location ? `üìç ${row.item.location}` : ''}
                             </span>` 
                            : ''}
                    </div>
                    
                    ${row.item.note ? `<div style="font-size:13px; font-style:italic; background:rgba(0,0,0,0.05); color:var(--text); padding:6px 8px; border-radius:8px; margin-top:6px; line-height:1.4; text-align:left; width:100%;">üìù ‚Äû${row.item.note}‚Äú</div>` : ''}
                </div>

                <!-- ZONE 2: DEAD ZONE (Sicherheitsabstand) -->
                <div class="row-deadzone" style="width:30px; border-left:1px solid rgba(255,255,255,0.05);" onclick="event.stopPropagation()"></div>

                <!-- ZONE 3: MEN√ú -->
                <div class="row-menu" onclick="openHistoryMenu(${i}, '${row.date}', ${row.arrIdx}, event)">‚ãÆ</div>
            </div>`;
        });
    }

    // --- 4. HTML ZUSAMMENBAUEN ---
    let html = `
    <!-- HEADER -->
    <div class="stats-grid" style="margin-bottom:20px;">
        <div class="stat-card">
            <div class="stat-label">Gesamt ${y}</div>
            <div class="stat-value bump-effect" id="stat-total">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Tages-Rekord</div>
            <div class="stat-value" id="stat-record">0</div>
        </div>
    </div>

    <!-- STAT WIDGET -->
    <div class="stat-widget-wrapper">
        <div class="widget-header">
            <span class="widget-label">Analyse:</span>
            <select class="stat-selector" onchange="switchStat(this.value)">
                <option value="highlights">üìù Highlights</option>
                <option value="ranking">üèÜ Rang (${myCat})</option>
                <option value="locations">üìç Top Orte</option>
                <option value="memory">üí≠ Notizen</option>
                <option value="timeline">‚è≥ Meilensteine</option>
                <option value="dna">üß¨ Jahres-DNA</option>
                <option value="rarity">üíé Seltenheit</option>
            </select>
        </div>

        <div id="highlights" class="stat-content active">
            <div class="grid-stats">
                <div class="stat-grid-item">
                    <div class="gi-icon">üìÖ</div>
                    <div class="gi-label">Erste Sichtung</div>
                    <div class="gi-val">${firstDate ? firstDate.split('-').reverse().join('.') : '-'}</div>
                </div>
                
                <div class="stat-grid-item">
                    <div class="gi-icon">üî•</div>
                    <div class="gi-label">Rekord</div>
                    <div class="gi-val gi-highlight">${maxDayCount} an einem Tag</div>
                </div>
                
                <div class="stat-grid-item" style="grid-column: span 2; flex-direction: row; align-items: center; gap: 15px;">
                    <div class="gi-icon" style="font-size:24px;">üìç</div>
                    <div>
                        <div class="gi-label">Lieblingsort</div>
                        <div class="gi-val">${favLoc}</div>
                    </div>
                </div>
            </div>
        </div>
     
        <div id="locations" class="stat-content">
            <div style="margin-top:10px">
                ${sortedLocs.length===0?'<div style="opacity:0.5;text-align:center">Leer</div>':''}
                ${sortedLocs.slice(0,5).map((l,i)=>`<div class="loc-info"><strong>${l[0]}</strong><span>${l[1]}x</span></div><div class="loc-row"><div class="loc-rank ${i===0?'gold':''}">${i+1}</div><div class="loc-bar-bg"><div class="loc-bar-fill" style="width:${(l[1]/sortedLocs[0][1])*100}%"></div></div></div>`).join('')}
            </div>
        </div>

        <div id="ranking" class="stat-content">
            <div class="ranking-list">
                ${catRanking.slice(0,5).map((r,i)=>`<div class="rank-row ${r.isMe?'me':''}"><div class="r-pos" style="${r.isMe?'color:var(--accent)':''}">${i+1}</div><div class="r-name">${r.name} ${r.isMe?'':''}</div><div class="r-count" style="${r.isMe?'background:var(--accent);color:#fff':''}">${r.count}x</div></div>`).join('')}
            </div>
        </div>

        <div id="memory" class="stat-content">
            <div class="mem-scroll">
                ${allEntries.filter(e => e.item.note).length === 0 ? '<div style="opacity:0.5; padding:20px;">Keine Notizen vorhanden.</div>' : ''}
                
                ${allEntries.filter(e => e.item.note).map((e, idx) => `
                <div class="mem-card" 
                     onclick="viewNoteDetail(${i}, '${e.date}', ${e.arrIdx})"
                     style="transform: rotate(${idx % 2 === 0 ? '-2' : '2'}deg);"> 
                    <div class="mem-date">${e.date.split('-').reverse().slice(0,2).join('.')}</div>
                    <div class="mem-txt">"${e.item.note}"</div>
                    <div style="position:absolute; bottom:-5px; right:-5px; font-size:40px; opacity:0.1; pointer-events:none;">${a.emoji}</div>
                </div>
                `).join('')}
            </div>
        </div>

        <div id="timeline" class="stat-content">
            <div class="timeline-container">
                <div class="timeline-line"></div>
                ${timelineEvents.map(evt => `
                <div class="tl-event">
                    <div class="tl-icon-bubble">${evt.icon}</div>
                    <div class="tl-content">
                        <div class="tl-date">${evt.date.split('-').reverse().join('.')}</div>
                        <div class="tl-title">${evt.title}</div>
                        <div class="tl-desc">${evt.desc}</div>
                    </div>
                </div>
                `).join('')}
                ${timelineEvents.length === 0 ? '<div style="padding-left:20px; opacity:0.5">Sammle mehr Daten f√ºr eine Timeline.</div>' : ''}
            </div>
        </div>

        <div id="dna" class="stat-content">
            <div class="dna-wrapper">
                <div class="dna-track">
                    ${Object.keys(dailyCounts).map(dStr=>`<div class="dna-mark" style="left:${(getDOY(dStr)/366)*100}%"></div>`).join('')}
                </div>
                <div class="dna-axis">
                    <span class="dna-tick">J</span><span class="dna-tick">F</span><span class="dna-tick">M</span><span class="dna-tick">A</span>
                    <span class="dna-tick">M</span><span class="dna-tick">J</span><span class="dna-tick">J</span><span class="dna-tick">A</span>
                    <span class="dna-tick">S</span><span class="dna-tick">O</span><span class="dna-tick">N</span><span class="dna-tick">D</span>
                </div>
                ${total > 0 ? `<div class="dna-insight">üí° Hauptsaison: ${bestSeason}</div>` : ''}
            </div>
        </div>

        <div id="rarity" class="stat-content">
            <div class="rarity-wrapper">
                <div class="rarity-scale-line">
                    <div class="rarity-pointer" style="left:${rarityPct}%">
                        <div class="rarity-flag">${rarityLabel} (${rarityPct}%)</div>
                        <div class="rarity-triangle"></div>
                    </div>
                </div>
                <div class="rarity-labels"><span>Gew√∂hnlich</span><span>Selten</span></div>
                <div style="text-align:center; font-size:13px; margin-top:20px; line-height:1.5; opacity:0.9">${rarityDesc}</div>
            </div>
        </div>
    </div>

    <!-- SEPARATER VERLAUF (AKKORDEON) -->
    <div class="history-section">
        <div class="history-toggle-btn" onclick="toggleHistory(this)">
            <span>üìã Verlauf anzeigen (${allEntries.length})</span>
            <span class="history-arrow">‚ñº</span>
        </div>
        <div class="history-container-wrapper">
            <div class="history-inner">
                <div class="history-scroll-area">
                    ${historyHTML}
                </div>
            </div>
        </div>
    </div>

    <!-- DELETE -->
    <div style="margin-top:20px; text-align:center;">
        <button onclick="safeRun(moveToTrash, ${i})" style="width:100%; background:var(--err-bg); color:var(--err-text); border:1px solid var(--err-text); padding:14px; border-radius:16px; font-weight:bold;">üóëÔ∏è Tier entfernen</button>
    </div>
    `;
    
    body.innerHTML = html;
    
    setTimeout(() => {
        if(typeof animateValue === 'function') {
            animateValue(document.getElementById('stat-total'), 0, total, 1000);
            animateValue(document.getElementById('stat-record'), 0, maxDayCount, 1200);
        } else {
            document.getElementById('stat-total').innerHTML = total;
            document.getElementById('stat-record').innerHTML = maxDayCount;
        }
    }, 100);
}

// Helper f√ºr das History Men√º
function openHistoryMenu(idx, date, arrIdx, event) {
    if(event) event.stopPropagation();
    
    const menuItems = [
        { label: 'Bearbeiten', icon: '‚úèÔ∏è', action: `openNoteModal(${idx}, '${date}', ${arrIdx})` },
        { label: 'L√∂schen', icon: 'üóëÔ∏è', action: `deleteHistoryItem('${date}', ${idx}, ${arrIdx})`, danger: true }
    ];
    
    // Position (Touch/Maus)
    let x = event.clientX || (event.touches ? event.touches[0].clientX : 0);
    let y = event.clientY || (event.touches ? event.touches[0].clientY : 0);
    
    // Fallback
    if(x === 0 && y === 0) { 
        const rect = event.target.getBoundingClientRect();
        x = rect.left; y = rect.bottom;
    }

    openContextMenu(x, y, menuItems);
}
// === PAPIERKORB LOGIK (TIERE & EINTR√ÑGE) ===

// 1. Einzelnen Eintrag l√∂schen -> in Papierkorb
function deleteHistoryItem(date, i, idx) { 
    if(confirm("Eintrag in Papierkorb verschieben?")) { 
        const h = getHistory(parseInt(date.split('-')[0]));
        const entry = h[date].perAnimal[i][idx];
        
        trashBin.push({
            type: 'entry',
            name: animals[i].name, // F√ºr Anzeige
            date: date,
            animalIdx: i,
            data: entry,
            deletedAt: Date.now()
        });
        
        removeEntry(date, i, idx); 
        saveGlobals(); 
        updateTrashUI();
        updateDetailChart(); 
        render(); 
        showErrorToast("In Papierkorb verschoben", true);
    } 
}

 // 2. Ganzes Tier l√∂schen -> in Papierkorb (INKLUSIVE HISTORIE & INDEX-KORREKTUR)
function moveToTrash(i){ 
    const tierName = animals[i].name;
    if(!confirm(`M√∂chtest du "${tierName}" wirklich l√∂schen?\n\nDas Tier UND alle seine ${animals[i].count||0} Eintr√§ge landen im Papierkorb.`)) {
        return; 
    }

    // A) Historie sichern (Alle Jahre durchgehen)
    const archivedHistory = {}; 
    const years = getAvailableYears();
    
    years.forEach(y => {
        const h = getHistory(y);
        let hasData = false;
        
        Object.entries(h).forEach(([dateStr, dayData]) => {
            if(dayData.perAnimal && dayData.perAnimal[i]) {
                if(!archivedHistory[y]) archivedHistory[y] = {};
                // Wir speichern Datum -> Array von Eintr√§gen
                archivedHistory[y][dateStr] = dayData.perAnimal[i]; 
                hasData = true;
            }
        });
    });

    // B) In Papierkorb schieben (Tier + Historie)
    trashBin.push({
        type: 'animal',
        data: { ...animals[i] }, 
        history: archivedHistory, // Das ist NEU: Die kompletten Sichtungen
        name: tierName,
        deletedAt: Date.now()
    });
    
    // C) Historie der verbleibenden Tiere korrigieren (Index-Shift)
    // Wenn wir Tier 2 l√∂schen, wird Tier 3 zu Tier 2. Die Historie muss das auch tun!
    years.forEach(y => {
        const h = getHistory(y);
        let changed = false;
        
        Object.values(h).forEach(dayData => {
            if(!dayData.perAnimal) return;
            
            // 1. Eintrag des gel√∂schten Tiers entfernen
            if(dayData.perAnimal[i]) { delete dayData.perAnimal[i]; changed = true; }
            
            // 2. Alle Indices > i um eins verringern
            // Wir m√ºssen hier vorsichtig sein und eine neue Map aufbauen oder Schl√ºssel verschieben
            const newPerAnimal = {};
            Object.keys(dayData.perAnimal).forEach(k => {
                const idx = parseInt(k);
                if(idx < i) {
                    newPerAnimal[idx] = dayData.perAnimal[idx]; // Bleibt gleich
                } else if (idx > i) {
                    newPerAnimal[idx - 1] = dayData.perAnimal[idx]; // Rutscht eins runter
                    changed = true;
                }
            });
            dayData.perAnimal = newPerAnimal;
        });
        
        if(changed) saveHistory(y, h);
    });

    // D) Tier aus Array entfernen
    animals.splice(i, 1); 
    
    saveGlobals(); 
    render(); 
    updateStorageUI(); 
    updateTrashUI(); 
    closeModal('detailModal'); 
    showErrorToast("In Papierkorb verschoben", true); 
}


// 3. Wiederherstellen (Tier inkl. Historie)
function restoreFromTrash(trashIdx){ 
    const item = trashBin[trashIdx];
    
    if(item.type === 'entry') {
        // Einzelner Eintrag
        writeEntry(item.date, item.animalIdx, item.data);
        showErrorToast("Eintrag wiederhergestellt", true);
    } else {
        // KOMPLETTES TIER
        const animalData = item.data || item; // Fallback f√ºr alte Backups
        
        // 1. Tier wieder ans Ende der Liste anf√ºgen
        animals.push(animalData);
        const newIdx = animals.length - 1; // Das ist der neue Index
        
        // 2. Historie wiederherstellen (falls vorhanden)
        if(item.history) {
            Object.entries(item.history).forEach(([yearStr, datesObj]) => {
                const y = parseInt(yearStr);
                const h = getHistory(y);
                
                Object.entries(datesObj).forEach(([dateStr, entriesArr]) => {
                    // Tag initialisieren falls nicht da
                    h[dateStr] = h[dateStr] || { total:0, perAnimal:{} };
                    h[dateStr].perAnimal[newIdx] = entriesArr; // Hier mit NEUEM Index einf√ºgen
                    h[dateStr].total += entriesArr.length;
                });
                
                saveHistory(y, h);
            });
        }
        
        showErrorToast("Tier & Verlauf wiederhergestellt", true);
    }
    
    trashBin.splice(trashIdx, 1); 
    saveGlobals(); 
    render(); 
    
    // Falls Detailansicht offen war, aktualisieren
    if(getEl('detailModal').style.display === 'block') {
        // Wir m√ºssen das Modal schlie√üen, da sich der Index ge√§ndert hat!
        closeModal('detailModal');
    }
    
    updateStorageUI(); 
}

// 4. Papierkorb leeren	


async function emptyTrash(){ 
    if(confirm("Papierkorb unwiderruflich leeren? Alle Bilder werden auch gel√∂scht!")){ 
        
        // Durchsuche Papierkorb nach Bildern und l√∂sche sie aus DB
        for (const item of trashBin) {
            // Fall 1: Einzelner Eintrag
            if (item.type === 'entry' && item.data.noteImageId) {
                await dbDelImg(item.data.noteImageId);
            }
            // Fall 2: Ganzes Tier (Hier m√ºssen wir tief graben)
            else if (item.type === 'animal' && item.history) {
                // Tier-Profilbild l√∂schen
                if (item.data.imageId) await dbDelImg(item.data.imageId);

                // Alle Notiz-Bilder in der Historie l√∂schen
                Object.values(item.history).forEach(yearData => {
                    Object.values(yearData).forEach(dayList => {
                        dayList.forEach(entry => {
                            if (entry.noteImageId) dbDelImg(entry.noteImageId);
                        });
                    });
                });
            }
        }

        trashBin = []; 
        saveGlobals(); 
        updateTrashUI(); 
        showErrorToast("Papierkorb & Bilder gel√∂scht", true);
    } 
}

// 5. Papierkorb Eintrag Detailansicht
let currentTrashIdx = null;

function openTrashDetail(i) {
    currentTrashIdx = i;
    const item = trashBin[i];
    const m = getEl('trashDetailModal');
    
    // F√ºlle Daten
    getEl('tdName').innerText = item.name || 'Unbekannt';
    
    if (item.type === 'entry') {
        // --- EINZELNER EINTRAG ---
        getEl('tdType').innerHTML = 'üìù Einzelner Eintrag';
        getEl('tdDate').innerText = item.date;
        getEl('tdTime').innerText = item.data.time || '-';
        getEl('tdLoc').innerText = item.data.location || '-';
        getEl('tdNote').innerText = item.data.note || 'Keine Notiz';
        getEl('tdNote').style.display = 'block';
    } else {
        // --- KOMPLETTES TIER ---
        // Wir z√§hlen mal schnell nach, wie viele Eintr√§ge im Backup stecken
        let countArchived = 0;
        if(item.history) {
            Object.values(item.history).forEach(yearObj => {
                Object.values(yearObj).forEach(dayList => {
                    countArchived += dayList.length;
                });
            });
        }

        // Anzeige mit Z√§hler
        getEl('tdType').innerHTML = `üêæ Komplettes Tier <br><small style="color:var(--accent)">(${countArchived} Sichtungen archiviert)</small>`;
        getEl('tdDate').innerText = new Date(item.deletedAt).toLocaleDateString();
        getEl('tdTime').innerText = '-';
        getEl('tdLoc').innerText = '-';
        getEl('tdNote').style.display = 'none';
    }
    
    // Button Logik
    getEl('tdRestoreBtn').onclick = function() {
        restoreFromTrash(currentTrashIdx);
        closeModal('trashDetailModal');
    };

    m.style.display = 'block';
}

function updateTrashUI(){ 
    const t = getEl('trashList'); 
    const section = getEl('trashSection');
    const emptyBtn = section.querySelector('button'); // Den Button finden
    
    t.innerHTML = ''; // Liste leeren
    
    // WICHTIG: Die Bubble immer sichtbar machen (falls noch hidden gesetzt war)
    section.classList.remove('hidden');

    // FALL 1: Papierkorb ist leer
    if(trashBin.length === 0) {
        t.innerHTML = '<div style="padding:20px; text-align:center; opacity:0.6; font-size:13px; font-style:italic;">üóëÔ∏è Nichts im Papierkorb.<br>Alles sauber!</div>';
        if(emptyBtn) emptyBtn.style.display = 'none'; // Button verstecken
        return;
    }
    
    // FALL 2: Papierkorb hat Inhalt -> Button zeigen
    if(emptyBtn) emptyBtn.style.display = 'block';

    // Hilfsfunktion Zeilen-Erstellung
    const createTrashRow = (item, i) => {
        const daysLeft = item.deletedAt ? Math.ceil((30 * 86400000 - (Date.now() - item.deletedAt)) / 86400000) : 30;
        let info = item.type === 'entry' ? `${item.date}` : 'Tier';
        
        return `
        <div onclick="safeRun(openTrashDetail, ${i})" style="display:flex; justify-content:space-between; align-items:center; padding:12px; border-bottom:1px solid var(--btn); cursor:pointer; transition:background 0.2s;" onmouseover="this.style.background='var(--btn)'" onmouseout="this.style.background='transparent'">
            <div style="overflow:hidden;">
                <div style="font-weight:bold; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                    ${item.type==='entry'?'üìù':'üêæ'} ${item.name}
                </div>
                <div style="font-size:11px; opacity:0.7">
                    ${info} ‚Ä¢ noch ${daysLeft} Tage
                </div>
            </div>
            <span style="font-size:18px; color:var(--accent)">‚ÑπÔ∏è</span>
        </div>`;
    };

    // Die ersten 2 Eintr√§ge
    trashBin.slice(0, 2).forEach((item, i) => {
        t.innerHTML += createTrashRow(item, i);
    });

    // Accordion f√ºr den Rest
    if (trashBin.length > 2) {
        let hiddenRows = '';
        trashBin.slice(2).forEach((item, i) => {
            hiddenRows += createTrashRow(item, i + 2);
        });

        t.innerHTML += `
        <details style="margin-top:5px; border-top:1px solid var(--btn);">
            <summary style="padding:10px; font-size:12px; color:var(--accent); cursor:pointer; text-align:center; font-weight:bold; list-style:none;">
                üîΩ Alle anzeigen (${trashBin.length})
            </summary>
            <div style="background:rgba(0,0,0,0.02); border-radius:8px;">
                ${hiddenRows}
            </div>
        </details>
        `;
    }
}

// HELPER: Autocomplete f√ºr Orte
/* === INTELLIGENTE ORTS-SUCHE (Lokal + Web) === */

/* === INTELLIGENTE ORTS-SUCHE (Mit Untertiteln) === */
function setupLocationAutocomplete() {
    const inp = document.getElementById('noteLoc');
    const res = document.getElementById('noteLocResults');
    let osmTimer; // Timer f√ºr die Internet-Suche

    inp.oninput = (e) => {
        const val = e.target.value.trim();
        
        // Reset
        res.innerHTML = '';
        if(val.length < 2) { res.style.display='none'; return; }
        
        res.style.display = 'block';

        // 1. LOKALE SUCHE (Sofort)
        const localMatches = locations.filter(l => l.toLowerCase().includes(val.toLowerCase()));

        localMatches.forEach(l => {
            const div = document.createElement('div');
            div.className = 'suggestion-item';
            
            // Design f√ºr lokale Orte (mit "Gespeichert" Badge)
            div.innerHTML = `
                <div style="display:flex; align-items:center; gap:10px;">
                    <span style="font-size:18px;">üìç</span>
                    <div>
                        <div style="font-weight:bold; color:var(--text); font-size:14px;">${l}</div>
                        <div style="font-size:10px; color:var(--accent); font-weight:bold; opacity:0.8;">Gespeichert</div>
                    </div>
                </div>`;
            
            div.onclick = () => {
                inp.value = l;
                res.style.display = 'none';
            };
            res.appendChild(div);
        });

        // 2. WEB SUCHE (Verz√∂gert)
        clearTimeout(osmTimer);
        osmTimer = setTimeout(() => {
            if(!navigator.onLine) return;

            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&addressdetails=1&limit=4&accept-language=de`)
            .then(r => r.json())
            .then(data => {
                // Duplikate filtern (falls Ort schon lokal existiert)
                const newOsmMatches = data.filter(item => {
                    const cleanName = item.display_name.split(',')[0]; 
                    return !locations.includes(cleanName) && !locations.includes(item.display_name);
                });

                if(newOsmMatches.length > 0) {
                    // Trennlinie
                    if(localMatches.length > 0) {
                        const sep = document.createElement('div');
                        sep.style.cssText = "font-size:10px; font-weight:bold; opacity:0.5; padding:4px 12px; background:var(--bg); border-top:1px solid var(--btn); text-transform:uppercase; margin-top:5px;";
                        sep.innerText = "Aus dem Web:";
                        res.appendChild(sep);
                    }

                    newOsmMatches.forEach(item => {
                        const div = document.createElement('div');
                        div.className = 'suggestion-item';
                        
                        // Titel: Nur der Name (z.B. "Dresden")
                        const shortName = item.display_name.split(',')[0];
                        
                        // Untertitel: Der ganze Rest (z.B. "Dresden, Sachsen, Deutschland")
                        // Wir entfernen den shortName aus dem Untertitel, damit es nicht doppelt steht
                        let subText = item.display_name.replace(shortName + ", ", ""); 

                        // === HIER IST DAS NEUE DESIGN ===
                        div.innerHTML = `
                            <div style="display:flex; align-items:center; gap:10px; overflow:hidden;">
                                <span style="font-size:18px;">üåç</span>
                                <div style="flex:1; overflow:hidden;">
                                    <div style="font-weight:bold; color:var(--text); font-size:14px;">${shortName}</div>
                                    <div style="font-size:11px; color:var(--sub); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-top:2px;">
                                        ${subText}
                                    </div>
                                </div>
                            </div>`;

                        div.onclick = () => {
                            inp.value = shortName; // Wir √ºbernehmen den kurzen Namen
                            // Koordinaten speichern f√ºr die Karte
                            locCoords[shortName] = {lat:parseFloat(item.lat), lon:parseFloat(item.lon)};
                            res.style.display = 'none';
                        };
                        res.appendChild(div);
                    });
                }
            })
            .catch(err => console.log("OSM Suche fehlgeschlagen", err));
        }, 400); // 400ms warten nach Tippen
    };
    
    // Schlie√üen beim Klick woanders hin
    document.addEventListener('click', (e) => {
        if(e.target !== inp) res.style.display='none';
    });
}


// === NOTES ===
let editNoteRef = null;

async function openNoteModal(i, date=null, arrIdx=null){
    // Reset Quick Mode
    if(typeof isQuickSightingMode !== 'undefined') isQuickSightingMode = false;
    
    // UI Reset
    currentNoteImg = null; // WICHTIG: Reset
    document.getElementById('noteImgPreviewBox').style.display = 'none';
    document.getElementById('noteCamInput').value = ''; // Reset Inputs
    document.getElementById('noteGalInput').value = '';

    const titleEl = getEl('noteModalTitle');
    if(titleEl) { titleEl.innerHTML = `...`; } // (Dein HTML hier behalten)
    
    const wrapper = getEl('noteAnimalWrapper');
    if(wrapper) wrapper.style.display = 'none';

    const modal = getEl('noteModal');
    if(typeof setupLocationAutocomplete === 'function') setupLocationAutocomplete();
    
    // Bestehende Notiz bearbeiten?
    if(date && arrIdx !== null) {
        editNoteRef = { date, i, arrIdx };
        const h = getHistory(parseInt(date.split('-')[0]));
        
        if(h && h[date] && h[date].perAnimal && h[date].perAnimal[i]) {
            const entry = h[date].perAnimal[i][arrIdx];
            getEl('noteDate').value = date; 
            getEl('noteTime').value = entry.time||''; 
            getEl('noteLoc').value = entry.location||'';
            getEl('noteText').value = entry.note||'';

            // === BILD LADEN ===
            if(entry.noteImageId) {
                try {
                    const src = await dbGetImg(entry.noteImageId);
                    if(src) {
                        document.getElementById('noteImgEl').src = src;
                        document.getElementById('noteImgPreviewBox').style.display = 'block';
                        // Wir setzen currentNoteImg NICHT, damit wir beim Speichern wissen:
                        // "Null" hei√üt: Keine √Ñnderung (altes Bild behalten).
                        // Wenn User l√∂scht, wird es 'DELETE'.
                        // Wenn User neues l√§dt, wird es Base64 String.
                    }
                } catch(e) { console.log("Bildfehler", e); }
            }
        }
    } else {
        // Neue Notiz
        editNoteRef = null;
        getEl('noteDate').value = todayStr(); 
        getEl('noteTime').value = nowTimeStr();
        getEl('noteLoc').value = ''; 
        getEl('noteText').value = '';
    }
    
    // Speicher Button Logik
    getEl('noteSaveBtn').onclick = async () => { // Async machen!
        const d = getEl('noteDate').value || todayStr();
        
        // Ort Logik
        const rawLoc = getEl('noteLoc').value.trim();
        if(rawLoc && !locations.includes(rawLoc)) {
            locations.push(rawLoc);
            saveGlobals();
            if(typeof renderLocations === 'function') renderLocations();
        }

        // --- IMAGE SAVING LOGIC ---
        let finalImgId = null;

        // Fall 1: Altes Entry laden (falls Edit)
        let oldEntry = null;
        if(editNoteRef) {
             const hOld = getHistory(parseInt(editNoteRef.date.split('-')[0]));
             oldEntry = hOld[editNoteRef.date].perAnimal[editNoteRef.i][editNoteRef.arrIdx];
             finalImgId = oldEntry.noteImageId || null;
        }

        // Fall 2: √Ñnderungen verarbeiten
        if(currentNoteImg === 'DELETE') {
            // User hat X gedr√ºckt
            if(finalImgId) await dbDelImg(finalImgId);
            finalImgId = null;
        } else if (currentNoteImg) {
            // Neues Bild wurde gew√§hlt
            if(finalImgId) await dbDelImg(finalImgId); // Altes l√∂schen
            finalImgId = 'note_img_' + Date.now();
            await dbSaveImg(finalImgId, currentNoteImg);
        }
        // Fall 3: currentNoteImg ist null -> Altes Bild (finalImgId) bleibt erhalten

        const data = { 
            time: getEl('noteTime').value, 
            location: rawLoc, 
            note: getEl('noteText').value,
            noteImageId: finalImgId // ID speichern!
        };
        
        // Alten Eintrag l√∂schen
        if(editNoteRef) removeEntry(editNoteRef.date, editNoteRef.i, editNoteRef.arrIdx);
        else playSound('pop');
        
        // Speichern
        writeEntry(d, i, data);
        
        closeModal('noteModal');
        if(getEl('detailModal').style.display === 'block') updateDetailChart();
        render();
    };
    
    modal.style.display='block';
}


/* === VIEW NOTE DETAIL (Updated: Mit Bild) === */
async function viewNoteDetail(animalIdx, dateStr, arrIdx) {
    const h = getHistory(parseInt(dateStr.split('-')[0]));
    
    if (h && h[dateStr] && h[dateStr].perAnimal && h[dateStr].perAnimal[animalIdx]) {
        const entry = h[dateStr].perAnimal[animalIdx][arrIdx];
        
        // 1. Textdaten f√ºllen
        const displayDate = dateStr.split('-').reverse().join('.');
        getEl('nvDate').innerText = displayDate;
        getEl('nvLoc').innerText = entry.location ? `üìç ${entry.location}` : '';
        getEl('nvText').innerText = entry.note || "Keine Notiz.";
        
        // 2. BILD LADEN (NEU)
        const imgEl = getEl('nvHeroImg');
        if (entry.noteImageId) {
            try {
                const src = await dbGetImg(entry.noteImageId);
                if (src) {
                    imgEl.src = src;
                    imgEl.style.display = 'block'; // Bild anzeigen
                    
                    // Helper f√ºr Lightbox speichern (damit onclick funktioniert)
                    imgEl.dataset.fullSrc = src; 
                } else {
                    imgEl.style.display = 'none';
                }
            } catch (e) { console.log(e); imgEl.style.display = 'none'; }
        } else {
            imgEl.style.display = 'none'; // Kein Bild -> Ausblenden
        }

        // 3. Edit Button konfigurieren
        getEl('nvEditBtn').onclick = function() {
            closeModal('noteViewModal');
            setTimeout(() => {
                openNoteModal(animalIdx, dateStr, arrIdx);
            }, 200);
        };
        
        // Anzeigen
        getEl('noteViewModal').style.display = 'block';
    }
}

// Helper f√ºr die Lightbox direkt aus der Notiz
function openLightboxFromNote() {
    const src = getEl('nvHeroImg').dataset.fullSrc;
    if(src) openImageLightbox(src);
}



// === EDIT ANIMAL (NAME, ICON, TAGS, IMAGE) ===
let editIconIdx = null; 
let editIconTemp = null;

async function openIconEdit(i){
    editIconIdx = i; 
    editIconTemp = null;
    const a = animals[i];
    
    // Werte laden
    getEl('editName').value = a.name; // NEU: Name laden
    getEl('editEmoji').value = a.emoji;
    getEl('editTag').value = (a.tags||[]).join(', ');
    
    // Bild Vorschau laden
    const prev = getEl('editPreviewImg');
    const container = getEl('editPreviewContainer');
    
    if(a.imageId) {
        const src = await dbGetImg(a.imageId);
        if(src) {
            prev.src = src;
            container.style.display = 'block';
        } else {
            container.style.display = 'none';
        }
    } else { 
        container.style.display = 'none'; 
    }
    
    getEl('iconModal').style.display='block';
}



function handleEditFile(input){
    if(input.files[0]) {
        const reader = new FileReader();
        reader.onload = e => resizeImage(e.target.result, 800, res => { editIconTemp = res; getEl('editPreviewImg').src = res; getEl('editPreviewContainer').style.display='block'; });
        reader.readAsDataURL(input.files[0]);
    }
}
async function removeEditImage(){ editIconTemp = 'DELETE'; getEl('editPreviewContainer').style.display='none'; }


async function saveIconEdit(){
    if(editIconIdx === null) return;
    const a = animals[editIconIdx];
    
    // 1. Name speichern
    const newName = getEl('editName').value.trim();
    if(newName) a.name = newName;
    
    // 2. Rest speichern
    a.emoji = getEl('editEmoji').value || 'üêæ';
    a.tags = getEl('editTag').value.split(',').map(s=>s.trim()).filter(s=>s);
    
    // 3. Bild Logik
    if(editIconTemp === 'DELETE') { 
        if(a.imageId) await dbDelImg(a.imageId); 
        a.imageId = null; 
    }
    else if(editIconTemp) { 
        if(a.imageId) await dbDelImg(a.imageId); 
        const newId = 'img_' + Date.now(); 
        await dbSaveImg(newId, editIconTemp); 
        a.imageId = newId; 
    }
    
    saveGlobals(); 
    render(); 
    updateStorageUI(); 
    
    // 1. Modal schlie√üen (nur das Bearbeiten-Fenster)
    closeModal('iconModal');
    
    // 2. CHECK: Ist Detailansicht offen? Dann KOMPLETT neu laden (f√ºr neuen Namen/Bild)
    if(getEl('detailModal').style.display === 'block') {
        openDetail(editIconIdx); // Ruft die Funktion neu auf -> Header & Bild aktualisieren sich
    }
    
    showErrorToast("√Ñnderungen gespeichert", true);
}

function quickCreate(name) {
    if(!name) return;
    
    // Tier anlegen (Kategorie leer lassen -> User sieht das sp√§ter)
    animals.push({ 
        name: name, 
        emoji: 'üêæ', 
        imageId: null, 
        tags: [], // Noch keine Tags
        isFav: false 
    });
    
    saveGlobals();
    getEl('listSearch').value = ''; // Suche leeren
    global
    showErrorToast(`"${name}" angelegt!`, true);
    
    // Wir rendern neu
    render();
    
    // OPTIONAL: Wir √∂ffnen direkt das Bearbeiten Fenster, 
    // falls du es SOFORT kategorisieren willst.
    // Wenn du das NICHT willst (wegen Schnelligkeit), kommentiere die n√§chste Zeile aus:
    // openIconEdit(animals.length - 1); 
}



function exportCSV() {
    let csv = "Datum;Uhrzeit;Tier;Ort;Notiz\n";
    getAvailableYears().forEach(y => {
        const h = getHistory(y);
        Object.entries(h).forEach(([d, val]) => {
             if(val.perAnimal) Object.entries(val.perAnimal).forEach(([idx, list]) => {
                 const name = animals[idx]?.name || 'Unknown';
                 list.forEach(item => csv += `${d};${item.time};"${name}";"${item.location||''}";"${item.note||''}"\n`);
             });
        });
    });
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'tiere-export.csv'; a.click();
}

// === MAP & STATS ===


function renderStats(){
    const ct = getEl('statsContent'); 
    const ys = getAvailableYears(); 
    const sel = getEl('statsYearSelect');
    
    // Dropdown f√ºllen falls leer
    if(sel.options.length !== ys.length) {
        sel.innerHTML = ys.map(y => `<option value="${y}" ${y===currentSystemYear?'selected':''}>${y}</option>`).join('');
    }
    
    const sYr = parseInt(sel.value) || currentSystemYear;
    
    // 1. GLOBALE STATS (F√ºr Level & XP - √ºber ALLE Jahre)
    let gTot=0, gNote=0, gLoc=new Set(), streak=0;
    ys.forEach(y => {
        const h = getHistory(y); 
        Object.values(h).forEach(e => {
            gTot += (e.total||0); 
            if(e.perAnimal) Object.values(e.perAnimal).forEach(l => l.forEach(x => {
                if(x.note) gNote++;
                if(x.location) gLoc.add(x.location);
            }));
        });
    });
    
    // 2. JAHRES STATS (F√ºr das gew√§hlte Jahr sYr)
    const th = getHistory(sYr);
    let yTot = 0, yWk = 0, yDistinct = new Set();
    let time = { Morgens:0, Mittags:0, Abends:0, Nachts:0 };
    let mCounts = new Array(12).fill(0);
    let animalCounts = {}; // { animalIndex: count }

    Object.entries(th).forEach(([dStr, e]) => {
        yTot += e.total; 
        mCounts[new Date(dStr).getMonth()] += e.total; 
        if([0,6].includes(new Date(dStr).getDay())) yWk += e.total;
        
        if(e.perAnimal) {
            Object.entries(e.perAnimal).forEach(([k, l]) => { 
                const idx = parseInt(k);
                const aName = animals[idx]?.name || '???';
                yDistinct.add(aName); 
                
                // F√ºr Top 3 z√§hlen
                animalCounts[idx] = (animalCounts[idx] || 0) + l.length;

                l.forEach(x => {
                    if(x.time){
                        const h = parseInt(x.time); 
                        if(h>=5 && h<11) time.Morgens++;
                        else if(h>=11 && h<14) time.Mittags++;
                        else if(h>=14 && h<22) time.Abends++;
                        else time.Nachts++;
                    }
                }); 
            });
        }
    });

    // 3. LEVEL BERECHNUNG & DESIGN
    const photo = animals.some(a => a.imageId);
    // Streak Berechnung
    const dates = Object.keys(th).sort((a,b) => new Date(b)-new Date(a));
    if(dates.length){ 
        const dh = (new Date(todayStr())-new Date(dates[0]))/36e5; 
        if(dh <= 48){
            streak = 1;
            for(let i=0; i<dates.length-1; i++) {
                if(Math.round((new Date(dates[i])-new Date(dates[i+1]))/864e5)===1) streak++; else break;
            }
        }
    }

    // DIESE ZEILE EINF√úGEN:
const xp = calculateTotalXP();

    // Level Logik
    let lvl = levels[0], nxt = null; 
    let lvlIdx = 0;
    for(let i=0; i<levels.length; i++){ 
        if(xp >= levels[i].xp){ lvl = levels[i]; lvlIdx = i; } 
        else { nxt = levels[i]; break; }
    }
    const pct = nxt ? Math.min(((xp-lvl.xp)/(nxt.xp-lvl.xp))*100,100) : 100;

   // --- DESIGN & ICON W√ÑHLEN (5 ZONEN) ---
    let rankClass = 'rank-garden'; // Default
    let rankIcon = 'üêû'; 

    // Zone 1: Garten (Level 1-4)
    if (lvlIdx < 4) {
        rankClass = 'rank-garden';
        if(lvlIdx >= 2) rankIcon = 'ü¶î'; // Igel ab Lvl 3
    }
    // Zone 2: Wald (Level 5-8)
    else if (lvlIdx >= 4 && lvlIdx < 8) {
        rankClass = 'rank-forest';
        rankIcon = 'üå≤'; 
        if(lvlIdx >= 6) rankIcon = 'ü¶â'; // Eule ab Lvl 7
    }
    // Zone 3: Wasser (Level 9-12)
    else if (lvlIdx >= 8 && lvlIdx < 12) {
        rankClass = 'rank-water';
        rankIcon = 'üê∏';
        if(lvlIdx >= 10) rankIcon = 'üê¨'; // Delfin ab Lvl 11
    }
    // Zone 4: Savanne (Level 13-16)
    else if (lvlIdx >= 12 && lvlIdx < 16) {
        rankClass = 'rank-savanna';
        rankIcon = 'üêí';
        if(lvlIdx >= 14) rankIcon = 'ü¶Å'; // L√∂we ab Lvl 15
    }
    // Zone 5: Legende (Level 17-20)
    else {
        rankClass = 'rank-legend';
        rankIcon = 'ü¶Ö';
        if(lvlIdx >= 18) rankIcon = 'üê∫'; // Wolf ab Lvl 19
        if(lvlIdx === 19) rankIcon = 'üëë'; // Krone f√ºr Max Level
    }

    // --- HTML ZUSAMMENBAUEN ---
    
// === NEU: DASHBOARD BUTTON JETZT HIER (Zwischen KPI und Top 3) ===
    
    // Heutigen Count berechnen
    const todayKeyForStats = new Date().toISOString().slice(0,10);
    const todayCountStats = getHistory(currentSystemYear)[todayKeyForStats]?.total || 0;

    let html = `
    <div class="dashboard-hero-stats" onclick="safeRun(openTodayModal)">
      <div>
        <h2 style="margin:0; font-size: 28px; font-weight: 900;" id="heroCountStats">${todayCountStats}</h2>
        <p style="margin:0; opacity: 0.9; font-size: 13px; font-weight:bold;">Tiere heute entdeckt</p>
      </div>
      <div style="font-size: 24px; background:rgba(255,255,255,0.2); width:40px; height:40px; border-radius:50%; display:flex; align-items:center; justify-content:center;">‚ûî</div>
    </div>`;
    // === ENDE NEUER BUTTON ===



    // 1. Die neue Level Karte

html += ` 
  <div class="level-card fade-in ${rankClass}">
        <div class="lvl-header">
            <span>Level ${lvlIdx + 1}</span>
            <span>${xp} XP</span>
        </div>
        <div class="lvl-icon-big">${rankIcon}</div>
        <div class="lvl-name">${lvl.name}</div>
        <div class="lvl-progress-container">
            <div class="lvl-bar-bg">
                <div class="lvl-bar-fill" style="width:${pct}%"></div>
            </div>
            <div class="lvl-stats-text">
                <span>Aktuell</span>
                <span>${nxt ? (nxt.xp - xp) + ' bis Aufstieg' : 'MAX LEVEL'}</span>
            </div>
        </div>
    </div>`;
    
// ... (Dein Code davor bleibt gleich) ...

 // === 2. LEVEL ROADMAP (Timeline Style) ===
    // Wir bauen die Zeilen dynamisch als Bubbles
    const roadmapItems = levels.map((l, i) => {
        let zoneClass = 'rm-garden';
        let zoneIcon = 'üêû'; 

        // Zonen-Logik
        if (i < 4) { zoneClass = 'rm-garden'; zoneIcon = 'üêû'; }
        else if (i < 8) { zoneClass = 'rm-forest'; zoneIcon = 'üå≤'; }
        else if (i < 12) { zoneClass = 'rm-water'; zoneIcon = 'üê¨'; }
        else if (i < 16) { zoneClass = 'rm-savanna'; zoneIcon = 'ü¶Å'; }
        else { zoneClass = 'rm-legend'; zoneIcon = 'üëë'; }

        // Aktuelles Level markieren
        const isCurrent = (i === lvlIdx);
        const activeClass = isCurrent ? 'active' : '';
        const displayIcon = isCurrent ? 'üìç' : zoneIcon; 
        const opacity = i > lvlIdx ? '0.5' : '1'; // Zuk√ºnftige Levels leicht ausblenden

        return `
        <div class="roadmap-item ${zoneClass} ${activeClass}" style="opacity:${opacity}">
            <div class="roadmap-dot"></div>
            <div style="font-size:20px;">${displayIcon}</div>
            <div style="display:flex; flex-direction:column;">
                <span style="font-weight:bold; font-size:13px;">${l.name}</span>
                <span style="font-size:10px; opacity:0.7;">Level ${i+1}</span>
            </div>
            <div class="roadmap-xp">${l.xp.toLocaleString()} XP</div>
        </div>`;
    }).join('');

    // Akkordeon Container f√ºr die Roadmap
    html += `
    <details style="margin-bottom:25px; border:1px solid rgba(0,0,0,0.05); border-radius:24px; padding:15px; background:var(--card); box-shadow:var(--shadow);">
        <summary style="font-weight:800; color:var(--text); cursor:pointer; list-style:none; display:flex; align-items:center; gap:10px;">
            <span style="font-size:20px;">üó∫Ô∏è</span> Deine Reise-Route <span style="opacity:0.5; font-weight:normal; font-size:12px; margin-left:auto;">(Alle Level) ‚ñº</span>
        </summary>
        <div class="roadmap-container">
            <div class="roadmap-line"></div>
            ${roadmapItems}
        </div>
    </details>`;

    if(gTot === 0) { ct.innerHTML = html+'<div style="text-align:center">Noch keine Daten.</div>'; return; }

    // === 3. NEUE KPI BUBBLES (Grid) ===
    html += `
    <div class="kpi-grid">
        <!-- Sichtungen (Blau) -->
        <div class="kpi-bubble kpi-blue">
            <div class="kpi-icon">üëÅÔ∏è</div>
            <!-- HIER GE√ÑNDERT: ID hinzugef√ºgt und Startwert 0 -->
            <div class="kpi-val" id="kpi-stat-total">0</div>
            <div class="kpi-label">Sichtungen</div>
        </div>
        
        <!-- Arten (Gr√ºn) -->
        <div class="kpi-bubble kpi-green">
            <div class="kpi-icon">üß¨</div>
            <!-- HIER GE√ÑNDERT: ID hinzugef√ºgt und Startwert 0 -->
            <div class="kpi-val" id="kpi-stat-species">0</div>
            <div class="kpi-label">Arten</div>
        </div>
        
        <!-- Streak (Orange) -->
        <div class="kpi-bubble kpi-orange">
            <div class="kpi-icon">üî•</div>
            <!-- HIER GE√ÑNDERT: ID hinzugef√ºgt und Startwert 0 -->
            <div class="kpi-val" id="kpi-stat-streak">0</div>
            <div class="kpi-label">Tage Streak</div>
        </div>
        
        <!-- Aktivste Zeit (Lila) - Bleibt Text, daher kein Tacho -->
        <div class="kpi-bubble kpi-purple">
            <div class="kpi-icon">‚åö</div>
            <div class="kpi-val" style="font-size:18px; margin-top:4px;">
                ${Object.entries(time).sort((a,b)=>b[1]-a[1])[0]?.[0] || '-'}
            </div>
            <div class="kpi-label">Top Zeit</div>
        </div>
    </div>`;


    // 4. TOP 3 (Deine Logik, beibehalten)
    const sortedTop = Object.entries(animalCounts)
        .map(([idx, count]) => ({ idx: parseInt(idx), count }))
        .sort((a,b) => b.count - a.count)
        .slice(0, 3); 

    if(sortedTop.length > 0) {
        const medals = ['ü•á', 'ü•à', 'ü•â'];
        const maxVal = sortedTop[0].count; 
        html += `<div class="card-section"><h3>üèÜ Top 3 Lieblinge (${sYr})</h3><div class="top3-container">`;
        sortedTop.forEach((item, rank) => {
            const a = animals[item.idx];
            if(!a) return;
            const percent = (item.count / maxVal) * 100;
            const imgId = `stat-top3-${item.idx}-${sYr}`;
            html += `<div class="top3-row"><div class="top3-bar" style="width:${percent}%"></div><div class="top3-medal">${medals[rank]}</div><div class="top3-img" id="${imgId}">${a.emoji}</div><div class="top3-info"><span>${a.name}</span><span class="top3-count">${item.count}</span></div></div>`;
            if(a.imageId) { dbGetImg(a.imageId).then(src => { const el = document.getElementById(imgId); if(src && el) { el.innerHTML = `<img src="${src}">`; el.style.border = "none"; } }); }
        });
        html += `</div></div>`;
    }

    // 5. TROPH√ÑEN
    const badges=[
          {i:'üê£',n:'Starter',c:gTot>=1},{i:'ü•â',n:'Sammler',c:gTot>=50},{i:'ü•à',n:'Profi',c:gTot>=100},{i:'üëë',n:'Legende',c:gTot>=250},{i:'ü™ê',n:'Titan',c:gTot>=1000},
          {i:'üî•',n:'On Fire',c:streak>=3},{i:'‚ö°',n:'Marathon',c:streak>=7},{i:'üìÖ',n:'Weekend',c:yWk>0},{i:'üç±',n:'Mittag',c:time.Mittags>0},
          {i:'üåà',n:'Arche',c:yDistinct.size>=10},{i:'üß¨',n:'Darwin',c:yDistinct.size>=25},{i:'üåç',n:'Entdecker',c:gLoc.size>=3},
          {i:'üó∫Ô∏è',n:'Globe',c:gLoc.size>=10},{i:'üì∏',n:'Paparazzi',c:photo},{i:'ü¶â',n:'Nachteule',c:time.Nachts>0},{i:'üêì',n:'Fr√ºh',c:time.Morgens>0}
    ];
    html += `<div class="card-section"><h3>üèÜ Troph√§en</h3><div class="badge-grid">`+badges.map(b=>`<div class="badge ${b.c?'earned':''}"><span class="badge-icon">${b.i}</span> ${b.n}</div>`).join('')+`</div></div>`;
    
    // 6. TAGESZEITEN
    const maxT = Math.max(...Object.values(time), 1);
    html += `<div class="card-section"><h3>‚è±Ô∏è Tageszeiten</h3>`+Object.entries(time).map(([l,v])=>`<div class="hbar-row"><div class="hbar-label" style="width:80px">${l}</div><div class="hbar-track"><div class="hbar-fill" style="width:${(v/maxT)*100}%;opacity:0.8"></div></div><div class="hbar-val">${v}</div></div>`).join('')+`</div>`;
    
    // 7. JAHRES CHART
    html += `<div class="card-section"><h3>üóìÔ∏è Jahr ${sYr}</h3><div class="chart-wrap">`+mCounts.map((v,i)=>`<div class="chart-col"><div class="chart-bar" style="height:${v?(v/Math.max(...mCounts))*100:1}%;opacity:${v?1:0.1}"></div><div class="chart-label">${['J','F','M','A','M','J','J','A','S','O','N','D'][i]}</div></div>`).join('')+`</div></div>`;
    
  
// === 8. HEATMAP (Kalender-orientiert) ===
    
    // 1. FEHLENDE DEFINITION WIEDER EINGEF√úGT:
    // Wenn aktuelles Jahr gew√§hlt: Heute. Wenn vergangenes Jahr: 31. Dezember.
    let refDate = (sYr === currentSystemYear) ? new Date() : new Date(sYr, 11, 31);
    
    const today = new Date(refDate);
    const dayOfWeek = today.getDay(); // 0 (So) - 6 (Sa)
    
    // JS: Sonntag ist 0, wir wollen Montag als Start (0). 
    const daysSinceMonday = (dayOfWeek + 6) % 7;
    
    // Startdatum berechnen (Der Montag vor ca. 4 Wochen)
    const startDate = new Date(today);
    startDate.setDate(today.getDate() - (28 + daysSinceMonday));

    // HTML Header
    html += `
    <div class="card-section">
        <h3>üî• Aktivit√§t (30 Tage)</h3>
        <div class="heatmap-container">
            <!-- Wochentage Header -->
            <div class="heatmap-weekdays">
                <div class="heatmap-day-label">Mo</div>
                <div class="heatmap-day-label">Di</div>
                <div class="heatmap-day-label">Mi</div>
                <div class="heatmap-day-label">Do</div>
                <div class="heatmap-day-label">Fr</div>
                <div class="heatmap-day-label">Sa</div>
                <div class="heatmap-day-label">So</div>
            </div>
            
            <div class="heatmap-grid" id="heatmapGrid">`;

    // Zellen generieren (5 Wochen = 35 Zellen)
    for (let i = 0; i < 35; i++) { 
        const d = new Date(startDate);
        d.setDate(startDate.getDate() + i + 1); 
        
        const iso = d.toISOString().slice(0,10);
        const isFuture = d > today;
        
        if (isFuture) {
            // Leere Zellen f√ºr die Zukunft
            html += `<div class="heat-cell" style="background:transparent; cursor:default;"></div>`;
        } else {
            const count = getHistory(d.getFullYear())[iso]?.total || 0;
            const isToday = (iso === todayStr());
            
            // Farbe berechnen
            let bg = 'var(--btn)';
            if(count > 0) bg = `rgba(33, 150, 243, ${Math.min(count*0.25 + 0.2, 1)})`; 
            
            // Info Text vorbereiten
            const dayName = d.toLocaleDateString('de-DE', { weekday:'short', day:'2-digit', month:'2-digit' });
            
            html += `
            <div class="heat-cell ${isToday?'is-today':''}" 
                 style="background:${bg}; color:${count>0?'#ffffff':'transparent'}; text-shadow:0 1px 2px rgba(0,0,0,0.3); font-weight:bold;"
                 onclick="showHeatmapInfo(this, '${dayName}', ${count})">
                 ${count || ''}
            </div>`;
        }
    }

    html += `
            </div>
            <!-- Hier erscheint der Text beim Klicken -->
            <div id="heatmapInfoText" class="heatmap-info-line">Tippe auf einen Tag üëÜ</div>
        </div>
    </div>`;
    
    ct.innerHTML = html;
    
    // === ANIMATION STARTEN (TACHO EFFEKT) ===
    // Wir warten 50ms, damit der Browser das HTML erst mal "malen" kann
    setTimeout(() => {
        // Pr√ºfen ob die animateValue Funktion existiert (die haben wir vorhin angelegt)
        if(typeof animateValue === 'function') {
            // Von 0 auf den Zielwert in 1500ms
            animateValue(document.getElementById('kpi-stat-total'), 0, yTot, 1500);
            animateValue(document.getElementById('kpi-stat-species'), 0, yDistinct.size, 1500);
            animateValue(document.getElementById('kpi-stat-streak'), 0, streak, 1500);
      if(document.getElementById('heroCountStats')) {
    animateValue(document.getElementById('heroCountStats'), 0, todayCountStats, 1000);
}

  } else {
            // Fallback, falls die Animation-Funktion fehlt: Werte direkt setzen
            if(document.getElementById('kpi-stat-total')) document.getElementById('kpi-stat-total').innerText = yTot;
            if(document.getElementById('kpi-stat-species')) document.getElementById('kpi-stat-species').innerText = yDistinct.size;
            if(document.getElementById('kpi-stat-streak')) document.getElementById('kpi-stat-streak').innerText = streak;
        }
    }, 50);

} // Ende der Funktion renderStats
    

/* === ULTIMATE SHARE CARD GENERATOR (V2) === */
async function generateShareCard() {
    showErrorToast("üé® Erstelle Grafik...", true); // Feedback geben

    // 1. SETUP & DATEN
    const width = 800;
    const height = 1200;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    const year = parseInt(getEl('statsYearSelect').value) || currentSystemYear;
    const h = getHistory(year);
    
    // Daten berechnen (Gesamt & Top 1)
    let total = 0;
    let counts = {}; // { animalIndex: count }
    
    Object.entries(h).forEach(([date, d]) => {
        total += d.total || 0;
        if(d.perAnimal) {
            Object.entries(d.perAnimal).forEach(([idx, list]) => {
                counts[idx] = (counts[idx] || 0) + list.length;
            });
        }
    });

    // Top 1 finden
    let topAnimal = null;
    let topCount = 0;
    const sortedIdx = Object.keys(counts).sort((a,b) => counts[b] - counts[a]);
    if(sortedIdx.length > 0) {
        topAnimal = animals[parseInt(sortedIdx[0])];
        topCount = counts[sortedIdx[0]];
    }

    // Level berechnen (f√ºr den Header)
    // Wir nutzen hier eine vereinfachte XP Rechnung nur f√ºr die Karte, 
    // oder holen uns die XP global, falls verf√ºgbar.
    // Wir nehmen hier einfach den "Rang Titel" basierend auf der Total-Zahl (Quick Hack)
    // oder besser: Wir berechnen kurz die echten XP wie in renderStats.
    // (Hier gek√ºrzt auf Basis von Total f√ºr Geschwindigkeit):
    const titleText = `Mein Tierjahr ${year}`;

    // 2. HINTERGRUND (Modern Gradient)
    const grad = ctx.createLinearGradient(0, 0, width, height);
    grad.addColorStop(0, '#2b1055'); // Dunkel Lila
    grad.addColorStop(1, '#7597de'); // Hellblau
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);

    // Partikel im Hintergrund (Sterne/Glitzer)
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    for(let i=0; i<40; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        const r = Math.random() * 4;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    }

    // 3. GLAS-CARD (Container in der Mitte)
    const cardX = 50, cardY = 150, cardW = 700, cardH = 900;
    ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 30; ctx.shadowOffsetY = 20;
    
    // Rounded Rect Helper
    roundRect(ctx, 50, 100, 700, 1000, 40); 
    ctx.fill();
    ctx.shadowBlur = 0; ctx.shadowOffsetY = 0; // Reset Shadow

    // 4. TEXTE & INHALT
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffffff';

    // Header
    ctx.font = 'bold 40px sans-serif';
    ctx.fillText("TIER TICKER üêæ", width/2, 180);
    ctx.font = '30px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillText(titleText, width/2, 230);

    // TOTAL COUNT (Riesig)
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 180px sans-serif';
    ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 10;
    ctx.fillText(total, width/2, 450);
    ctx.shadowBlur = 0;
    
    ctx.font = '30px sans-serif';
    ctx.fillStyle = '#4cd137'; // Gr√ºn
    ctx.fillText("GESAMT SICHTUNGEN", width/2, 500);

    // TRENNLINIE
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(150, 560); ctx.lineTo(650, 560); ctx.stroke();

    // 5. TOP 1 TIER (MVP)
    if(topAnimal) {
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.font = 'bold 35px sans-serif';
        ctx.fillText("üèÜ MEIST ENTDECKT", width/2, 620);

        const imgY = 670;
        const imgSize = 220;
        
        // Versuchen Bild zu laden
        let imgDrawn = false;
        if(topAnimal.imageId) {
            try {
                const src = await dbGetImg(topAnimal.imageId);
                if(src) {
                    const img = new Image();
                    img.src = src;
                    await new Promise(r => img.onload = r);
                    
                    // Bild Rund ausschneiden
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(width/2, imgY + imgSize/2, imgSize/2, 0, Math.PI*2);
                    ctx.closePath();
                    ctx.clip();
                    
                    // Bild zeichnen & skalieren (Cover fit)
                    const scale = Math.max(imgSize/img.width, imgSize/img.height);
                    const x = (width/2) - (img.width/2) * scale;
                    const y = (imgY + imgSize/2) - (img.height/2) * scale;
                    ctx.drawImage(img, x, y, img.width*scale, img.height*scale);
                    
                    // Goldener Rand
                    ctx.beginPath();
                    ctx.arc(width/2, imgY + imgSize/2, imgSize/2, 0, Math.PI*2);
                    ctx.lineWidth = 10; ctx.strokeStyle = "#ffd700"; ctx.stroke();
                    
                    ctx.restore();
                    imgDrawn = true;
                }
            } catch(e) { console.log("Bildfehler", e); }
        }

        // Fallback Emoji (wenn kein Bild oder Fehler)
        if(!imgDrawn) {
            ctx.font = '150px serif';
            ctx.fillText(topAnimal.emoji, width/2, imgY + 160);
        }

        // Name & Count des Top Tiers
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 50px sans-serif';
        ctx.fillText(topAnimal.name, width/2, 960);
        
        ctx.fillStyle = '#ffd700'; // Gold
        ctx.font = 'bold 40px sans-serif';
        ctx.fillText(`${topCount} mal gesehen`, width/2, 1020);
    } else {
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '30px sans-serif';
        ctx.fillText("Noch keine Favoriten...", width/2, 800);
    }

    // FOOTER
    ctx.font = '20px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fillText("Erstellt mit Tier Ticker App", width/2, 1150);

    // DOWNLOAD
    //const link = document.createElement('a');
   // link.download = `TierTicker-Share-${year}.png`;
   // link.href = canvas.toDataURL('image/png');
    //link.click();

// ... (Canvas Code wie gehabt) ...

    // STATT DOWNLOAD -> NATIVE SHARE
    canvas.toBlob(async (blob) => {
        const file = new File([blob], "tier-stats.png", { type: "image/png" });
        
        // Pr√ºfen, ob der Browser echtes Teilen unterst√ºtzt
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
            try {
                await navigator.share({
                    title: 'Mein Tier-Ticker Jahr',
                    text: `Ich habe dieses Jahr ${total} Tiere gesehen! üêæ #TierTicker`,
                    files: [file]
                });
                showErrorToast("Erfolgreich geteilt! üöÄ", true);
            } catch (err) {
                console.log("Teilen abgebrochen", err);
            }
        } else {
            // Fallback: Alter Download
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "tier-stats.png";
            a.click();
            showErrorToast("Bild gespeichert (Teilen nicht verf√ºgbar)", true);
        }
    });
}


// Helper f√ºr runde Ecken im Canvas
function roundRect(ctx, x, y, w, h, r) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

// === NOTIFICATIONS & UTILS ===
function saveNotifySettings(){
    notifyConfig.enabled = getEl('notifyToggle').checked;
    notifyConfig.days = parseInt(getEl('notifyDays').value) || 7;
    localStorage.setItem('notifyConfig', JSON.stringify(notifyConfig));
    showErrorToast("Einstellungen gespeichert", true); closeModal('notifyModal');
}
function testNotification(){
    if (Notification.permission === "granted") new Notification("Tier Ticker", { body: "Test-Erinnerung: Zeit zu z√§hlen! üêæ" });
    else if (Notification.permission !== "denied") Notification.requestPermission().then(p => { if (p === "granted") new Notification("Test", { body: "Erinnerungen aktiviert." }); });
}
function downloadICS() {
    let ics = "BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//TierTracker//DE\nBEGIN:VEVENT\nSUMMARY:Tiere z√§hlen üêæ\nRRULE:FREQ=" + getEl('icsFreq').value + (getEl('icsFreq').value==='WEEKLY' ? ";BYDAY="+getEl('icsDay').value : "") + "\nDTSTART:" + todayStr().replace(/-/g,'') + "T" + getEl('icsTime').value.replace(':','') + "00\nDURATION:PT15M\nDESCRIPTION:Zeit deine Beobachtungen einzutragen!\nEND:VEVENT\nEND:VCALENDAR";
    const a = document.createElement('a'); a.href = 'data:text/calendar;charset=utf-8,' + encodeURIComponent(ics); a.download = 'tiere-erinnerung.ics'; a.click();
}

function toggleDarkMode(){ dark=!dark; localStorage.setItem('darkmode',dark); document.body.classList.toggle('dark', dark); }
function switchView(id, btn){
    document.querySelectorAll('.view-section').forEach(e=>e.classList.remove('active')); getEl(id).classList.add('active');
    document.querySelectorAll('.nav-item').forEach(e=>e.classList.remove('active')); if(btn) btn.classList.add('active');
    if(id==='view-map') setTimeout(initMapWithTimeTravel, 200); if(id==='view-stats') renderStats(); refreshSolarData();
}
function toggleInfo(){ const b = getEl('infoBox'); b.style.display = b.style.display==='none'?'block':'none'; }

// === SETTINGS & TOGGLES ===

// √ñffnet das neue zentrale Einstellungs-Men√º
function openSettings(){ 
    const modal = getEl('notifyModal');
    
    // 1. Dark Mode Status setzen
    const darkBox = getEl('settingDarkToggle');
    if(darkBox) darkBox.checked = dark;

    // 2. Kompakt Modus Status setzen
    const compactBox = getEl('compactToggle');
    if(compactBox) compactBox.checked = isCompact;

    // 3. Mute Status setzen
    const muteBox = getEl('settingMuteToggle');
    if(muteBox) muteBox.checked = isMuted;

    // 4. Notification Settings laden
    getEl('notifyToggle').checked = notifyConfig.enabled;
    getEl('notifyDays').value = notifyConfig.days;

    modal.style.display='block'; 
}

// Neue Funktion f√ºr den Mute-Switch im Men√º
function toggleMuteState() {
    isMuted = !isMuted;
    localStorage.setItem('muted', isMuted);
    // Kein Button-Text Update mehr n√∂tig, da Switch
}

// Die bestehende toggleDarkMode Funktion bleibt, 
// sie wird jetzt vom Switch im Modal aufgerufen.
// Schlie√üt Modals und gibt das Scrollen wieder frei
function closeModal(id){ 
    getEl(id).style.display='none';
    document.body.classList.remove('no-scroll'); // Scrollen wieder erlauben
    
    // Position vom Body fix l√∂sen (optional, falls es springt, kann man das verfeinern)
    // Aber meistens reicht das Entfernen der Klasse.
}

async function hardReset(){ 
    if(confirm("ALLES L√ñSCHEN?\n\nDeine Tiere und Bilder werden gel√∂scht.\nDeine Cloud-Sync-Keys bleiben erhalten.")) { 
        // 1. Keys retten
        const savedChannels = localStorage.getItem('tier_sync_channels');
        const savedActiveId = localStorage.getItem('tier_active_sync_id');

        // 2. LocalStorage leeren
        localStorage.clear(); 

        // 3. Keys wiederherstellen
        if(savedChannels) localStorage.setItem('tier_sync_channels', savedChannels);
        if(savedActiveId) localStorage.setItem('tier_active_sync_id', savedActiveId);

        // 4. Datenbanken killen
        const db = await dbPromise;
        const tx = db.transaction([STORE_IMGS, STORE_DECKS], 'readwrite');
        tx.objectStore(STORE_IMGS).clear();
        tx.objectStore(STORE_DECKS).clear();
        
        try {
            const rfDb = await rfDbPromise;
            const txRf = rfDb.transaction(RF_STORE, 'readwrite');
            txRf.objectStore(RF_STORE).clear();
        } catch(e) {}

        location.reload(); 
    } 
}

// === GPS ===
function locateMe(){
    if(!navigator.geolocation) return showErrorToast("Kein GPS");
    showErrorToast("Suche Position...", true);
    navigator.geolocation.getCurrentPosition(p => {
        fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${p.coords.latitude}&lon=${p.coords.longitude}&zoom=18`)
        .then(r=>r.json()).then(d => {
            const name = (d.address.road || d.address.village || d.address.city || "Ort");
            getEl('osmInput').value = name; locCoords[name] = {lat:p.coords.latitude, lon:p.coords.longitude};
        }).catch(()=>showErrorToast("Ort nicht gefunden"));
    });
}

function addManualLocation(){ 
    const v = getEl('osmInput').value; 
    if(v && !locations.includes(v)) { 
        locations.push(v); 
        saveGlobals(); 
        
        renderLocations(); // <--- HIER GE√ÑNDERT (statt render())
        
        showErrorToast("Ort gespeichert", true); 
    } 
}

function deleteLocation(i) {
    if(confirm(`Ort "${locations[i]}" wirklich l√∂schen?`)) {
        locations.splice(i, 1);
        saveGlobals();
        
        renderLocations(); // <--- HIER GE√ÑNDERT (statt render())
        
        showErrorToast("Ort gel√∂scht", true);
    }
}

// === AUTOCOMPLETE LOGIC FROM FILE 2 ===
getEl('osmInput').addEventListener('keydown', (e) => { if(e.key === 'Enter') addManualLocation(); });
getEl('osmInput').addEventListener('input', e => { 
    if(e.target.value.length<3) { getEl('osmResults').style.display='none'; return; }
    clearTimeout(window.osmDebounce); 
    window.osmDebounce = setTimeout(() => { 
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${e.target.value}`)
        .then(r=>r.json()).then(d => { 
            const res = getEl('osmResults'); res.innerHTML='';
            if(d.length) {
                res.style.display='block';
                d.slice(0,3).forEach(x => { 
                    const div = document.createElement('div'); div.className='suggestion-item'; div.innerText=x.display_name.split(',')[0]; 
                    div.onclick=()=>{ getEl('osmInput').value=div.innerText; locCoords[div.innerText]={lat:parseFloat(x.lat),lon:parseFloat(x.lon)}; res.style.display='none'; addManualLocation(); }; 
                    res.appendChild(div); 
                });
            } else { res.style.display='none'; }
        }); 
    }, 500); 
});
document.addEventListener('click', (e) => { if(e.target !== getEl('osmInput')) getEl('osmResults').style.display='none'; });


// === LIGHTBOX LOGIC ===
function openImageLightbox(src) {
    const modal = document.getElementById('lightboxModal');
    const img = document.getElementById('lightboxImg');
    img.src = src;
    modal.style.display = 'flex';
    // Kleiner Timeout f√ºr Animationseffekt
    setTimeout(() => modal.classList.add('active'), 10);
}

function closeImageLightbox() {
    const modal = document.getElementById('lightboxModal');
    modal.classList.remove('active');
    setTimeout(() => modal.style.display = 'none', 200);
}


// --- UPDATE: Backup Health Check (Erweitert um Header Badge) ---
function checkBackupHealth() {
    const last = localStorage.getItem('lastBackup');
    const now = Date.now();
    const daysSince = last ? Math.floor((now - last) / (1000 * 60 * 60 * 24)) : 100;
    
    // Elemente holen
    const adminBtn = document.querySelectorAll('.nav-item')[1]; 
    const existingBadge = adminBtn ? adminBtn.querySelector('.warn-badge') : null;
    
    // Die Box innen
    const warnBox = getEl('backupWarningBox');
    const daysText = getEl('backupDaysCount');
    
    // Der Badge auf dem Header (wenn zugeklappt)
    const headerBadge = getEl('backupHeaderBadge');

    // Schwelle: Warnen ab 14 Tagen
    if (daysSince > 14) {
        // 1. Roter Punkt in der Navigation
        if (adminBtn && !existingBadge) {
            const badge = document.createElement('div');
            badge.className = 'warn-badge';
            badge.style.cssText = "position:absolute; top:5px; right:20px; width:10px; height:10px; background:var(--err-text); border-radius:50%; border:2px solid var(--card); z-index:10;";
            adminBtn.style.position = 'relative';
            adminBtn.appendChild(badge);
        }

        // 2. Warnbox innen (Text setzen)
        if(warnBox) {
            warnBox.style.display = 'flex';
            const timeText = last ? `vor ${daysSince} Tagen` : "noch nie";
            daysText.innerText = timeText;
        }
        
        // 3. NEU: Warnbadge auf dem Header anzeigen
        if(headerBadge) {
            headerBadge.style.display = 'block';
        }

    } else {
        // Alles gut: Aufr√§umen
        if (existingBadge) existingBadge.remove();
        if (warnBox) warnBox.style.display = 'none';
        if (headerBadge) headerBadge.style.display = 'none'; // Header Badge weg
    }
}

// Scroll Monitor
window.addEventListener('scroll', () => {
    const btn = getEl('scrollTopBtn');
    if(window.scrollY > 300) { // Erst ab 300px Scrolltiefe zeigen
        btn.style.display = 'flex';
        btn.style.opacity = '1';
    } else {
        btn.style.display = 'none';
    }
}, {passive: true});

// === NEW: OPEN TODAY MODAL ===
function openTodayModal() {
    const listCont = getEl('todayListContainer');
    listCont.innerHTML = ''; // Reset
    
    const h = getHistory(currentSystemYear);
    const todayKey = todayStr();
    const todayData = h[todayKey];

    if (!todayData || !todayData.perAnimal || todayData.total === 0) {
        listCont.innerHTML = '<div style="text-align:center; padding:40px; opacity:0.6">Noch keine Tiere heute.<br>Geh raus und such welche! üå≥</div>';
        getEl('todayModal').style.display = 'block';
        return;
    }

    // 1. Alle heutigen Eintr√§ge in eine flache Liste sammeln
    let timeline = [];
    Object.keys(todayData.perAnimal).forEach(idxStr => {
        const idx = parseInt(idxStr);
        const entries = todayData.perAnimal[idx];
        const animal = animals[idx];
        
        entries.forEach((entry, arrIdx) => {
            timeline.push({
                animalIdx: idx,
                name: animal.name,
                emoji: animal.emoji,
                time: entry.time || '00:00',
                location: entry.location || '',
                note: entry.note || '',
                arrIdx: arrIdx // F√ºr Editieren/L√∂schen wichtig
            });
        });
    });

    // 2. Sortieren nach Uhrzeit (Neueste oben)
    timeline.sort((a, b) => b.time.localeCompare(a.time));

    // 3. HTML generieren
    timeline.forEach((item, i) => {
        // Animation Delay f√ºr sch√∂nen Effekt
        const delay = i * 0.05;
        
        const row = document.createElement('div');
        row.className = 'today-row';
        row.style.animationDelay = delay + 's';
        
        // Falls keine Zeit eingetragen ist, zeigen wir "--:--"
        const displayTime = item.time === '00:00' ? '--:--' : item.time;
        
        let detailsHTML = '';
        if(item.location) detailsHTML += `<div style="margin-top:4px">üìç ${item.location}</div>`;
        if(item.note) detailsHTML += `<div style="margin-top:4px; font-style:italic; opacity:0.8">" ${item.note} "</div>`;
        if(!item.location && !item.note) detailsHTML += `<div style="margin-top:4px; opacity:0.5; font-size:11px">Keine Details</div>`;

        row.innerHTML = `
            <div class="today-time-col">
                <div class="today-time-text">${displayTime}</div>
                <div class="today-line"></div>
            </div>
            <div class="today-bubble" onclick="safeRun(openDetail, ${item.animalIdx})">
                <div class="today-header">
                    <div class="today-animal-name">${item.emoji} ${item.name}</div>
                    <span style="font-size:12px; color:var(--accent)">‚ûî</span>
                </div>
                <div class="today-details">
                    ${detailsHTML}
                </div>
            </div>
        `;
        listCont.appendChild(row);
    });

    // Letzte Linie ausblenden (kosmetisch)
    if(listCont.lastChild) {
        listCont.lastChild.querySelector('.today-line').style.background = 'transparent';
    }

    getEl('todayModal').style.display = 'block';
}

// --- NEUE FUNKTION: Akkordeon umschalten ---
function toggleAccordion(headerElement) {
    // Wir klicken auf den Header, wollen aber die ganze Sektion √∂ffnen
    const section = headerElement.closest('.card-section');
    section.classList.toggle('open');
}
// WICHTIG: Inputs innerhalb des Akkordeons d√ºrfen das Zuklappen nicht ausl√∂sen.
// Das habe ich im HTML oben schon mit onclick="event.stopPropagation()" gel√∂st.


// === QUICK SIGHTING LOGIC ===
let isQuickSightingMode = false;

/* === ERSETZE DIE BESTEHENDE openQuickSighting FUNKTION HIERMIT: === */


/* === FIX: QUICK SIGHTING WITH IMAGE SUPPORT === */

function openQuickSighting() {
    isQuickSightingMode = true;
    const modal = document.getElementById('noteModal');
    
    // 1. UI Reset
    document.getElementById('noteModalTitle').innerText = "‚ûï Neue Sichtung";
    document.getElementById('noteAnimalWrapper').style.display = 'block'; 
    document.getElementById('noteAnimalInput').value = '';
    document.getElementById('noteAnimalResults').style.display = 'none';
    
    document.getElementById('noteDate').value = todayStr(); 
    document.getElementById('noteTime').value = nowTimeStr();
    document.getElementById('noteText').value = '';
    document.getElementById('noteLoc').value = ''; // Ort leeren
    
    // BILD RESET (Wichtig!)
    currentNoteImg = null;
    document.getElementById('noteImgPreviewBox').style.display = 'none';
    document.getElementById('noteCamInput').value = '';
    document.getElementById('noteGalInput').value = '';
    
    // Fokus aufs Eingabefeld
    setTimeout(() => document.getElementById('noteAnimalInput').focus(), 100);
    
    // Autocomplete initialisieren
    if(typeof setupLocationAutocomplete === 'function') setupLocationAutocomplete();

    // Tier-Suche Logik (Autocomplete)
    const inp = document.getElementById('noteAnimalInput');
    inp.oninput = (e) => {
        const val = e.target.value.toLowerCase();
        const res = document.getElementById('noteAnimalResults');
        res.innerHTML = '';
        if(val.length < 1) { res.style.display='none'; return; }
        
        const matches = animals.filter(a => a.name.toLowerCase().includes(val));
        if(matches.length > 0) {
            res.style.display = 'block';
            matches.slice(0, 5).forEach(a => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.innerHTML = `${a.emoji} <b>${a.name}</b>`;
                div.onclick = () => { inp.value = a.name; res.style.display = 'none'; };
                res.appendChild(div);
            });
        } else { res.style.display = 'none'; }
    };

    // === SPEICHERN LOGIK (JETZT MIT BILD!) ===
    document.getElementById('noteSaveBtn').onclick = async () => {
        const animalName = document.getElementById('noteAnimalInput').value.trim();
        if(!animalName) return showErrorToast("Bitte Tiernamen eingeben");


        let idx = animals.findIndex(a => a.name.toLowerCase() === animalName.toLowerCase());
        let isNewAnimal = false;


        // A) Tier anlegen falls neu
        if(idx === -1) {
            animals.push({ name: animalName, emoji: 'üêæ', imageId: null, tags: [], isFav: false });
            idx = animals.length - 1;
            saveGlobals();
            isNewAnimal = true;
        }

        // B) Ort speichern
        const rawLoc = document.getElementById('noteLoc').value.trim();
        if(rawLoc && !locations.includes(rawLoc)) {
            locations.push(rawLoc);
            saveGlobals();
            if(typeof renderLocations === 'function') renderLocations();
        }

        // --- C) BILD SPEICHERN (DIESER TEIL FEHLTE) ---
        let finalImgId = null;
        if (currentNoteImg) {
            // Wir generieren eine ID und speichern das Bild in der DB
            finalImgId = 'note_img_' + Date.now();
            await dbSaveImg(finalImgId, currentNoteImg);
        }

        // D) Eintrag schreiben
        const d = document.getElementById('noteDate').value || todayStr();
        const data = { 
            time: document.getElementById('noteTime').value, 
            location: rawLoc, 
            note: document.getElementById('noteText').value,
            noteImageId: finalImgId // <--- Hier wird die Bild-ID verkn√ºpft!
        };
        
        playSound('pop');
        writeEntry(d, idx, data);
        
        // Aufr√§umen & Schlie√üen
        closeModal('noteModal');
        render();

        // Falls neu -> Editier-Fenster √∂ffnen
        if (isNewAnimal) {
            setTimeout(() => {
                showErrorToast("‚ú® Neu! W√§hle jetzt ein Icon/Bild.", true);
                openIconEdit(idx); 
            }, 300);
        } else {
            showErrorToast("Sichtung gespeichert!", true);
        }
    };

    modal.style.display = 'block';
}

/* === TUTORIAL LOGIC V3.3 (FIXED NAV & BUBBLE) === */
let currentStep = 0;

// Definition der Tour (Bleibt gleich, nur zur Vollst√§ndigkeit)
/* === UPDATED TOUR STEPS (V7.0) === */
const tourSteps = [
    { 
        view: 'view-list', 
        target: null, 
        title: "Willkommen zur√ºck! üöÄ", 
        text: "Tier Ticker ist jetzt noch m√§chtiger.<br>Ich zeige dir kurz die neuen Highlights." 
    },
    { 
        view: 'view-list', 
        target: '#sfWrapper', 
        title: "1. Die Suche üîç", 
        text: "Hier findest du alles: Tiere, Notizen und deine Fotos.<br>Tipp: Gib einen Ort ein, um zu sehen, was du dort entdeckt hast." 
    },
    { 
        view: 'view-list', 
        target: '.tag-story-item', // Der Story Ring
        title: "2. Story Highlights ‚≠ï", 
        text: "Ganz neu: Hier oben siehst du zuf√§llige Erinnerungen und Fotos aus deiner Sammlung. Tippe drauf f√ºr einen R√ºckblick!" 
    },
    { 
        view: 'view-list', 
        target: 'div[onclick="openRangerChat()"]', // Der Funk Chip
        title: "3. Ranger Funk üìª", 
        text: "Im Ranger Funk kannst Du √ºber einen geheimen Chat reden. Tausche dich live mit Freunden aus, teile Funde und Bilder." 
    },

    { 
        view: 'view-list', 
        target: '.nav-main-fab', // Das mittlere Plus
        title: "4. Schnell-Erfassung ‚ö°", 
        text: "Der wichtigste Knopf: Hier legst du neue Sichtungen an ‚Äì jetzt auch direkt mit Foto!" 
    },
    { 
        view: 'view-stats', 
        target: '#factWidget', 
        title: "5. Wissen & Quiz üß†", 
        text: "T√§glich neue Fakten. Klicke auf die <b>drei Punkte (‚ãÆ)</b>, um dein Wissen im Quiz zu testen und XP zu sammeln!" 
    },
    { 
        view: 'view-admin', 
        target: '.sync-card', // Die neue Sync Karte
        title: "6. Cloud Sync ‚òÅÔ∏è", 
        text: "Das Highlight: Synchronisiere deine Daten verschl√ºsselt zwischen Handy, Tablet und PC.<br>Ohne Anmeldung, sicher und einfach." 
    },
    { 
        view: 'view-admin', 
        target: '#backupCard', // Die Karte mit der ID von Schritt 1
        title: "7. Lokales Backup üíæ", 
        text: "<b>WICHTIG!</b> Deine Daten sind NUR auf diesem Ger√§t.<br>Bitte erstelle hier regelm√§√üig ein Backup, damit bei Verlust nichts weg ist!" 
    },
    { 
        view: 'view-admin', 
        title: "8. Fertig! üéâ", 
        text: "Du bist bereit. Viel Spa√ü beim Entdecken, Sammeln und Leveln!" 
    }
];


function startTutorial(force = false) {
    if (!force && localStorage.getItem('tutorial_v3_done') === 'true') return;
    document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
    window.scrollTo({top: 0, behavior: 'smooth'});
    currentStep = 0;
    document.getElementById('onboardingOverlay').style.display = 'block';
    document.getElementById('onboardingBubble').style.display = 'block';
    processStep(0);
}

// FIX 1: Korrekte Indices f√ºr die Navigation
function processStep(index) {
    if (index >= tourSteps.length) { endTutorial(true); return; }
    const step = tourSteps[index];
    
    if (step.view) {
        // Nav-Items sind: [0]Liste, [1]Stats, (FAB), [2]Map, [3]Admin
        let btnIndex = 0;
        if(step.view === 'view-stats') btnIndex = 1;
        if(step.view === 'view-map') btnIndex = 2;   // KORRIGIERT (war 3)
        if(step.view === 'view-admin') btnIndex = 3; // KORRIGIERT (war 4)

        const navBtns = document.querySelectorAll('.nav-item');
        if(navBtns[btnIndex]) {
            switchView(step.view, navBtns[btnIndex]);
        }
        
        // Widget laden erzwingen
        if (step.target === '#factWidget') loadRandomFact(); 
        
        // Scrollen bei Admin (Verz√∂gert)
        if (step.view === 'view-admin' && (index === 8 || index === 9)) {
             setTimeout(() => {
                 const el = document.querySelector(step.target);
                 if(el) el.scrollIntoView({behavior: 'smooth', block: 'center'});
             }, 650);
        }
    }

    setTimeout(() => { showStepVisuals(step, index); }, 600);
}

// FIX 2: Bubble Positionierung (Sicherheitsabstand unten)
/* === FIX: ONBOARDING POSITIONING (Smart Clamp) === */
function showStepVisuals(step, index) {
    const bubble = document.getElementById('onboardingBubble');
    const overlay = document.getElementById('onboardingOverlay');
    
    // 1. Text und Buttons setzen
    document.getElementById('tourTitle').innerText = step.title;
    document.getElementById('tourText').innerHTML = step.text;
    const btn = document.getElementById('tourNextBtn');
    
    if (index === tourSteps.length - 1) btn.innerText = "Fertig üöÄ";
    else if (index === 0) btn.innerText = "Starten ‚ûî";
    else btn.innerText = "Weiter";

    // 2. Highlights zur√ºcksetzen
    document.querySelectorAll('.tour-highlight').forEach(el => el.classList.remove('tour-highlight'));

    if (step.target) {
        const el = document.querySelector(step.target);
        // Pr√ºfen, ob das Element existiert und sichtbar ist
        if (el && el.offsetParent !== null) {
            
            // Hinscrollen (Mittig, damit wir Platz haben)
            el.scrollIntoView({behavior: 'smooth', block: 'center'});
            el.classList.add('tour-highlight');
            overlay.style.background = 'transparent'; // Fokus-Effekt durch CSS Shadow

            // --- SMARTE POSITIONIERUNG ---
            const rect = el.getBoundingClientRect();
            const bubbleH = bubble.offsetHeight || 180; // Gesch√§tzte H√∂he falls noch nicht gerendert
            const windowH = window.innerHeight;
            const gap = 20; // Abstand zum Element

            // Standard: Zentriert √ºber dem Element
            bubble.style.left = "50%"; 
            bubble.style.transform = "translateX(-50%)";
            bubble.style.bottom = "auto"; 
            bubble.style.top = "auto";

            // ENTSCHEIDUNG: Dr√ºber oder Drunter?
            
            // Platz unter dem Element berechnen
            const spaceBelow = windowH - rect.bottom;
            
            // Strategie: Wenn oben wenig Platz ist (< 40%), dann lieber drunter packen
            // ABER nur, wenn unten auch genug Platz f√ºr die Blase ist.
            const preferBottom = (rect.top < (windowH * 0.4)) && (spaceBelow > bubbleH + gap);

            if (preferBottom) {
                // UNTER dem Element positionieren
                let topPos = rect.bottom + gap;
                // Sicherheits-Check: Rutscht es unten raus?
                if (topPos + bubbleH > windowH - 10) {
                    // Notfall: Doch dr√ºber oder zentrieren
                    topPos = Math.max(10, windowH - bubbleH - 10);
                }
                bubble.style.top = topPos + "px";
            } else {
                // √úBER dem Element positionieren
                let topPos = rect.top - bubbleH - gap;
                // Sicherheits-Check: Rutscht es oben raus?
                if (topPos < 10) {
                    // Wenn es oben raus rutscht -> Notfall-Zentrierung
                    fallbackBubblePosition(overlay, bubble);
                    return; 
                }
                bubble.style.top = topPos + "px";
            }

        } else {
            // Element nicht gefunden -> Fallback Mitte
            fallbackBubblePosition(overlay, bubble);
        }
    } else {
        // Kein Target (Intro/Outro) -> Mitte
        fallbackBubblePosition(overlay, bubble);
    }
}

// Helper: Erzwingt die Mitte (Safe Mode)
function fallbackBubblePosition(overlay, bubble) {
    overlay.style.background = 'rgba(0, 0, 0, 0.85)'; // Dunkler Hintergrund
    bubble.style.top = "50%"; 
    bubble.style.left = "50%"; 
    bubble.style.bottom = "auto";
    bubble.style.transform = "translate(-50%, -50%)";
}

function fallbackBubblePosition(overlay, bubble) {
    overlay.style.background = 'rgba(0, 0, 0, 0.85)';
    bubble.style.top = "50%"; bubble.style.left = "50%"; 
    bubble.style.bottom = "auto";
    bubble.style.transform = "translate(-50%, -50%)";
}

function nextStep() { currentStep++; processStep(currentStep); }

function endTutorial(completed = false) {
    document.getElementById('onboardingOverlay').style.display = 'none';
    document.getElementById('onboardingBubble').style.display = 'none';
    document.querySelectorAll('.tour-highlight').forEach(el => el.classList.remove('tour-highlight'));
    
    const listBtn = document.querySelectorAll('.nav-item')[0]; 
    switchView('view-list', listBtn);
    window.scrollTo({top: 0, behavior: 'smooth'});

    if (completed) {
        localStorage.setItem('tutorial_v3_done', 'true');
        showErrorToast("Alles klar! Viel Spa√ü! üêæ", true);
        if(typeof playSound === 'function') playSound('fanfare');
    }
}


/* === CONTEXT MENU LOGIC (DAS HAT GEFEHLT) === */

// 1. Das Men√º zeichnen
function openContextMenu(x, y, items) {
    // Alte Men√ºs entfernen
    closeContextMenu();

    // Backdrop (damit Klick daneben es schlie√üt)
    const backdrop = document.createElement('div');
    backdrop.className = 'context-backdrop';
    backdrop.onclick = closeContextMenu;
    document.body.appendChild(backdrop);

    // Men√º Container
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    
    // REPARATUR: Smarte Positionierung
    const winW = window.innerWidth;
    const menuWidth = 190; // Gesch√§tzte Breite
    
    // Wenn Men√º rechts rausragt, nach links schieben
    if (x + menuWidth > winW) {
        x = winW - menuWidth - 10; 
    }
    // Wenn Men√º links rausragt (negative x), auf 10px setzen
    if (x < 10) x = 10;
    
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Items generieren
    items.forEach(item => {
        const div = document.createElement('div');
        div.className = `context-item ${item.danger ? 'danger' : ''}`;
        div.innerHTML = `<span style="font-size:18px">${item.icon}</span> ${item.label}`;
        div.onclick = () => {
            closeContextMenu();
            // Die Aktion ausf√ºhren
            safeRun(() => { eval(item.action); }); 
        };
        menu.appendChild(div);
    });

    document.body.appendChild(menu);
    
    // Kleines Vibrations-Feedback
    if(navigator.vibrate) navigator.vibrate(5);
}


function closeContextMenu() {
    document.querySelectorAll('.context-menu, .context-backdrop').forEach(e => e.remove());
}

// 2. Das Men√º f√ºr die LISTE (Startseite)
/* === UPDATED CONTEXT MENU (Mit Favoriten-Option) === */
function openItemMenu(idx, event) {
    if(event) event.stopPropagation();
    
    // 1. Position ermitteln
    let x = event.clientX || (event.touches ? event.touches[0].clientX : 0);
    let y = event.clientY || (event.touches ? event.touches[0].clientY : 0);

    // 2. Pr√ºfen: Ist es schon ein Favorit?
    const isFav = animals[idx].isFav;

    // 3. Styling f√ºr den "+"-Button (Sichtung)
    const btnStyleIcon = `<span style="display:inline-flex; align-items:center; justify-content:center; background:var(--accent); color:white; border-radius:8px; width:26px; height:26px; font-size:18px; font-weight:900; box-shadow:0 2px 5px var(--accent-glow); padding-bottom:1px;">+</span>`;

    // 4. Men√º-Eintr√§ge definieren
    const items = [
        // HIER NEU: Favoriten Umschalter
        { 
            label: isFav ? 'Favorit entfernen' : 'Zu Favoriten', 
            icon: isFav ? '‚òÜ' : '‚≠ê', // Leerer Stern vs. Voller Stern
            action: `toggleFav(${idx})` 
        },
        
        { label: 'Sichtung hinzuf√ºgen', icon: btnStyleIcon, action: `openNoteModal(${idx})` },
        { label: 'Tier bearbeiten', icon: '‚úèÔ∏è', action: `openIconEdit(${idx})` },
        { label: 'L√∂schen', icon: 'üóëÔ∏è', action: `moveToTrash(${idx})`, danger: true }
    ];

    openContextMenu(x, y, items);
}

// 3. Das Men√º f√ºr das DETAIL-HEADER (Tier selbst)
function openAnimalMenu(idx, event) {
    if(event) event.stopPropagation(); // Verhindert Bubbling
    
    // Button Position finden
    const rect = event.target.getBoundingClientRect();
    
    // REPARATUR: Sicherstellen, dass x nicht negativ wird oder zu weit rechts ist
    // Wir zielen auf "links vom Button", aber min. 10px vom Rand
    let x = rect.left - 140; 
    if (x < 10) x = 10; // Nicht links rausfliegen
    
    const y = rect.bottom + 5;

    const items = [
        { label: 'Tier bearbeiten', icon: '‚úèÔ∏è', action: `openIconEdit(${idx})` },
        { label: 'Tier l√∂schen', icon: 'üóëÔ∏è', action: `moveToTrash(${idx})`, danger: true }
    ];

    openContextMenu(x, y, items);
}

// Zeigt Details unter der Heatmap an
function showHeatmapInfo(el, dateStr, count) {
    // 1. Text aktualisieren
    const infoBox = document.getElementById('heatmapInfoText');
    if(count === 0) infoBox.innerText = `${dateStr}: Keine Sichtungen`;
    else infoBox.innerText = `${dateStr}: ${count} Tier${count!==1?'e':''} entdeckt!`;
    
    // 2. Visuelles Feedback (Active State f√ºr alle anderen entfernen)
    document.querySelectorAll('.heat-cell.selected').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
}

function animateValue(obj, start, end, duration) {
    if(!obj) return;
    let startTimestamp = null;
    const step = (timestamp) => {
        if (!startTimestamp) startTimestamp = timestamp;
        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
        obj.innerHTML = Math.floor(progress * (end - start) + start);
        if (progress < 1) {
            window.requestAnimationFrame(step);
        }
    };
    window.requestAnimationFrame(step);
}

/* === LISTE EIN- UND AUSKLAPPEN STEUERUNG === */

function expandList() {
    listExpanded = true;
localStorage.setItem('listExpandedState', 'true'); // <--- DAS MERKT SICH DEN ZUSTAND
    render(); // <--- WICHTIG: Sofort neu zeichnen!
    
    // Haptisches Feedback (optional)
    if(navigator.vibrate) navigator.vibrate(10);
}

function collapseList() {
    listExpanded = false;
localStorage.setItem('listExpandedState', 'false'); // <--- DAS MERKT SICH DEN ZUSTAND
    render(); // <--- WICHTIG: Sofort neu zeichnen!
    
    // Nach dem Einklappen wieder sanft zum Anfang der Liste scrollen
    // damit man nicht "im Nichts" steht, wenn die Liste kurz wird.
    const container = document.getElementById('sneakPeekContainer');
    if(container) {
        container.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}
/* Helper f√ºr das neue Widget */
function switchStat(id) {
    // 1. Alle ausblenden
    document.querySelectorAll('.stat-content').forEach(el => el.classList.remove('active'));
    // 2. Gew√§hlten einblenden
    const target = document.getElementById(id);
    if(target) target.classList.add('active');
}

/* Helper f√ºr den Verlauf Toggle */
function toggleHistory(btn) {
    // 1. Button Status toggeln (Pfeil drehen)
    btn.classList.toggle('open');
    
    // 2. Den Wrapper finden (n√§chstes Element)
    const wrapper = btn.nextElementSibling;
    
    // 3. Wrapper √∂ffnen/schlie√üen
    wrapper.classList.toggle('open');
    
    // Optional: Wenn ge√∂ffnet, kurz warten und hinscrollen
    if(wrapper.classList.contains('open')) {
        setTimeout(() => {
            wrapper.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 200);
    }
}

/* === MAP BOTTOM SHEET LOGIC === */

function openMapSheet(locationName, count) {
    // 1. Daten in das HTML schreiben
    getEl('sheetTitle').innerText = locationName;
    getEl('sheetSub').innerText = `${count} Sichtungen an diesem Ort`;
    
    // 2. Den "Pfeil"-Button konfigurieren
    const btn = getEl('sheetJumpBtn');
    btn.onclick = () => jumpToLocationFilter(locationName);
    
    // 3. Sheet hochfahren
    getEl('mapSheet').classList.add('active');
    
    // Kleines Vibrations-Feedback
    if(navigator.vibrate) navigator.vibrate(5);
}

function jumpToLocationFilter(locationName) {
    // 1. Sheet schlie√üen
    getEl('mapSheet').classList.remove('active');
    
    // 2. Suchleiste f√ºllen (Das ist der Trick!)
    const searchInput = getEl('listSearch');
    searchInput.value = locationName;
    
    // 3. Zur Liste wechseln
    // Wir simulieren einen Klick auf den ersten Nav-Button ("Liste")
    const listNavBtn = document.querySelectorAll('.nav-item')[0];
    switchView('view-list', listNavBtn);
    
    // 4. Liste neu rendern (filtert automatisch nach dem Ort im Suchfeld)
    render();
    
    // 5. User Feedback
    showErrorToast(`Zeige Tiere in: ${locationName}`, true);
}

/* === FIX: MEMORY DECK ENGINE (STACKING & SWIPE) === */

let deckCards = []; // Speichert die DOM Elemente

// 1. Initialisierung

/* === FIX: MEMORY DECK & STORY RING (COMBINED) === */

async function initMemoryDeck() {
    const container = document.getElementById('cardDeck');
    
    // 1. Daten sammeln (Logic wie gehabt)
    let candidates = [];
    const years = getAvailableYears();
    
    years.forEach(y => {
        const h = getHistory(y);
        Object.entries(h).forEach(([dateStr, d]) => {
            const [yStr, mStr, dVal] = dateStr.split('-');
            const dateFormatted = `${dVal}.${mStr}.${yStr}`;
            if(d.perAnimal) {
                Object.entries(d.perAnimal).forEach(([idxStr, list]) => {
                    const idx = parseInt(idxStr);
                    const animal = animals[idx];
                    if(!animal) return;
                    list.forEach((entry, entryIndex) => {
                        // Kriterium: Bild ODER Notiz vorhanden
                        if(entry.note || entry.noteImageId || animal.imageId) {
                            candidates.push({
                                name: animal.name,
                                emoji: animal.emoji,
                                dateDisplay: dateFormatted,
                                timeDisplay: entry.time ? `${entry.time}` : '',
                                note: entry.note || "Ein sch√∂ner Moment.",
                                loc: entry.location || "",
                                imageId: animal.imageId,
                                noteImageId: entry.noteImageId,
                                rawDate: dateStr,
                                animalIdx: idx,
                                arrIdx: entryIndex
                            });
                        }
                    });
                });
            }
        });
    });

    // 2. CHECK: Genug Daten?
    // Wenn weniger als 3 Memories da sind, keinen Ring anzeigen
    if(candidates.length < 3) {
        storyPreviewData = null;
        render(); // UI aktualisieren (Ring verschwindet)
        return;
    }

    // 3. Shuffle & Auswahl
    candidates.sort(() => 0.5 - Math.random());
    const selection = candidates.slice(0, 5);

    // --- TEIL A: STORY RING DATEN VORBEREITEN (DAS HAT GEFEHLT!) ---
    let ringImg = null;
    const firstItem = selection[0];

    // Versuch, ein Bild f√ºr den Ring zu laden
    if (firstItem.noteImageId) {
        try { ringImg = await dbGetImg(firstItem.noteImageId); } catch(e){}
    }
    if (!ringImg && firstItem.imageId) {
        try { ringImg = await dbGetImg(firstItem.imageId); } catch(e){}
    }

    // Globale Variable setzen
    storyPreviewData = {
        count: selection.length, // Gesamtzahl im Badge anzeigen
        emoji: firstItem.emoji,
        img: ringImg
    };

    // WICHTIG: Startseite neu zeichnen, damit der Ring erscheint!
    render(); 

    // --- TEIL B: KARTEN STAPEL BAUEN (Modal Inhalt) ---
    if (!container) return;
    
    // Reset & Empty State
    container.innerHTML = '';
    deckCards = [];
    
    const emptyState = document.createElement('div');
    emptyState.className = 'deck-empty';
    emptyState.innerHTML = `
        <div style="font-size:50px; margin-bottom:10px;">‚úÖ</div>
        <div style="font-weight:bold; font-size:18px;">Alles erledigt!</div>
        <div style="opacity:0.6; font-size:13px; margin-top:5px;">Komm morgen wieder.</div>
        <button onclick="closeModal('storyModal')" style="margin-top:20px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.4); padding:10px 25px; border-radius:30px; cursor:pointer;">Schlie√üen</button>
    `;
    container.appendChild(emptyState);

    // Karten rendern
    for (let i = 0; i < selection.length; i++) {
        const item = selection[i];
        const el = document.createElement('div');
        el.className = 'deck-card';
        
        // Bild f√ºr Karte laden
        let cardImg = '';
        if(item.noteImageId) { try { cardImg = await dbGetImg(item.noteImageId); } catch(e){} }
        if(!cardImg && item.imageId) { try { cardImg = await dbGetImg(item.imageId); } catch(e){} }
        
        const imgHTML = cardImg 
            ? `<img src="${cardImg}" class="dc-img" style="width:100%; height:100%; object-fit:cover; pointer-events:none;">` 
            : `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:80px; background:#f0f0f0;">${item.emoji}</div>`;

        el.innerHTML = `
            <div class="dc-img-area">
                ${imgHTML}
                ${item.loc ? `<div class="dc-badge" style="position:absolute; top:10px; right:10px; padding:4px 10px; border-radius:15px; font-size:11px; font-weight:bold;">üìç ${item.loc}</div>` : ''}
            </div>
            <div class="dc-body" style="padding:15px; flex:1; display:flex; flex-direction:column;">
                <div class="dc-title">${item.emoji} ${item.name}</div>
                <div class="dc-note">"${item.note}"</div>
                <div class="dc-date" style="display:flex; justify-content:space-between; font-size:11px;">
                    <span>üìÖ ${item.dateDisplay}</span>
                    <span>${item.timeDisplay}</span>
                </div>
            </div>
        `;
        
        makeCardDraggable(el, item);
        container.appendChild(el);
        deckCards.push(el);
    }

    // Visuelles Stapeln aktivieren
    updateDeckVisuals();
}

// 2. Das visuelle Stapeln (Der Kern-Fix)
function updateDeckVisuals() {
    deckCards.forEach((card, i) => {
        // Z-Index: Erste Karte (i=0) ganz oben (z.B. 10), n√§chste 9...
        card.style.zIndex = deckCards.length - i;
        
        // Animation resetten f√ºr sauberes Positionieren
        card.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.3s';

        if (i === 0) {
            // === OBERSTE KARTE ===
            // Volle Gr√∂√üe, voll sichtbar, klickbar
            card.style.transform = 'scale(1) translateY(0) rotate(0deg)';
            card.style.opacity = '1';
            card.style.pointerEvents = 'all'; 
        } 
        else if (i === 1) {
            // === ZWEITE KARTE (Dahinter) ===
            // Leicht verkleinert, etwas tiefer, etwas gedreht -> "Papierstapel Chaos"
            card.style.transform = 'scale(0.96) translateY(12px) rotate(-3deg)';
            card.style.opacity = '1'; // WICHTIG: Sichtbar lassen!
            card.style.pointerEvents = 'none';
        } 
        else if (i === 2) {
            // === DRITTE KARTE (Ganz hinten) ===
            card.style.transform = 'scale(0.92) translateY(24px) rotate(2deg)';
            card.style.opacity = '1'; // Auch sichtbar!
            card.style.pointerEvents = 'none';
        } 
        else {
            // === REST (Warteschlange) ===
            // Versteckt hinter dem Stapel
            card.style.transform = 'scale(0.9) translateY(24px)';
            card.style.opacity = '0'; // Erst jetzt unsichtbar
            card.style.pointerEvents = 'none';
        }
    });
}

// 3. Draggable Logic (Ohne Verz√∂gerung beim Nachr√ºcken)
function makeCardDraggable(card, dataItem) {
    let startX = 0, currentX = 0;
    let isDragging = false;
    let startTime = 0;

    const start = (e) => {
        if(card !== deckCards[0]) return; // Nur oberste Karte
        isDragging = true;
        startX = e.clientX || e.touches[0].clientX;
        startTime = Date.now();
        card.style.transition = 'none'; // Direktes Feedback
    };

    const move = (e) => {
        if(!isDragging) return;
        const x = e.clientX || e.touches[0].clientX;
        currentX = x - startX;
        
        // Karte dreht sich beim Ziehen
        const rot = currentX * 0.08;
        card.style.transform = `translateX(${currentX}px) rotate(${rot}deg)`;
        
        // Opacity verringern beim weiten Ziehen
        if(Math.abs(currentX) > 150) {
            card.style.opacity = Math.max(0.5, 1 - (Math.abs(currentX)-150)/200);
        }
    };

    const end = (e) => {
        if(!isDragging) return;
        isDragging = false;
        
        // Klick-Erkennung (wenig bewegt + kurz gedr√ºckt)
        if (Math.abs(currentX) < 10 && (Date.now() - startTime) < 300) {
            card.style.transform = 'scale(1) translateY(0) rotate(0deg)'; // Reset
            safeRun(viewNoteDetail, dataItem.animalIdx, dataItem.rawDate, dataItem.arrIdx); // √ñffnen
            return;
        }

        // SWIPE ERKANNT (>120px)
        if (Math.abs(currentX) > 120) {
            // 1. Karte wegfliegen lassen
            const dir = currentX > 0 ? 1 : -1;
            const endX = window.innerWidth * 1.2; // Weit raus
            
            // Flug-Animation
            card.style.transition = 'transform 0.3s ease-out';
            card.style.transform = `translateX(${dir * endX}px) rotate(${dir * 45}deg)`;
            
            // 2. SOFORT Daten updaten (Array Shift)
            // Die Karte ist noch im DOM (fliegt gerade weg), aber logisch schon weg
            deckCards.shift(); 
            
            // 3. Den Rest SOFORT nachr√ºcken lassen (animiert durch CSS transition in updateDeckVisuals)
            updateDeckVisuals();
            
            // 4. Aufr√§umen: Weggeflogene Karte aus dem DOM l√∂schen (nach Animation)
            setTimeout(() => card.remove(), 300);
            
            if(navigator.vibrate) navigator.vibrate(10);

        } else {
            // ZUR√úCK SCHNAPPEN (Nicht weit genug gezogen)
            card.style.transition = 'transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            card.style.transform = 'scale(1) translateY(0) rotate(0deg)';
            card.style.opacity = '1';
        }
        currentX = 0;
    };

    card.addEventListener('mousedown', start);
    card.addEventListener('touchstart', start, {passive: true});
    document.addEventListener('mousemove', move);
    document.addEventListener('touchmove', move, {passive: false});
    document.addEventListener('mouseup', end);
    document.addEventListener('touchend', end);
}

/* =========================================
   FIX & REPARATUR BLOCK
   F√ºge das am Ende deines Scripts ein.
   ========================================= */


// 2. Die Smart Date Upload Funktion

// ERSETZE DEINE AKTUELLE handleNoteImgUpload FUNKTION DAMIT:

/* =========================================
   ROBUST SMART DATE & SHARE
   ========================================= */


// 1. Der "Dirty Search" Scanner
function findDateInHeader(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        // Wir lesen die ersten 50KB. Das reicht f√ºr den Header.
        reader.onload = function(e) {
            const buffer = new Uint8Array(e.target.result);
            let str = "";
            // Bin√§rdaten zu String (nur druckbare Zeichen, um Speicher zu sparen)
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] > 32 && buffer[i] < 127) {
                    str += String.fromCharCode(buffer[i]);
                } else {
                    str += " "; // Platzhalter
                }
            }

            // Suche nach EXIF-Standardformat: YYYY:MM:DD HH:MM:SS
            // Wir suchen Jahre ab 2000 bis 2099
            const match = str.match(/(20\d{2}):(\d{2}):(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);

            if (match) {
                // match[1]=YYYY, match[2]=MM, etc.
                const realDate = new Date(
                    match[1], match[2]-1, match[3], 
                    match[4], match[5], match[6]
                );
                resolve(realDate);
            } else {
                resolve(null);
            }
        };
        reader.readAsArrayBuffer(file.slice(0, 51200)); 
    });
}

// 2. Die Upload Funktion
async function handleNoteImgUpload(input) {
    if(input.files && input.files[0]){
        const file = input.files[0];
        
        // A) Versuch: Echter Scan im Datei-Header
        let detectedDate = await findDateInHeader(file);
        
        // B) Fallback: Datei-Metadaten (nur wenn nicht "Heute")
        if (!detectedDate) {
            const modDate = new Date(file.lastModified);
            const todayStr = new Date().toDateString();
            if (modDate.toDateString() !== todayStr) {
                detectedDate = modDate;
            }
        }

        // Ergebnis verarbeiten
        if (detectedDate) {
            const today = new Date();
            // Ist das gefundene Datum ungleich Heute?
            // (Toleranz: Wir ignorieren die Uhrzeit f√ºr den "Ist es heute?" Check)
            if (detectedDate.toDateString() !== today.toDateString()) {
                
                const dispDate = detectedDate.toLocaleDateString();
                const dispTime = detectedDate.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                
                if(confirm(`üìÖ Aufnahmedatum gefunden: ${dispDate} (${dispTime})\n\nSoll die Sichtung auf diesen Zeitpunkt datiert werden?`)) {
                    
                    const yyyy = detectedDate.getFullYear();
                    const mm = String(detectedDate.getMonth() + 1).padStart(2, '0');
                    const dd = String(detectedDate.getDate()).padStart(2, '0');
                    
                    const dEl = document.getElementById('noteDate');
                    const tEl = document.getElementById('noteTime');
                    
                    if(dEl) dEl.value = `${yyyy}-${mm}-${dd}`;
                    if(tEl) tEl.value = dispTime;
                    
                    showErrorToast(`Datum auf ${dispDate} gesetzt`, true);
                }
            } else {
                // Debugging f√ºr dich: Falls er doch "Heute" findet
                console.log("Datum im Bild gefunden, aber es ist von heute.");
            }
        } else {
            console.log("Kein Datum im Bild-Header gefunden.");
        }

        // Bild anzeigen
        const reader = new FileReader();
        reader.onload = function(e) {
            resizeImage(e.target.result, 1280, function(res) { 
                currentNoteImg = res;
                const imgEl = document.getElementById('noteImgEl');
                const box = document.getElementById('noteImgPreviewBox');
                if(imgEl) imgEl.src = res;
                if(box) box.style.display = 'block';
            }, 0.7); 
        };
        reader.readAsDataURL(file);
    }
}

// 3. Share Funktion (Bleibt gleich, muss aber im Block sein)
/* === SINGLE NOTE SHARE GENERATOR (MIT EIGENEM TITEL) === */
async function shareSingleNote() {
    const dateEl = document.getElementById('nvDate');
    const locEl = document.getElementById('nvLoc');
    const noteEl = document.getElementById('nvText');
    const imgEl = document.getElementById('nvHeroImg');

    if(!dateEl) return;

    // 1. Standard-Titel ermitteln
    let defaultTitle = "Tier Sichtung";
    if (typeof detailAnimalIdx !== 'undefined' && animals[detailAnimalIdx]) {
        defaultTitle = animals[detailAnimalIdx].name;
    }

    // --- NEU: TITEL ABFRAGE ---
    // Ein Eingabefenster √∂ffnet sich vor dem Generieren
    const userTitle = prompt("Titel f√ºr die Share-Card eingeben:", defaultTitle);

    // Wenn der User "Abbrechen" dr√ºckt, stoppen wir hier
    if (userTitle === null) return;

    // Den Titel setzen (Eingabe oder Standard, falls leer gelassen)
    const titleText = userTitle.trim() || defaultTitle;
    
    // Daten auslesen
    const dateTxt = dateEl.innerText;
    const locTxt = locEl.innerText.replace('üìç ', '');
    const noteTxt = noteEl.innerText;

    showErrorToast("üé® Designe Karte...", true);

    // 2. Bild vorbereiten
    const hasImg = (imgEl && imgEl.style.display !== 'none' && imgEl.src);
    let imgObj = null;
    let imgDrawH = 0;
    
    // Layout-Konstanten
    const cardW = 900; 
    const margin = 50; 
    const contentW = cardW - (margin * 2);
    
    if (hasImg) {
        try {
            imgObj = new Image();
            imgObj.crossOrigin = "anonymous";
            imgObj.src = imgEl.src;
            await new Promise((r, e) => { imgObj.onload = r; imgObj.onerror = e; });
            
            const ratio = imgObj.height / imgObj.width;
            imgDrawH = contentW * ratio; 
        } catch(e) { console.log(e); }
    } else {
        imgDrawH = 250; // Platz f√ºr Icon
    }

    // 3. Text-H√∂he berechnen
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const titleFont = "900 60px 'Segoe UI', Roboto, sans-serif";
    const metaFont = "700 26px monospace";
    const noteFont = "italic 400 32px serif";
    const lineHeight = 48;

    let noteHeight = 0;
    let lines = [];
    
    if(noteTxt && noteTxt !== "Keine Notiz.") {
        ctx.font = noteFont;
        const words = noteTxt.split(' ');
        let line = '';
        
        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            if (metrics.width > contentW && n > 0) {
                lines.push(line);
                line = words[n] + ' ';
            } else {
                line = testLine;
            }
        }
        lines.push(line);
        noteHeight = lines.length * lineHeight;
    }

    // 4. Gesamth√∂he (Mit mehr "Luft")
    const spacingTitle = 60; 
    const spacingMeta = 30;
    const spacingNote = 60; 
    const spacingFooter = 80;
    
    const totalHeight = margin + imgDrawH + spacingTitle + 60 + spacingMeta + 30 + spacingNote + noteHeight + spacingFooter + margin;

    // 5. Canvas Finalisieren
    canvas.width = cardW;
    canvas.height = totalHeight;

    // Background
    const grad = ctx.createLinearGradient(0, 0, cardW, totalHeight);
    grad.addColorStop(0, '#f8f9fa'); 
    grad.addColorStop(1, '#e9ecef'); 
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, cardW, totalHeight);

    // Die "Karte" (Wei√üer Kasten)
    ctx.fillStyle = "#ffffff";
    ctx.shadowColor = "rgba(0,0,0,0.15)"; ctx.shadowBlur = 40; ctx.shadowOffsetY = 20;
    
    function roundRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }

    roundRect(margin, margin, contentW, totalHeight - (margin*2), 20); 
    ctx.fill();
    ctx.shadowBlur = 0; ctx.shadowOffsetY = 0; 

    // === INHALT ===
    let currentY = margin + 30; 

    // A) BILD
    if (imgObj) {
        const imgX = margin + 30;
        const imgY = currentY;
        const imgW = contentW - 60;
        const imgH = imgDrawH;
        const imgRadius = 16;

        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 20; ctx.shadowOffsetY = 10;
        ctx.fillStyle = "#000"; 
        roundRect(imgX, imgY, imgW, imgH, imgRadius);
        ctx.fill(); 
        ctx.restore();

        ctx.save();
        roundRect(imgX, imgY, imgW, imgH, imgRadius);
        ctx.clip();
        ctx.drawImage(imgObj, imgX, imgY, imgW, imgH);
        ctx.restore();
        
        ctx.strokeStyle = "rgba(0,0,0,0.05)"; ctx.lineWidth = 2;
        roundRect(imgX, imgY, imgW, imgH, imgRadius);
        ctx.stroke();

        currentY += imgH + spacingTitle;
    } else {
        currentY += 60;
        ctx.font = "120px serif"; ctx.textAlign = "center"; ctx.fillStyle = "#333";
        ctx.fillText("üêæ", cardW/2, currentY + 80);
        currentY += 200;
    }

    // B) TEXTE
    ctx.textAlign = "center";
    
    // Titel (JETZT DER BENUTZERDEFINIERTE)
    ctx.fillStyle = "#1a1a1a";
    ctx.font = titleFont;
    ctx.fillText(titleText, cardW/2, currentY);
    currentY += 50;

    // Meta (Datum/Ort)
    ctx.fillStyle = "#2196f3"; 
    ctx.font = metaFont;
    const metaStr = (dateTxt + " ‚Ä¢ " + (locTxt || 'Unbekannt')).toUpperCase();
    ctx.fillText(metaStr, cardW/2, currentY);
    currentY += 40;

    // Trennlinie
    ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cardW/2 - 50, currentY);
    ctx.lineTo(cardW/2 + 50, currentY);
    ctx.stroke();
    
    currentY += 50; 

    // Notiz
    if(lines.length > 0) {
        ctx.font = noteFont;
        ctx.fillStyle = "#444";
        lines.forEach(line => {
            ctx.fillText(line, cardW/2, currentY);
            currentY += lineHeight;
        });
    }

    // Footer
    const footerY = totalHeight - margin - 30;
    ctx.font = "bold 14px sans-serif";
    ctx.fillStyle = "#aaa";
    ctx.fillText("ERSTELLT MIT TIER TICKER APP", cardW/2, footerY);

    // 6. EXPORT
    canvas.toBlob(async (blob) => {
        // Dateiname auch basierend auf Titel
        const safeFilename = titleText.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const file = new File([blob], `sichtung-${safeFilename}.png`, { type: "image/png" });
        
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
            try { await navigator.share({ files: [file], title: titleText, text: `Schau mal: ${titleText} üêæ` }); } catch (err) {}
        } else {
            const a = document.createElement('a'); 
            a.href = URL.createObjectURL(blob); 
            a.download = `sichtung-${safeFilename}.png`; 
            a.click(); 
            showErrorToast("Bild gespeichert!", true);
        }
    });
}
   
function removeNoteImg() {
    currentNoteImg = 'DELETE';
    document.getElementById('noteImgEl').src = '';
    document.getElementById('noteImgPreviewBox').style.display = 'none';
}

/* =========================================
   ASTRO ENGINE (REAL MATH VERSION)
   ========================================= */

let solarCoords = JSON.parse(localStorage.getItem('solarCoords')) || { lat: 51.16, lon: 10.45, name: 'Deutschland (Mitte)' };

// 1. ECHTE SONNEN-MATHEMATIK (Sunrise Equation)
function getSunCalc(date, lat, lng) {
    // Hilfsfunktionen (Grad zu Radiant)
    const rad = Math.PI / 180;
    const deg = 180 / Math.PI;

    // Tag des Jahres
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = date - start;
    const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));

    // 1. Mittlere Sonnenzeit berechnen
    // Wir sch√§tzen die Zeitzone anhand der Longitude (15¬∞ = 1 Stunde)
    const lngHour = lng / 15;
    
    function calcTime(isSunrise) {
        const t = dayOfYear + ((isSunrise ? 6 : 18) - lngHour) / 24;

        // 2. Mittlere Anomalie der Sonne
        const M = (0.9856 * t) - 3.289;

        // 3. Wahre L√§nge der Sonne
        let L = M + (1.916 * Math.sin(M * rad)) + (0.020 * Math.sin(2 * M * rad)) + 282.634;
        if (L > 360) L -= 360; else if (L < 0) L += 360;

        // 4. Rektaszension
        let RA = deg * Math.atan(0.91764 * Math.tan(L * rad));
        if (RA > 360) RA -= 360; else if (RA < 0) RA += 360;

        // RA muss im selben Quadranten wie L sein
        const Lquadrant  = (Math.floor( L/90)) * 90;
        const RAquadrant = (Math.floor(RA/90)) * 90;
        RA = RA + (Lquadrant - RAquadrant);
        RA = RA / 15;

        // 5. Deklination der Sonne
        const sinDec = 0.39782 * Math.sin(L * rad);
        const cosDec = Math.cos(Math.asin(sinDec));

        // 6. Lokaler Stundenwinkel (Zenit: 90¬∞50' f√ºr offiziellen Aufgang)
        const cosH = (Math.cos(90.833 * rad) - (sinDec * Math.sin(lat * rad))) / (cosDec * Math.cos(lat * rad));
        
        if (cosH >  1) return null; // Polarnacht (Sonne geht nie auf)
        if (cosH < -1) return null; // Polartag (Sonne geht nie unter)

        const H = (isSunrise ? (360 - deg * Math.acos(cosH)) : (deg * Math.acos(cosH))) / 15;

        // 7. Lokale mittlere Zeit (UTC)
        const T = H + RA - (0.06571 * t) - 6.622;
        let UT = T - lngHour;
        if (UT > 24) UT -= 24; else if (UT < 0) UT += 24;
        
        return UT; // Zeit in UTC Dezimal
    }

    // Berechnung
    const riseUTC = calcTime(true);
    const setUTC = calcTime(false);

    // Wir berechnen die "Remote Timezone" (grob)
    // Offset in Stunden: Longitude / 15. 
    // New York (-74¬∞) / 15 = -4.9h (Passt grob zu EST -5)
    const remoteOffset = Math.round(lng / 15);

    // Helper: Dezimalzeit zu String (HH:MM)
    const toTimeStr = (utcDec) => {
        if(utcDec === null) return "--:--";
        let localH = utcDec + remoteOffset;
        if(localH >= 24) localH -= 24;
        if(localH < 0) localH += 24;
        
        const h = Math.floor(localH);
        const m = Math.floor((localH - h) * 60);
        return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
    };

    return {
        rise: toTimeStr(riseUTC),
        set: toTimeStr(setUTC),
        offset: remoteOffset
    };
}

// 2. SONNEN-POSITION (Elevation f√ºr Tag/Nacht Status)
function calculateSunElevation(date, lat, lng) {
    const PI = Math.PI, sin = Math.sin, cos = Math.cos, asin = Math.asin;
    const rad = PI / 180;
    
    // Einfache Position (reicht f√ºr Status-Check)
    const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
    const dec = 23.45 * sin(rad * (360/365) * (dayOfYear - 81));
    const b = (360/365) * (dayOfYear - 81);
    const eot = 9.87 * sin(2*rad*b) - 7.53 * cos(rad*b) - 1.5 * sin(rad*b);
    
    // Zeit in UTC nutzen!
    const utcHours = date.getUTCHours() + date.getUTCMinutes()/60;
    const timeOffset = (utcHours * 60 + 4 * lng + eot) / 60; // Solar Time
    
    const ha = (timeOffset - 12) * 15;
    const alt = asin(sin(rad*lat) * sin(rad*dec) + cos(rad*lat) * cos(rad*dec) * cos(rad*ha)) / rad;
    
    return { alt: alt, solarHour: timeOffset };
}

// 3. WIDGET RENDERN
function refreshSolarData() {
    const el = document.getElementById('solarWidget');
    if(!el) return;
    
    // Echte Daten berechnen
    const now = new Date();
    const sunData = getSunCalc(now, solarCoords.lat, solarCoords.lon);
    const posData = calculateSunElevation(now, solarCoords.lat, solarCoords.lon);
    
    // --- UHRZEIT FIX F√úR REMOTE ORT ---
    // Wir nehmen die aktuelle UTC Zeit und addieren den Offset des Ortes
    const utcMs = now.getTime() + (now.getTimezoneOffset() * 60000);
    const remoteDate = new Date(utcMs + (3600000 * sunData.offset));
    const remoteTimeStr = remoteDate.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    
    // UI Update
    document.getElementById('solSunrise').innerText = sunData.rise;
    document.getElementById('solSunset').innerText = sunData.set;
      // Fallback Logik: Wenn kein Name da ist, ist es Standard
    const locName = solarCoords.name || "Unbekannt (Standard)";
    document.getElementById('solLocName').innerHTML = `üìç ${locName}`; // Nur Name, Zeit steht ja gro√ü dr√ºber

 document.getElementById('solClock').innerText = remoteTimeStr;

    // Status Berechnung (Elevation)
    const alt = posData.alt;
    let phase = "Tag";
    let bg = "linear-gradient(to bottom, #2980b9, #6dd5fa)"; // Tag Blau
    let icon = "‚òÄÔ∏è";
    
    if (alt < -18) { phase = "Nacht"; bg = "linear-gradient(to bottom, #0f2027, #203a43)"; icon = "üåô"; }
    else if (alt < -6) { phase = "D√§mmerung (Astro)"; bg = "linear-gradient(to bottom, #141e30, #243b55)"; icon = "‚ú®"; }
    else if (alt < 0) { phase = "D√§mmerung (Zivil)"; bg = "linear-gradient(to bottom, #ff7e5f, #feb47b)"; icon = "üåÖ"; } 
    else if (alt < 15) { phase = "Goldene Stunde"; bg = "linear-gradient(to bottom, #f12711, #f5af19)"; icon = "‚òÄÔ∏è"; }
    
    document.getElementById('solPhase').innerText = phase;
    document.getElementById('solarIcon').innerText = icon;
    el.style.background = bg;

    // Rotation des Icons im Bogen
    // Wir mappen die Solar-Zeit (0-24h) auf den Halbkreis
    // 6 Uhr = links (-90deg), 12 Uhr = mitte (0deg), 18 Uhr = rechts (90deg)
    // Wir nehmen posData.solarHour (Das ist die wahre Sonnenzeit am Ort)
    let rot = ((posData.solarHour - 12) * 15); 
    
    // Begrenzen damit es nicht unten raus dreht
    if(rot < -100) rot = -100; 
    if(rot > 100) rot = 100;
    
    document.getElementById('solarOrbit').style.transform = `translateX(-50%) rotate(${rot}deg)`;
}

/* === MAP TIME TRAVEL LOGIC === */
let mapMarkers = []; // Speichert {marker, month}

// Ersetzt die alte initMap Logik teilweise
function initMapWithTimeTravel() {
    if(!mapInstance) {
        mapInstance = L.map('map').setView([51.165, 10.451], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution:'&copy; OSM'}).addTo(mapInstance);
        
        // Klick Handler
        mapInstance.on('click', () => { getEl('mapSheet').classList.remove('active'); });
    }

    // Marker neu aufbauen
    // Zuerst alles alte l√∂schen
    mapMarkers.forEach(m => m.marker.remove());
    mapMarkers = [];

    // Daten sammeln
    const years = getAvailableYears();
    
    // Tempor√§res Objekt um Orte zu gruppieren (optional, sonst viele Marker √ºbereinander)
    // Hier machen wir einfache Einzelmarker f√ºr den TimeTravel Effekt
    
    years.forEach(y => {
        const h = getHistory(y);
        Object.entries(h).forEach(([dateStr, d]) => {
            const monthIdx = new Date(dateStr).getMonth(); // 0 - 11
            
            if(d.perAnimal) {
                Object.values(d.perAnimal).forEach(list => {
                    list.forEach(item => {
                        if(item.location && locCoords[item.location]) {
                            const c = locCoords[item.location];
                            
                            // Marker erstellen aber noch NICHT zur Map hinzuf√ºgen (au√üer Slider ist auf 12)
                            const marker = L.marker([c.lat, c.lon]);
                            
                            // Popup Logik (oder Sheet)
                            marker.on('click', (e) => {
                                L.DomEvent.stopPropagation(e);
                                openMapSheet(item.location, "Sichtung am " + dateStr.split('-').reverse().join('.'));
                            });

                            mapMarkers.push({ marker: marker, month: monthIdx });
                        }
                    });
                });
            }
        });
    });

    // Initial: Alles anzeigen
    filterMapTime(12); 
}



function filterMapTime(val) {
    const limit = parseInt(val);
    const months = ["JAN", "FEB", "M√ÑR", "APR", "MAI", "JUN", "JUL", "AUG", "SEP", "OKT", "NOV", "DEZ"];
    
    // Pfeile hinzuf√ºgen f√ºr Direction-Feedback
    const label = limit === 12 
        ? "‚ö° GANZES JAHR" 
        : `‚óÑ BIS ${months[limit]} ‚ñ∫`; // Pfeile zeigen Range an
        
    const display = document.getElementById('mapTimeDisplay');
    if(display) display.innerText = label;

    // Haptik Feedback beim Ziehen (nur wenn sich Wert √§ndert)
    if(limit !== window.lastMapLimit) {
        if(navigator.vibrate) navigator.vibrate(5);
        window.lastMapLimit = limit;
    }

    mapMarkers.forEach(obj => {
        if (limit === 12 || obj.month <= limit) {
            obj.marker.addTo(mapInstance);
        } else {
            obj.marker.remove();
        }
    });
}

/* === SOLAR WIDGET INTERACTION === */

// Toggle Funktion f√ºr das Suchfeld
function toggleSolarInput() {
    const wrap = document.getElementById('solInputWrap');
    const inp = document.getElementById('solWidgetInput');
    
    if (wrap.style.display === 'block') {
        wrap.style.display = 'none';
    } else {
        wrap.style.display = 'block';
        inp.focus();
        // Event Listener initialisieren, falls noch nicht passiert
        if (!inp.dataset.init) {
            initSolarWidgetSearch();
            inp.dataset.init = "true";
        }
    }
}

// Die neue Such-Logik (Gebunden an das Widget)
function initSolarWidgetSearch() {
    const inp = document.getElementById('solWidgetInput');
    const res = document.getElementById('solWidgetResults');
    let timer;

    inp.oninput = function(e) {
        const val = e.target.value;
        
        // Spezial: "GPS" eingeben f√ºr automatische Ortung
        if(val.toLowerCase() === 'gps') {
            useGPSForSolar();
            return;
        }

        res.innerHTML = '';
        if(val.length < 3) { res.style.display='none'; return; }
        
        clearTimeout(timer);
        timer = setTimeout(() => {
            if(!navigator.onLine) return;

            fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(val)}&accept-language=de&limit=3`)
            .then(r => r.json())
            .then(data => {
                res.innerHTML = ''; 
                if(data.length > 0) {
                    res.style.display = 'block';
                    data.forEach(item => {
                        const div = document.createElement('div');
                        div.className = 'suggestion-item';
                        div.style.color = '#333'; // Wichtig da Hintergrund wei√ü
                        
                        const shortName = item.display_name.split(',')[0];
                        div.innerHTML = `üåç <b>${shortName}</b> <br><span style="font-size:10px; opacity:0.6">${item.display_name}</span>`;
                        
                        div.onclick = () => {
                            setSolarCoords(parseFloat(item.lat), parseFloat(item.lon), shortName);
                            toggleSolarInput(); // Schlie√üen
                            inp.value = '';
                        };
                        res.appendChild(div);
                    });
                }
            });
        }, 500);
    };
}

function useGPSForSolar() {
    if(!navigator.geolocation) return showErrorToast("Kein GPS");
    navigator.geolocation.getCurrentPosition(p => {
        setSolarCoords(p.coords.latitude, p.coords.longitude, "Mein Standort (GPS)");
        toggleSolarInput();
        document.getElementById('solWidgetInput').value = '';
    });
}

function setSolarCoords(lat, lon, name) {
    solarCoords = { lat, lon, name };
    localStorage.setItem('solarCoords', JSON.stringify(solarCoords));
    refreshSolarData();
    showErrorToast(`Ort gesetzt: ${name}`, true);
}




/* === FUSION ENGINE V3.6: HYBRID & FALLBACK === */

// 0. NOTFALL-KIT (Direkt im Code, falls facts.json nicht l√§dt)
const STARTER_FACTS = [
  { animal: "Rotfuchs", icon: "ü¶ä", text: "F√ºchse nutzen das Magnetfeld der Erde, um bei der Jagd im Schnee die Entfernung zur Beute exakt zu bestimmen.", tags: ["Jagd", "Sinne"], source: "Starter-Kit" },
  { animal: "Honigbiene", icon: "üêù", text: "Bienen kommunizieren die Entfernung und Richtung von Futterquellen durch einen speziellen 'Schw√§nzeltanz'.", tags: ["Kommunikation"], source: "Starter-Kit" },
  { animal: "Oktopus", icon: "üêô", text: "Kraken haben drei Herzen und blaues Blut. Zwei Herzen pumpen Blut zu den Kiemen, eins zum Rest des K√∂rpers.", tags: ["Anatomie", "Wasser"], source: "Starter-Kit" },
  { animal: "Faultier", icon: "ü¶•", text: "Faultiere kommen nur einmal pro Woche vom Baum herunter, um auf die Toilette zu gehen. Ein riskantes Man√∂ver!", tags: ["Verhalten", "Lustig"], source: "Starter-Kit" },
  { animal: "Blauwal", icon: "üêã", text: "Das Herz eines Blauwals ist so gro√ü wie ein VW K√§fer und man k√∂nnte durch die Aorta schwimmen.", tags: ["Anatomie", "Gr√∂√üe"], source: "Starter-Kit" }
];

// STATE
let allGlobalFacts = [];            
let activeLibTab = 'saved';         
let userFlavorTags = JSON.parse(localStorage.getItem('userFlavorTags')) || []; 
let activeDeckIDs = JSON.parse(localStorage.getItem('activeDeckIDs')) || ['builtin']; 

// SEARCH STATE
let libSearchState = { query: '', animalFilter: null };

updateLibBadge();
setTimeout(initFactEngine, 500);

// 1. INIT & DECK MERGE
async function initFactEngine() {
    allGlobalFacts = []; // Reset
    let loadedCount = 0;

    // A) Built-in (Standard Bibliothek)
    if (activeDeckIDs.includes('builtin')) {
        try {
            // Versuch 1: Externe Datei laden
            const response = await fetch('./facts.json');
            if (response.ok) {
                const builtIn = await response.json();
                const processed = builtIn.map(f => ({ ...f, id: generateFactId(f.text), deckSource: 'Standard' }));
                allGlobalFacts.push(...processed);
                loadedCount += processed.length;
                console.log("Online facts.json geladen.");
            } else {
                throw new Error("Datei nicht gefunden");
            }
        } catch (e) {
            // Versuch 2: FALLBACK auf Starter-Kit (wenn Datei fehlt/CORS Fehler)
            console.warn("Lade Fallback-Fakten (Offline Mode).");
            const fallback = STARTER_FACTS.map(f => ({ ...f, id: generateFactId(f.text), deckSource: 'Standard (Offline)' }));
            allGlobalFacts.push(...fallback);
            loadedCount += fallback.length;
        }
    }

    // B) Custom Decks aus IndexedDB laden
    try {
        const myDecks = await dbGetDecks();
        myDecks.forEach(deck => {
            if (activeDeckIDs.includes(deck.id)) {
                const processed = deck.facts.map(f => ({ ...f, id: generateFactId(f.text), deckSource: deck.name }));
                allGlobalFacts.push(...processed);
                loadedCount += processed.length;
            }
        });
    } catch (e) { console.error("DB Deck Error", e); }

    console.log(`Engine bereit: ${loadedCount} Fakten aus ${activeDeckIDs.length} Quellen.`);
    
    // UI Update (Falls Widget leer war, jetzt f√ºllen)
    if (document.getElementById('factText').innerText === 'Lade Wissen...') {
        loadRandomFact();
    }
}

// Helper f√ºr ID
function generateFactId(text) {
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
        hash = ((hash << 5) - hash) + text.charCodeAt(i);
        hash |= 0; 
    }
    return 'gen_' + Math.abs(hash);
}

// 2. WIDGET LOGIK
async function loadRandomFact() {
    const widget = document.getElementById('factWidget');
    const footer = document.getElementById('factLibraryBtn');
    
    // Versuch nachzuladen
    if (allGlobalFacts.length === 0) await initFactEngine();

    // FALLBACK: Wenn ALLES deaktiviert ist
    if (allGlobalFacts.length === 0) {
        document.getElementById('factText').innerText = "Keine Fakten aktiv.\nAktiviere die Standard-Bibliothek oder importiere Decks!";
        document.getElementById('factIcon').innerText = "üì≠";
        document.getElementById('factSource').innerText = "";
        widget.style.display = 'block';
        return;
    }

    // A) Filtern nach Pr√§ferenzen
    let pool = allGlobalFacts;
    if (userFlavorTags.length > 0) {
        const filtered = allGlobalFacts.filter(f => f.tags && f.tags.some(t => userFlavorTags.includes(t)));
        if (filtered.length > 0) pool = filtered;
    }

    // B) Zufall
    const randomFact = pool[Math.floor(Math.random() * pool.length)];
    currentFactData = randomFact; 

    // C) Render
    const txtEl = document.getElementById('factText');
    const iconEl = document.getElementById('factIcon');
    const srcEl = document.getElementById('factSource');
    
    txtEl.style.opacity = 0;
    setTimeout(() => {
        txtEl.innerText = `"${randomFact.text}"`;
        iconEl.innerText = randomFact.icon || 'üí°';
        srcEl.innerText = randomFact.source ? `Quelle: ${randomFact.source}` : `Deck: ${randomFact.deckSource}`;
        checkHeartStatus();
        txtEl.style.opacity = 1;
    }, 200);

    widget.style.display = 'block';
    if(footer) footer.style.display = 'flex';
}

/* === DECK MANAGER LOGIC (FIXED) === */

async function openDeckManager() {
    const list = document.getElementById('deckListContainer');
    list.innerHTML = '<div class="loader-spinner"></div>';
    document.getElementById('deckModal').style.display = 'block';
    
    const promptBox = document.getElementById('deckPromptOutput');
    if(promptBox) {
        promptBox.value = `Erstelle mir eine JSON-Liste mit 20 interessanten Fakten √ºber [THEMA].\nNutze exakt dieses Format (Array von Objekten):\n\n[\n  {\n    "animal": "Tiername",\n    "icon": "ü¶Å",\n    "text": "Der Faktentext...",\n    "tags": ["Tag1", "Tag2"],\n    "source": "Quelle"\n  }\n]`;
    }

    const decks = await dbGetDecks();
    renderDeckList(decks);
}

function renderDeckList(decks) {
    const list = document.getElementById('deckListContainer');
    if(!list) return;
    list.innerHTML = '';

    // 1. Built-in Deck
    const isBuiltInActive = activeDeckIDs.includes('builtin');
    const div = document.createElement('div');
    div.className = `dm-item ${isBuiltInActive ? '' : 'disabled'}`;
    div.innerHTML = `
        <div class="dm-info">
            <span class="dm-title">üì¶ Standard Bibliothek</span>
            <span class="dm-meta">Die integrierten Fakten der App.</span>
        </div>
        <label class="dm-switch switch">
            <input type="checkbox" ${isBuiltInActive ? 'checked' : ''} onchange="toggleDeck('builtin')">
            <span class="slider"></span>
        </label>
    `;
    list.appendChild(div);

    // 2. Custom Decks
    decks.forEach(d => {
        const isActive = activeDeckIDs.includes(d.id);
        const el = document.createElement('div');
        el.className = `dm-item ${isActive ? '' : 'disabled'}`;
        el.innerHTML = `
            <div class="dm-info">
                <span class="dm-title">${d.name}</span>
                <span class="dm-meta">${d.facts.length} Fakten ‚Ä¢ Importiert</span>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
                <div style="color:var(--err-text); cursor:pointer; padding:5px;" onclick="deleteDeck('${d.id}')">üóëÔ∏è</div>
                <label class="dm-switch switch">
                    <input type="checkbox" ${isActive ? 'checked' : ''} onchange="toggleDeck('${d.id}')">
                    <span class="slider"></span>
                </label>
            </div>
        `;
        list.appendChild(el);
    });
}

function toggleDeck(id) {
    if (activeDeckIDs.includes(id)) {
        activeDeckIDs = activeDeckIDs.filter(d => d !== id);
    } else {
        activeDeckIDs.push(id);
    }
    localStorage.setItem('activeDeckIDs', JSON.stringify(activeDeckIDs));
    openDeckManager(); 
    initFactEngine(); // Engine neu laden mit neuer Auswahl!
}

async function importFactDeck(input) {
    if(!input.files[0]) return;
    const file = input.files[0];
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const json = JSON.parse(e.target.result);
            let facts = [], name = file.name.replace('.json', ''), desc = "Importiert am " + new Date().toLocaleDateString();

            if (Array.isArray(json)) facts = json;
            else if (json.facts && Array.isArray(json.facts)) {
                facts = json.facts;
                if(json.meta) { name = json.meta.name || name; desc = json.meta.description || desc; }
            } else throw new Error("Format nicht erkannt.");

            const newDeck = { id: 'deck_' + Date.now(), name: name, description: desc, facts: facts };
            await dbSaveDeck(newDeck);
            activeDeckIDs.push(newDeck.id);
            localStorage.setItem('activeDeckIDs', JSON.stringify(activeDeckIDs));
            
            showErrorToast(`Deck "${name}" importiert!`, true);
            openDeckManager();
            initFactEngine();
            input.value = ''; 
        } catch(err) { showErrorToast("Import Fehler: " + err.message); }
    };
    reader.readAsText(file);
}

async function deleteDeck(id) {
    if(confirm("Deck wirklich l√∂schen?")) {
        await dbDelDeck(id);
        activeDeckIDs = activeDeckIDs.filter(d => d !== id);
        localStorage.setItem('activeDeckIDs', JSON.stringify(activeDeckIDs));
        openDeckManager();
        initFactEngine();
        showErrorToast("Deck gel√∂scht.");
    }
}

// ... Restliche Funktionen (openFactMenu, checkHeartStatus, Library Logic) bleiben erhalten ...

function openFactMenu(e) {
    if(e) e.stopPropagation();
    const items = [
        { label: 'üîç Suchen & Filter', icon: 'üåç', action: 'openLibraryModal()' },
        { label: 'üéõÔ∏è Themen-Wahl', icon: 'üé®', action: 'openFlavorModal()' },
        // NEU: HIER IST DER UMZUG
        { label: 'üóÇÔ∏è Quellen & Decks', icon: 'üìö', action: 'openDeckManager()' },
        // ---
        { label: 'Quiz spielen', icon: 'üéÆ', action: 'startQuiz()' }
    ];
    
    // Positionierung (leicht angepasst, da das Men√º jetzt h√∂her ist)
    let x = e.clientX - 200; 
    let y = e.clientY + 10;
    openContextMenu(x, y, items);
}
// 3. HERZ & SPEICHERN
function checkHeartStatus() {
    const heart = document.getElementById('factHeart');
    if(!currentFactData || !heart) return;
    const isSaved = savedFacts.some(f => f.text === currentFactData.text); 
    
    heart.innerText = isSaved ? '‚ù§Ô∏è' : 'ü§ç';
    heart.style.opacity = isSaved ? '1' : '0.6';
}

function toggleFactLike() {
    if(!currentFactData) return;
    const isSaved = savedFacts.some(f => f.text === currentFactData.text);
    
    if(isSaved) {
        savedFacts = savedFacts.filter(f => f.text !== currentFactData.text);
        showErrorToast("Entfernt");
    } else {
        savedFacts.push(currentFactData);
        showErrorToast("Gespeichert! üìö", true);
        if(navigator.vibrate) navigator.vibrate([50]); 
    }
    localStorage.setItem('savedFacts', JSON.stringify(savedFacts));
    checkHeartStatus();
    updateLibBadge();
    if(document.getElementById('libraryModal').style.display === 'block') renderLibrary();
}

function updateLibBadge() {
    const el = document.getElementById('libCountBadge');
    if(el) el.innerText = savedFacts.length;
}

// 4. LIBRARY MODAL (DRILL DOWN ENGINE)
function openLibraryModal() {
    // Scrollen sperren
    document.body.classList.add('no-scroll');

    // Reset Search State beim √ñffnen
    libSearchState = { query: '', animalFilter: null };
    const searchInp = document.getElementById('libSearchInput');
    if(searchInp) searchInp.value = '';
    
    switchLibTab('saved'); 
    document.getElementById('libraryModal').style.display = 'block';
}
function switchLibTab(tab) {
    activeLibTab = tab;
    document.getElementById('tabSaved').className = `tab-btn ${tab==='saved'?'active':''}`;
    document.getElementById('tabDiscover').className = `tab-btn ${tab==='discover'?'active':''}`;
    renderLibrary();
}

// Input Handler (nur Text-Query updaten)
function handleLibInput() {
    const val = document.getElementById('libSearchInput').value;
    libSearchState.query = val.trim().toLowerCase();
    
    clearTimeout(window.libDebounce);
    window.libDebounce = setTimeout(renderLibrary, 300);
}

// AKTION: Drill-Down in ein Tier
function drillDownToAnimal(animalName) {
    // 1. Filter setzen
    libSearchState.animalFilter = animalName;
    
    // 2. Suche LEEREN (damit man erst alles sieht)
    libSearchState.query = '';
    document.getElementById('libSearchInput').value = '';
    
    // 3. Neu rendern (Chip erscheint, Liste filtert nur dieses Tier)
    renderLibrary();
}

// AKTION: Filter l√∂schen (Chip X geklickt)
function removeAnimalFilter() {
    libSearchState.animalFilter = null;
    renderLibrary();
}

// CORE RENDER FUNCTION

// CORE RENDER FUNCTION FOR LIBRARY
function renderLibrary() {
    const contentBox = document.getElementById('libraryContent');
    const tabsBox = document.getElementById('libSearchTabs');
    const filterCont = document.getElementById('libFilterContainer');
    const loadBtn = document.getElementById('libLoadMoreBtn');
    const emptyState = document.getElementById('libEmptyState');
    const badgeSaved = document.getElementById('badgeSaved');

    // 1. Quelle w√§hlen
    let sourceData = (activeLibTab === 'saved') ? savedFacts : allGlobalFacts;
    if(badgeSaved) badgeSaved.innerText = `(${savedFacts.length})`;

    // Reset UI
    contentBox.innerHTML = '';
    tabsBox.innerHTML = '';
    if(loadBtn) loadBtn.style.display = 'none';
    if(emptyState) emptyState.style.display = 'none';

// Grid-Klasse setzen, au√üer wir zeigen die Tier-Liste
    if (libSearchState.query.length > 0 && libSearchMode === 'animals' && !libSearchState.animalFilter) {
        contentBox.className = ''; // Normale Liste (Block)
    } else {
        contentBox.className = 'masonry-grid-lib'; // Grid
    }

    // === SZENARIO 1: DRILL DOWN (Tier ist ausgew√§hlt) ===
    if (libSearchState.animalFilter) {
        filterCont.style.display = 'block';
        document.getElementById('libActiveFilterName').innerHTML = `ü¶ä ${libSearchState.animalFilter}`;
        
        // Filtern: Nur Fakten dieses Tieres
        let filtered = sourceData.filter(f => f.animal === libSearchState.animalFilter);
        
        // Optional: Suche im Drilldown? (Falls User im Filter noch tippt)
        if (libSearchState.query.length > 0) {
            const q = libSearchState.query;
            filtered = filtered.filter(f => f.text.toLowerCase().includes(q));
        }

        renderFactGrid(filtered, contentBox);
        return; // Fertig
    } 
    
    // Chip ausblenden
    filterCont.style.display = 'none';

    // === SZENARIO 2: SUCHE AKTIV ===
    if (libSearchState.query.length > 0) {
        const q = libSearchState.query;

        // A) Fakten Matches (Text-Suche)
        const factMatches = sourceData.filter(f => 
            f.text.toLowerCase().includes(q) || 
            (f.tags && f.tags.some(t => t.toLowerCase().includes(q)))
        );

        // B) Tier Matches (Name-Suche) -> Unique Liste erstellen
        const animalSet = new Set();
        sourceData.forEach(f => {
            if (f.animal && f.animal.toLowerCase().includes(q)) {
                animalSet.add(f.animal); // Treffer im Tiernamen
            }
            // Optional: Auch Tiere finden, deren Text matched?
            // Nein, das verwirrt. Tabs sollen trennen: "Suche ich das Tier?" vs "Suche ich den Text?"
        });
        const animalMatches = Array.from(animalSet).sort();

        // C) TABS RENDERN
        tabsBox.innerHTML = `
            <div class="lib-search-tabs">
                <div class="lib-tab ${libSearchMode==='animals'?'active':''}" onclick="setLibMode('animals')">
                    üêæ Tiere <span class="lib-tab-count">${animalMatches.length}</span>
                </div>
                <div class="lib-tab ${libSearchMode==='facts'?'active':''}" onclick="setLibMode('facts')">
                    üí° Fakten <span class="lib-tab-count">${factMatches.length}</span>
                </div>
            </div>
        `;

        // D) INHALT RENDERN (Je nach Tab)
        
// ... innerhalb von renderLibrary ...
        
        // D) INHALT RENDERN (Je nach Tab)
        if (libSearchMode === 'animals') {
            if (animalMatches.length === 0) {
                emptyState.style.display = 'block';
                emptyState.innerText = "Keine Tiere mit diesem Namen gefunden.";
            } else {
                // Tier Liste bauen
                animalMatches.forEach(animName => {
                    // Icon suchen (vom ersten Fakt dieses Tieres)
                    const icon = sourceData.find(f => f.animal === animName)?.icon || 'üêæ';
                    
                    const row = document.createElement('div');
                    row.className = 'lib-animal-row fade-in';
                    
                    // HIER DIE √ÑNDERUNG: Text + Pfeil
                    row.innerHTML = `
                        <div class="lib-row-icon">${icon}</div>
                        <div style="font-weight:bold; font-size:15px;">${animName}</div>
                        
                        <!-- Neu: Text "Fakten anzeigen" + Pfeil -->
                        <div style="margin-left:auto; display:flex; align-items:center; gap:6px; font-size:11px; opacity:0.6; font-weight:bold; text-transform:uppercase; letter-spacing:0.5px;">
                            Fakten anzeigen <span style="font-size:16px; color:var(--accent);">‚ûî</span>
                        </div>
                    `;
                    row.onclick = () => drillDownToAnimal(animName);
                    contentBox.appendChild(row);
                });
            } 
        
        // ... Rest der Funktion (else { Grid... }) bleibt gleich
        } else {
            // Fakten Grid
            if (factMatches.length === 0) {
                emptyState.style.display = 'block';
                emptyState.innerText = "Keine Fakten mit diesem Text gefunden.";
            } else {
                renderFactGrid(factMatches, contentBox);
            }
        }
        return;
    }

    // === SZENARIO 3: STANDAR ANSICHT (Keine Suche, kein Filter) ===
    // Einfach Grid anzeigen (Random oder Saved)
    let displayFacts = sourceData;
    
    if (activeLibTab === 'discover') {
        // Random Mix f√ºr Discover
        // (Hier vereinfacht, normalerweise w√ºrde man nicht bei jedem Render neu shufflen, 
        // aber f√ºr die Demo okay. Besser: Shuffle nur beim Tab-Switch speichern)
        displayFacts = [...sourceData].sort(() => 0.5 - Math.random()).slice(0, 20);
        if(loadBtn) {
            loadBtn.style.display = 'block';
            loadBtn.onclick = () => renderLibrary(); // Re-Roll
        }
    } else {
        // Saved: Neueste oben
        displayFacts = [...sourceData].reverse();
    }

    if (displayFacts.length === 0) {
        emptyState.style.display = 'block';
        emptyState.innerText = (activeLibTab === 'saved') ? "Noch keine Fakten gespeichert." : "Datenbank leer.";
    } else {
        renderFactGrid(displayFacts, contentBox);
    }
}

// Helper: Grid rendern (Ausgelagert, da oft genutzt)
function renderFactGrid(facts, container) {
    // Container Grid-Klasse geben
    container.className = 'masonry-grid-lib'; // Falls es √ºberschrieben wurde
    
    facts.forEach((fact, i) => {
        const isSaved = savedFacts.some(sf => sf.text === fact.text);
        const tile = document.createElement('div');
        tile.className = 'lib-tile fade-in';
        tile.style.animationDelay = (i * 0.02) + 's';
        const tagStr = fact.tags ? fact.tags.join(', ') : '';

        tile.innerHTML = `
            <div class="lib-unlike" onclick="toggleFromLib('${fact.text.replace(/'/g, "\\'")}', this)">
                ${isSaved ? '‚ù§Ô∏è' : 'ü§ç'}
            </div>
            <div class="lib-header">
                <div class="lib-icon">${fact.icon || 'üí°'}</div>
                <div>
                    <div style="font-weight:bold; font-size:12px;">${fact.animal || 'Fakt'}</div>
                    <div class="lib-source">${fact.source || fact.deckSource || 'Wissen'}</div>
                </div>
            </div>
            <div class="lib-text">"${fact.text}"</div>
            ${tagStr ? `<div style="margin-top:8px; font-size:10px; opacity:0.5;">üè∑Ô∏è ${tagStr}</div>` : ''}
        `;
        container.appendChild(tile);
    });
    // Grid Klasse nach dem Loop entfernen? Nein, der Container selbst ist das Grid.
    // Aber Achtung: Wenn wir 'lib-animal-row' rendern (oben), darf der Container NICHT 'masonry-grid-lib' sein!
    // FIX: Wir setzen die Klasse dynamisch in der Hauptfunktion.
    // -> In renderLibrary(): contentBox.className = (libSearchMode === 'animals' && isSearching) ? '' : 'masonry-grid-lib';
}

// Helper: Modus wechseln
function setLibMode(mode) {
    libSearchMode = mode;
    renderLibrary();
}

function loadMoreGlobalFacts() { renderLibrary(); } // Dummy f√ºr Refresh

// Herz im Grid
function toggleFromLib(factText, btnEl) {
    let fact = allGlobalFacts.find(f => f.text === factText) || savedFacts.find(f => f.text === factText);
    if(!fact) return;

    const isSaved = savedFacts.some(f => f.text === factText);

    if (isSaved) {
        savedFacts = savedFacts.filter(f => f.text !== factText);
        btnEl.innerText = 'ü§ç';
        showErrorToast("Entfernt");
        if (activeLibTab === 'saved') renderLibrary(); 
    } else {
        savedFacts.push(fact);
        btnEl.innerText = '‚ù§Ô∏è';
        showErrorToast("Gespeichert!", true);
    }
    
    localStorage.setItem('savedFacts', JSON.stringify(savedFacts));
    updateLibBadge();
    checkHeartStatus(); 
}

// 5. FLAVOR / TAG SEARCH ENGINE
function openFlavorModal() {
    // Scrollen sperren
    document.body.classList.add('no-scroll');

    const input = document.getElementById('flavorSearchInput');
    if(input) input.value = '';
    
    renderFlavorAllList(); 
    renderActiveFlavor();  
    
    document.getElementById('flavorModal').style.display = 'block';
}
// Rendert die "Chips" oben (Nur die ausgew√§hlten)
function renderActiveFlavor() {
    const list = document.getElementById('flavorActiveList');
    const wrapper = document.getElementById('flavorActiveWrapper');
    
    list.innerHTML = '';
    
    if (userFlavorTags.length === 0) {
        wrapper.style.display = 'none'; // Ausblenden wenn leer
        return;
    }
    
    wrapper.style.display = 'block';

    userFlavorTags.forEach(tag => {
        const el = document.createElement('div');
        el.className = 'flavor-tag active';
        el.innerHTML = `${tag} <span>‚úï</span>`;
        el.onclick = () => {
            toggleFlavorTag(tag); // Abw√§hlen
        };
        list.appendChild(el);
    });
}

// Rendert die gro√üe, durchsuchbare Liste unten
function renderFlavorAllList() {
    const container = document.getElementById('flavorListContainer');
    const query = document.getElementById('flavorSearchInput').value.toLowerCase();
    container.innerHTML = '';

    // 1. Alle Tags aus der DB sammeln
    const tagMap = new Map(); // Tag -> Anzahl
    
    allGlobalFacts.forEach(f => {
        if(f.tags) {
            f.tags.forEach(t => {
                const count = tagMap.get(t) || 0;
                tagMap.set(t, count + 1);
            });
        }
    });
    
    // 2. Zu Array wandeln & Sortieren (Alphabetisch)
    let allTags = Array.from(tagMap.keys()).sort();

    // 3. Filtern nach Sucheingabe
    if(query.length > 0) {
        allTags = allTags.filter(t => t.toLowerCase().includes(query));
    }

    if(allTags.length === 0) {
        container.innerHTML = '<div style="opacity:0.5; padding:10px; width:100%; text-align:center;">Kein Thema gefunden.</div>';
        return;
    }

    // 4. Liste bauen
    allTags.forEach(tag => {
        const isSelected = userFlavorTags.includes(tag);
        const count = tagMap.get(tag);
        
        const el = document.createElement('div');
        // Neue Klasse f√ºr die Liste
        el.className = `flavor-picker-item ${isSelected ? 'selected' : ''}`;
        
        // Inhalt: Tag-Name + Anzahl
        el.innerHTML = `
            <span>${tag}</span>
            <span style="font-size:10px; opacity:0.6; background:var(--bg); padding:2px 6px; border-radius:8px;">${count}</span>
        `;
        
        el.onclick = () => toggleFlavorTag(tag);
        container.appendChild(el);
    });
}

// Zentrale Toggle Funktion
function toggleFlavorTag(tag) {
    if (userFlavorTags.includes(tag)) {
        userFlavorTags = userFlavorTags.filter(t => t !== tag);
    } else {
        userFlavorTags.push(tag);
    }
    
    // UI sofort updaten (beide Listen)
    renderActiveFlavor();
    renderFlavorAllList(); 
}

function saveFlavorSettings() {
    localStorage.setItem('userFlavorTags', JSON.stringify(userFlavorTags));
    closeModal('flavorModal');
    showErrorToast("Filter gespeichert!", true);
    
    // Sofort anwenden: Neuen Fakt laden
    loadRandomFact(); 
}

function saveFlavorSettings() {
    localStorage.setItem('userFlavorTags', JSON.stringify(userFlavorTags));
    closeModal('flavorModal');
    showErrorToast("Pr√§ferenzen gespeichert!", true);
    loadRandomFact(); 
}

/* === END ENGINE V2.1 === */

function setSearchMode(mode) {
    searchMode = mode;
    render(); // Liste neu zeichnen
}



/* === LEVEL SYSTEM ENGINE === */

// 1. Zentrale XP Berechnung (Damit wir es nicht nur in Stats haben)
function calculateTotalXP() {
    let xp = 0;
    const ys = getAvailableYears();
    
    // Globale Stats sammeln
    let gTot=0, gNote=0, gLoc=new Set(), streak=0;
    
    ys.forEach(y => {
        const h = getHistory(y); 
        Object.values(h).forEach(e => {
            gTot += (e.total||0); 
            if(e.perAnimal) Object.values(e.perAnimal).forEach(l => l.forEach(x => {
                if(x.note) gNote++;
                if(x.location) gLoc.add(x.location);
            }));
        });
    });

    // Streak (Vereinfacht f√ºr global check)
    // Wir nehmen einfach an, renderStats hat streak global gesetzt ODER berechnen es grob
    // Da Streak aufwendig ist, nehmen wir f√ºr den Background-Check nur die "harten" Fakten
    // + gespeicherte Quiz XP
    
    const photoCount = animals.filter(a => a.imageId).length;
    
    // Formel
    xp = (gTot*40) + (gNote*75) + (animals.length*50) + (photoCount*100) + (gLoc.size*25) + (quizXP);
    
    return xp;
}

// 2. Level Index berechnen
function getLevelIndex(xp) {
    let idx = 0;
    for(let i=0; i<levels.length; i++){ 
        if(xp >= levels[i].xp) idx = i; 
        else break; 
    }
    return idx;
}

// 3. PR√úFUNG BEIM START (Das wolltest du!)
function checkLevelProgress() {
    const currentXP = calculateTotalXP();
    const currentLvlIdx = getLevelIndex(currentXP);
    
    // Gespeichertes Level laden (oder -1 beim ersten Mal)
    let lastLvlIdx = parseInt(localStorage.getItem('lastLevelIndex'));
    if (isNaN(lastLvlIdx)) lastLvlIdx = -1; // Init

    // FALL 1: Erster Start √ºberhaupt
    if (lastLvlIdx === -1) {
        // Wir speichern einfach das aktuelle, kein Popup (nervt sonst beim ersten Install)
        localStorage.setItem('lastLevelIndex', currentLvlIdx);
        return;
    }

    // FALL 2: Aufstieg! (Aktuell > Letztes)
    if (currentLvlIdx > lastLvlIdx) {
        // Overlay zeigen!
        showLevelUpOverlay(currentLvlIdx);
        
        // Speichern
        localStorage.setItem('lastLevelIndex', currentLvlIdx);
        
        // Konfetti & Sound
        if(typeof fireConfetti === 'function') setTimeout(fireConfetti, 300);
        if(typeof playSound === 'function') playSound('fanfare');
    }
    
    // FALL 3: Abstieg / Reset (Aktuell < Letztes)
    else if (currentLvlIdx < lastLvlIdx) {
        // Still und heimlich √ºberschreiben, damit beim n√§chsten Aufstieg wieder gefeiert wird
        localStorage.setItem('lastLevelIndex', currentLvlIdx);
    }
    
    // Fall 4: Gleich -> Nichts tun
}

// 4. Das Overlay f√ºllen und zeigen

function showLevelUpOverlay(idx) {
    const lvl = levels[idx];
    if(!lvl) return; // Sicherheits-Check

    // Icon Logik
    let rankIcon = 'üêû'; 
    if (idx >= 2) rankIcon = 'ü¶î';
    if (idx >= 4) rankIcon = 'üå≤'; 
    if (idx >= 6) rankIcon = 'ü¶â';
    if (idx >= 8) rankIcon = 'üê∏';
    if (idx >= 10) rankIcon = 'üê¨';
    if (idx >= 12) rankIcon = 'üêí';
    if (idx >= 14) rankIcon = 'ü¶Å';
    if (idx >= 17) rankIcon = 'ü¶Ö';
    if (idx >= 18) rankIcon = 'üê∫';
    if (idx === 19) rankIcon = 'üëë';

    // Text setzen
    const iconEl = document.getElementById('lvlUpIcon');
    const nameEl = document.getElementById('lvlUpName');
    const descEl = document.getElementById('lvlUpDesc');
    const overEl = document.getElementById('levelUpOverlay');

    if(iconEl) iconEl.innerText = rankIcon;
    if(nameEl) nameEl.innerText = lvl.name;
    if(descEl) descEl.innerText = `Du hast ${lvl.xp.toLocaleString()} XP erreicht!\nDein Rang in der Wildnis ist gestiegen.`;
    
    // Anzeigen (mit !important Hack f√ºr JS, falls CSS bockt)
    if(overEl) {
        overEl.style.setProperty('display', 'flex', 'important');
        // Sound abspielen
        if(typeof playSound === 'function') playSound('fanfare');
    }
}
function closeLevelOverlay() {
    getEl('levelUpOverlay').style.display = 'none';
}

function openInfoModal() {
    getEl('infoModal').style.display = 'block';
}

/* === RETTUNGS-FIX: STORY OPENER === */
window.openStoryModal = function(e) {
    if(e) e.stopPropagation(); // Verhindert, dass andere den Klick klauen
    console.log("Story Ring geklickt!"); // Debug-Info (F12)
    
    const m = document.getElementById('storyModal');
    if(m) {
        m.style.display = 'flex'; 
        // Kurzer Timeout f√ºr die CSS-Transition
        setTimeout(() => m.classList.add('active'), 10);
        
        // Optional: StatusBar schwarz (PWA Trick)
        const meta = document.querySelector('meta[name="theme-color"]');
        if(meta) meta.content = "#000000";
    } else {
        alert("Fehler: Modal #storyModal nicht gefunden!");
    }
};

/* === CLOUD SYNC ENGINE V2 (MULTI-CHANNEL Ntfy Chunking) === */

let syncChannels = JSON.parse(localStorage.getItem('tier_sync_channels')) || [];
let activeSyncId = localStorage.getItem('tier_active_sync_id') || null;
let isSyncing = false;
let abortSyncFlag = false;

// Init beim Start
setTimeout(renderSyncUI, 1000);

// --- UI & MANAGEMENT ---

function renderSyncUI() {
    const sel = document.getElementById('syncChannelSelect');
    if(!sel) return;
    sel.innerHTML = '<option value="" disabled>-- W√§hle Kanal --</option>';
    
    syncChannels.forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch.id;
        // Schloss anzeigen, wenn Passwort gesetzt ist
        opt.innerText = (ch.password ? "üîí " : "") + ch.name; 
        if(ch.id === activeSyncId) opt.selected = true;
        sel.appendChild(opt);
    });
    
    if(syncChannels.length === 0) sel.innerHTML = '<option value="" disabled selected>Keine Kan√§le</option>';
}

function onSyncChannelChange() {
    activeSyncId = document.getElementById('syncChannelSelect').value;
    localStorage.setItem('tier_active_sync_id', activeSyncId);
    // Liste zur√ºcksetzen, da neuer Kanal
    document.getElementById('syncListContainer').style.display = 'none';
}



/* === FIX: Topic L√§nge korrigiert (Max 64 Zeichen total) === */
function generateRandomTopic() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
    
    // Pr√§fix ist 16 Zeichen lang
    let result = 'tierticker-sync-'; 
    
    // Ntfy erlaubt max 64 Zeichen.
    // 64 - 16 (Pr√§fix) = 48 Zeichen Platz maximal.
    // Wir nehmen sicherheitshalber 32 bis 45 Zeichen Zufall.
    const len = 32 + Math.floor(Math.random() * 14); 
    
    const randomValues = new Uint8Array(len);
    crypto.getRandomValues(randomValues);
    
    for (let i = 0; i < len; i++) {
        result += chars[randomValues[i] % chars.length];
    }
    
    // Das Ergebnis in das Input-Feld schreiben
    document.getElementById('newSyncTopic').value = result;
}

/* === EDIT & ADD LOGIC === */

// Variable f√ºr Edit-Modus (oben bei den Globals einf√ºgen oder hier)
// let editingSyncId = null; 

function openAddSyncModal() {
    // RESET: Wir sind im "Neu"-Modus
    editingSyncId = null; 
    
    document.getElementById('newSyncName').value = '';
    document.getElementById('newSyncTopic').value = '';
    document.getElementById('newSyncPass').value = '';
    
    generateRandomTopic(); // Neuen Key vorschlagen
    
    // Modal Titel anpassen (Kosmetik)
    const titleEl = document.querySelector('#syncAddModal h3');
    if(titleEl) titleEl.innerText = "Neuer Sync-Kanal";
    
    document.getElementById('syncAddModal').style.display = 'flex';
}

function copySyncPass() {
    if(!activeSyncId) return;
    const ch = syncChannels.find(c => c.id === activeSyncId);
    
    if(ch && ch.password) {
        navigator.clipboard.writeText(ch.password).then(() => {
            showErrorToast("Passwort kopiert! üîë", true);
        });
    } else {
        showErrorToast("Kein Passwort gesetzt.", true);
    }
}

function editSyncChannel(id) {
    const ch = syncChannels.find(c => c.id === id);
    if(!ch) return;

    // SET: Wir sind im "Bearbeiten"-Modus
    editingSyncId = id;

    // Werte f√ºllen
    document.getElementById('newSyncName').value = ch.name;
    document.getElementById('newSyncTopic').value = ch.topic;
    document.getElementById('newSyncPass').value = ch.password || '';

    // Modal Titel anpassen
    const titleEl = document.querySelector('#syncAddModal h3');
    if(titleEl) titleEl.innerText = "Kanal bearbeiten";

    document.getElementById('syncAddModal').style.display = 'flex';
}

function saveNewSyncChannel() {
    const name = document.getElementById('newSyncName').value.trim();
    const topic = document.getElementById('newSyncTopic').value.trim();
    const password = document.getElementById('newSyncPass').value.trim();
    
    if(!name || topic.length < 10) return alert("Bitte Namen und g√ºltigen Key eingeben.");
    
    if (editingSyncId) {
        // === UPDATE MODE ===
        const idx = syncChannels.findIndex(c => c.id === editingSyncId);
        if(idx !== -1) {
            syncChannels[idx].name = name;
            syncChannels[idx].topic = topic;
            syncChannels[idx].password = password;
            showErrorToast(`Kanal "${name}" aktualisiert!`, true);
        }
    } else {
        // === CREATE MODE ===
        const newCh = { id: 'sync_' + Date.now(), name, topic, password };
        syncChannels.push(newCh);
        activeSyncId = newCh.id; // Neuen direkt ausw√§hlen
        showErrorToast(`Kanal "${name}" erstellt!`, true);
    }
    
    saveSyncConfig();
    renderSyncUI();
    closeModal('syncAddModal');
    
    // Reset Edit State
    editingSyncId = null;
}

function deleteSyncChannel() {
    if(!activeSyncId) return;
    const ch = syncChannels.find(c => c.id === activeSyncId);
    if(confirm(`Kanal "${ch.name}" wirklich aus deiner Liste l√∂schen?`)) {
        syncChannels = syncChannels.filter(c => c.id !== activeSyncId);
        activeSyncId = syncChannels.length > 0 ? syncChannels[0].id : null;
        saveSyncConfig();
        renderSyncUI();
    }
}

function copySyncKey() {
    if(!activeSyncId) return showErrorToast("Kein Kanal gew√§hlt");
    const ch = syncChannels.find(c => c.id === activeSyncId);
    if(ch) {
        navigator.clipboard.writeText(ch.topic).then(() => showErrorToast("Key in Zwischenablage!", true));
    }
}

function saveSyncConfig() {
    localStorage.setItem('tier_sync_channels', JSON.stringify(syncChannels));
    localStorage.setItem('tier_active_sync_id', activeSyncId || '');
}

// --- DATA PREPARATION (PRIVACY FILTER) ---

// WICHTIG: Das hier ersetzt deine bisherige getFullBackupString (falls schon eingebaut)
// === ZENTRALE BACKUP SAMMELSTELLE ===
async function getFullBackupString(forCloud = false) {
    // 1. Historie aller Jahre sammeln
    const fullHistory = {}; 
    getAvailableYears().forEach(y => fullHistory[y] = getHistory(y));

    // 2. Bilder sammeln (Profil & Notizen)
    const images = {};
    const imageIdsToFetch = new Set();
    
    // Profilbilder
    animals.forEach(a => { if(a.imageId) imageIdsToFetch.add(a.imageId); });
    
    // Notizbilder in Historie suchen
    Object.values(fullHistory).forEach(yearData => {
        Object.values(yearData).forEach(dayData => {
            if(dayData.perAnimal) {
                Object.values(dayData.perAnimal).forEach(entries => {
                    entries.forEach(entry => { if(entry.noteImageId) imageIdsToFetch.add(entry.noteImageId); });
                });
            }
        });
    });

    // Bilder aus DB laden
    for(let id of imageIdsToFetch) {
        try {
            const data = await dbGetImg(id);
            if(data) images[id] = data;
        } catch(e) { console.error("Bild-Fehler:", id); }
    }

    // 3. Ranger Funk Nachrichten
    let rfMessages = [];
    try {
        const db = await rfDbPromise;
        rfMessages = await new Promise(r => {
            const req = db.transaction(RF_STORE, 'readonly').objectStore(RF_STORE).getAll();
            req.onsuccess = () => r(req.result); req.onerror = () => r([]);
        });
    } catch(e) {}

    // 4. Custom Decks
    let customDecks = [];
    try { customDecks = await dbGetDecks(); } catch(e) {}

    // 5. Objekt bauen
    const exportObj = { 
        meta: { version: "SYNC-V2-ULTIMATE", date: new Date(), device: navigator.userAgent }, 
        
        // Core Data
        animals, locations, locCoords, fullHistory, images, notifyConfig, 
        
        // Wissen & Decks
        savedFacts, customDecks, activeDeckIDs, userFlavorTags,
        
        // Ranger Funk
        rfChannels, rfMessages,
        
        // NEU: Sync Kan√§le (Nur speichern wenn NICHT Cloud-Upload)
        // forCloud = true  -> Leeres Array (Schutz)
        // forCloud = false -> Echte Liste (Backup)
        syncChannels: forCloud ? [] : syncChannels 
    };

    return JSON.stringify(exportObj);
}

// --- UPLOAD PROCESS ---

async function startCloudPush() {
    const ch = syncChannels.find(c => c.id === activeSyncId);
    if(!ch) return alert("Kein Kanal gew√§hlt!");
    if(isSyncing) return;
    
    if(!confirm(`Backup auf "${ch.name}" hochladen?`)) return;

    try {
        isSyncing = true;
        abortSyncFlag = false;
        
        const modal = document.getElementById('syncProgressModal');
        const bar = document.getElementById('syncBar');
        const status = document.getElementById('syncStatus');
        
        modal.style.display = 'flex';
        document.getElementById('syncTitle').innerText = "Hochladen...";
        bar.style.width = "1%";

        // 1. JSON holen
        status.innerText = "Packe Daten...";
        await new Promise(r => setTimeout(r, 100));
        let payloadString = await getFullBackupString(true); 
        
        // --- NEU: VERSCHL√úSSELUNG ---
        let isEncrypted = false;
        if(ch.password) {
            status.innerText = "üîí Verschl√ºssele Daten...";
            await new Promise(r => setTimeout(r, 100)); // UI Update erlauben
            payloadString = await encryptText(payloadString, ch.password);
            isEncrypted = true;
        }
        // -----------------------------

        // 2. Chunking
        const CHUNK_SIZE = 1.4 * 1024 * 1024; // Etwas kleiner wegen Base64 Overhead
        const totalChunks = Math.ceil(payloadString.length / CHUNK_SIZE);
        const backupID = 'bkp_' + Date.now(); 
        
        // 3. Header senden
        const headerPayload = {
            type: 'tier_sync_header',
            id: backupID,
            chunks: totalChunks,
            size: payloadString.length,
            date: Date.now(),
            device: navigator.platform,
            name: ch.name,
            encrypted: isEncrypted // Flag setzen!
        };
        
        await fetch(`https://ntfy.sh/${ch.topic}`, {
            method: 'PUT', 
            body: JSON.stringify(headerPayload),
            headers: { 'Title': 'TierTicker Sync Header', 'Priority': 'high', 'Content-Type': 'text/plain' }
        });

        // 4. Chunks senden
        for (let i = 0; i < totalChunks; i++) {
            if(abortSyncFlag) throw new Error("Abbruch");

            const start = i * CHUNK_SIZE;
            const end = start + CHUNK_SIZE;
            const chunkData = payloadString.substring(start, end);
            
            const pct = Math.round(((i + 1) / totalChunks) * 100);
            bar.style.width = pct + '%';
            status.innerText = `Sende Paket ${i+1}/${totalChunks}...`;

            await fetch(`https://ntfy.sh/${ch.topic}`, {
                method: 'PUT',
                body: chunkData,
                headers: {
                    'Filename': `${backupID}_part_${i}`,
                    'Title': `Part ${i+1}/${totalChunks}`,
                    'Content-Type': 'text/plain' 
                }
            });

            await new Promise(r => setTimeout(r, 800)); 
        }

        document.getElementById('syncTitle').innerText = "Fertig! ‚úÖ";
        status.innerText = isEncrypted ? "üîí Sicher hochgeladen." : "Hochgeladen.";
        setTimeout(() => { modal.style.display = 'none'; isSyncing = false; }, 1500);

    } catch (e) {
        console.error(e);
        if(!abortSyncFlag) alert("Upload Fehler: " + e.message);
        document.getElementById('syncProgressModal').style.display = 'none';
        isSyncing = false;
    }
}

// --- CHECK & DOWNLOAD PROCESS ---


/* === FINAL FIX: POLL=1 (Kein H√§ngenbleiben mehr) === */
async function checkForCloudBackups() {
    const ch = syncChannels.find(c => c.id === activeSyncId);
    if(!ch) return alert("Kein Kanal gew√§hlt!");
    
    const listCont = document.getElementById('syncListContainer');
    const listItems = document.getElementById('syncListItems');
    
    listCont.style.display = 'block';
    listItems.innerHTML = ''; 
    const logUI = (msg, color='var(--sub)') => {
        console.log("[SYNC]", msg);
        listItems.innerHTML += `<div style="font-size:10px; color:${color}; font-family:monospace; margin-bottom:2px;">> ${msg}</div>`;
    };

    logUI("Verbinde...", "var(--accent)");

    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); 

        // Anfrage mit poll=1
        const response = await fetch(`https://ntfy.sh/${ch.topic}/json?since=12h&poll=1`, {
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let receivedText = "";
        
        logUI("Lade Liste...");

        while (true) {
            const { done, value } = await reader.read();
            if (value) receivedText += decoder.decode(value, { stream: true });
            if (done) break;
        }
        
        const lines = receivedText.trim().split('\n');
        logUI(`${lines.length} Nachrichten geladen.`);
        
        const backups = [];
        let fragmentCount = 0;

        lines.forEach(line => {
            if(!line.trim()) return;
            try {
                const msg = JSON.parse(line);
                if (msg.attachment) fragmentCount++;

                if (msg.event === 'message' && !msg.attachment && msg.message) {
                    let data = null;
                    try { data = JSON.parse(msg.message); } catch(e) {}

                    if (data && data.type === 'tier_sync_header') {
                        backups.push(data);
                    }
                }
            } catch(e) {}
        });

        // UI Leeren und neu aufbauen
        listItems.innerHTML = ''; 

        if (backups.length === 0) {
            if (fragmentCount > 0) {
                listItems.innerHTML = `<div style="color:orange; font-size:12px; padding:10px; text-align:center;">‚ö†Ô∏è <b>Header fehlt!</b><br>${fragmentCount} Dateiteile gefunden.<br>Bitte neu hochladen.</div>`;
            } else {
                listItems.innerHTML = `<div style="opacity:0.5; font-size:12px; padding:10px; text-align:center;">Keine Backups gefunden.</div>`;
            }
        } else {
            backups.sort((a,b) => b.date - a.date);
            backups.forEach(b => {
                const dateObj = new Date(b.date);
                const dateStr = dateObj.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                const dayStr = dateObj.toLocaleDateString();
                const sizeMB = (b.size / (1024*1024)).toFixed(1);
                
                // === HIER IST DER TEIL, DER DICH VERWIRRT HAT ===
                // Wir wandeln den Boolean (true/false) in einen String um ('true'/'false'),
                // damit er im HTML onclick="" Attribut richtig funktioniert.
                const isEncryptedStr = b.encrypted ? 'true' : 'false'; 
                
                const div = document.createElement('div');
                div.className = 'sync-item';
                div.innerHTML = `
                    <div class="sync-item-info">
                        <div class="sync-date">
                            ‚úÖ ${dayStr} ${dateStr} ${b.encrypted ? 'üîí' : ''}
                        </div>
                        <div class="sync-meta">üì¶ ${sizeMB} MB ‚Ä¢ ${b.chunks} Teile ‚Ä¢ ${b.name || 'Ger√§t'}</div>
                    </div>
                    <!-- Hier wird der String √ºbergeben -->
                    <button onclick="restoreFromCloud('${b.id}', ${b.chunks}, ${isEncryptedStr})" style="background:var(--accent); color:white; border:none; padding:6px 12px; border-radius:15px; font-size:12px; font-weight:bold; cursor:pointer;">üì• Laden</button>
                `;
                listItems.appendChild(div);
            });
        }

    } catch (e) {
        listItems.innerHTML = `<div style="color:var(--err-text); padding:10px; text-align:center;">Fehler: ${e.message}</div>`;
    }
}

    
/* === FIX: RESTORE MIT POLL=1 (Kein H√§ngenbleiben) === */
/* === RESTORE MIT DECRYPTION === */
async function restoreFromCloud(backupId, totalParts, isEncrypted) {
    const ch = syncChannels.find(c => c.id === activeSyncId);
    if(isSyncing || !ch) return;
    
    // Sicherheits-Check
    if(isEncrypted && !ch.password) {
        return alert("Dieses Backup ist verschl√ºsselt! üîí\nDu hast f√ºr diesen Kanal aber kein Passwort hinterlegt.\nBitte Kanal bearbeiten (l√∂schen/neu) und Passwort setzen.");
    }

    isSyncing = true;
    abortSyncFlag = false;

    const modal = document.getElementById('syncProgressModal');
    const bar = document.getElementById('syncBar');
    const status = document.getElementById('syncStatus');
    
    modal.style.display = 'flex';
    document.getElementById('syncTitle').innerText = "Lade Daten...";
    bar.style.width = "0%";

    try {
        status.innerText = "Suche Pakete...";
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000);

        const response = await fetch(`https://ntfy.sh/${ch.topic}/json?since=12h&poll=1`, {
            signal: controller.signal
        });
        clearTimeout(timeoutId);

        if (!response.ok) throw new Error("Verbindungsfehler");

        const text = await response.text();
        const lines = text.trim().split('\n');
        let foundParts = [];

        lines.forEach(line => {
            try {
                const msg = JSON.parse(line);
                if (msg.attachment && msg.attachment.name.startsWith(backupId)) {
                    const parts = msg.attachment.name.split('_part_');
                    const index = parseInt(parts[1]);
                    foundParts.push({ index: index, url: msg.attachment.url });
                }
            } catch(e) {}
        });

        if (foundParts.length < totalParts) throw new Error(`Nur ${foundParts.length}/${totalParts} Teile gefunden.`);

        foundParts.sort((a,b) => a.index - b.index);
        let rawDataString = "";

        for (let i = 0; i < foundParts.length; i++) {
            if(abortSyncFlag) throw new Error("Abbruch");
            status.innerText = `Lade Paket ${i+1}/${totalParts}...`;
            bar.style.width = Math.round(((i) / totalParts) * 100) + '%';

            const chunkRes = await fetch(foundParts[i].url);
            rawDataString += await chunkRes.text();
            await new Promise(r => setTimeout(r, 50));
        }

        // --- ENTSCHL√úSSELN ---
        if(isEncrypted) {
            status.innerText = "üîì Entschl√ºssele...";
            await new Promise(r => setTimeout(r, 100)); // UI Render
            try {
                rawDataString = await decryptText(rawDataString, ch.password);
            } catch(e) {
                throw new Error("Falsches Passwort! Entschl√ºsselung fehlgeschlagen.");
            }
        }
        // ----------------------

        status.innerText = "Verarbeite...";
        tempImportData = JSON.parse(rawDataString);
        
        modal.style.display = 'none';
        isSyncing = false;
        
        getEl('importModal').style.display = 'block';
        showErrorToast("Daten bereit!", true);

    } catch (e) {
        alert("Fehler: " + e.message);
        modal.style.display = 'none';
        isSyncing = false;
    }
}

function abortSync() {
    abortSyncFlag = true;
    document.getElementById('syncProgressModal').style.display = 'none';
    isSyncing = false;
    showErrorToast("Abgebrochen");
}

// === WICHTIG: UPDATE DER ORIGINALEN DOWNLOAD FUNKTION ===
// Diese Funktion musst du in deinem Code FINDEN und ERSETZEN,
// damit beim lokalen Backup die Sync-Kan√§le mitgespeichert werden!

async function downloadBackup() {
    showErrorToast("Erstelle Full-Backup...", true);
    
    try {
        // Hier rufen wir den Sammler auf. 
        // false = Wir wollen ALLES, auch die Sync-Kan√§le, weil es eine lokale Datei ist.
        const jsonString = await getFullBackupString(false); 
        
        const blob = new Blob([jsonString], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); 
        a.download = `tier-ticker-ultimate-backup-${todayStr()}.json`; 
        a.click();
        
        localStorage.setItem('lastBackup', Date.now()); 
        if(typeof checkBackupHealth === 'function') checkBackupHealth(); 
        showErrorToast("Datei-Backup erstellt üíæ", true);
        
    } catch(err) {
        console.error(err);
        showErrorToast("Fehler beim Backup erstellen!");
    }
}

function importBackup(e){
    const file = e.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = evt => { try { tempImportData = JSON.parse(evt.target.result); getEl('importModal').style.display='block'; } catch(err) { showErrorToast("Datei besch√§digt"); } };
    reader.readAsText(file);
}

 
async function confirmImport(mode) {
    getEl('importModal').style.display = 'none';
    if (mode === 'cancel') return;

    try {
        const d = tempImportData;
        showErrorToast("Import l√§uft... Bitte warten.", true);

        // --- 1. VORBEREITUNG (Nur bei Overwrite) ---
        if (mode === 'overwrite') {
            // A) SYNC KAN√ÑLE RETTEN! (Wichtig!)
            const savedChannels = localStorage.getItem('tier_sync_channels');
            const savedActiveId = localStorage.getItem('tier_active_sync_id');

            // B) LocalStorage leeren
            localStorage.clear();

            // C) SYNC KAN√ÑLE WIEDERHERSTELLEN
            if(savedChannels) localStorage.setItem('tier_sync_channels', savedChannels);
            if(savedActiveId) localStorage.setItem('tier_active_sync_id', savedActiveId);
            
            // Globale Variablen im Speicher aktualisieren, damit die App nicht crasht
            syncChannels = savedChannels ? JSON.parse(savedChannels) : [];
            activeSyncId = savedActiveId || null;

            // D) DATENBANKEN LEEREN (Bilder, Funk, Decks)
            const db = await dbPromise;
            // Wichtig: Wir warten (await) auf den Abschluss!
            const txImg = db.transaction(STORE_IMGS, 'readwrite');
            await txImg.objectStore(STORE_IMGS).clear();
            await new Promise(r => { txImg.oncomplete = r; txImg.onerror = r; });

            const txDeck = db.transaction(STORE_DECKS, 'readwrite');
            await txDeck.objectStore(STORE_DECKS).clear();
            await new Promise(r => { txDeck.oncomplete = r; txDeck.onerror = r; });
            
            // Funk DB leeren
            try {
                const rfDb = await rfDbPromise;
                const txRf = rfDb.transaction(RF_STORE, 'readwrite');
                await txRf.objectStore(RF_STORE).clear();
                await new Promise(r => { txRf.oncomplete = r; txRf.onerror = r; });
            } catch(e) { console.log("Funk DB leer/nicht da"); }
        }

        // --- 2. DB INHALTE WIEDERHERSTELLEN ---
        // Bilder importieren
        if (d.images) {
            for (let [id, data] of Object.entries(d.images)) await dbSaveImg(id, data);
        }
        // Ranger Funk Messages
        if (d.rfMessages) {
            const rfStore = (await rfDbPromise).transaction(RF_STORE, 'readwrite').objectStore(RF_STORE);
            for (let m of d.rfMessages) await rfStore.put(m);
        }
        // Decks
        if (d.customDecks) {
            for (let deck of d.customDecks) await dbSaveDeck(deck);
        }

        // --- 3. LOCALSTORAGE DATEN ---
        if (mode === 'overwrite') {
            // Alles √ºberschreiben (au√üer Sync Kan√§le, die sind schon da)
            animals = d.animals || [];
            locations = d.locations || [];
            locCoords = d.locCoords || {};
            notifyConfig = d.notifyConfig || { enabled: false, days: 7 };
            savedFacts = d.savedFacts || [];
            rfChannels = d.rfChannels || [];
            userFlavorTags = d.userFlavorTags || [];
            trashBin = []; 

            // Historie schreiben
            if (d.fullHistory) {
                Object.entries(d.fullHistory).forEach(([y, h]) => saveHistory(y, h));
            }

            // Configs
            localStorage.setItem('activeDeckIDs', JSON.stringify(d.activeDeckIDs || ['builtin']));
            
        } else {
            // --- MERGE MODE (Wie gehabt) ---
            d.animals?.forEach(impA => {
                if (!animals.some(a => a.name === impA.name)) animals.push(impA);
            });
            d.locations?.forEach(l => {
                if (!locations.includes(l)) locations.push(l);
            });
            d.savedFacts?.forEach(sf => {
                if (!savedFacts.some(local => local.text === sf.text)) savedFacts.push(sf);
            });
            d.rfChannels?.forEach(ch => {
                if (!rfChannels.some(local => local.topic === ch.topic)) rfChannels.push(ch);
            });
            
            // Sync Channels mergen (falls im Backup welche waren - optional)
            if(d.syncChannels && Array.isArray(d.syncChannels)) {
                d.syncChannels.forEach(ch => {
                    if (!syncChannels.some(local => local.topic === ch.topic)) syncChannels.push(ch);
                });
            }

            // Historie mergen
            if (d.fullHistory) {
                for (let yearData of Object.values(d.fullHistory)) {
                    for (let [dateStr, dayContent] of Object.entries(yearData)) {
                        if (dayContent.perAnimal) {
                            for (let [idxStr, list] of Object.entries(dayContent.perAnimal)) {
                                let targetIdx = parseInt(idxStr);
                                if (d.animals && d.animals[idxStr]) {
                                    const impName = d.animals[idxStr].name;
                                    const localIdx = animals.findIndex(a => a.name === impName);
                                    if (localIdx !== -1) targetIdx = localIdx;
                                }
                                for (let item of list) {
                                    const y = dateStr.split('-')[0];
                                    const h = getHistory(y);
                                    let exists = h[dateStr]?.perAnimal?.[targetIdx]?.some(ex => 
                                        ex.time === item.time && ex.location === item.location
                                    );
                                    if (!exists) writeEntry(dateStr, targetIdx, item);
                                }
                            }
                        }
                    }
                }
            }
        }

        // --- 4. FINALE SPEICHERUNG ---
        saveGlobals();
        localStorage.setItem('ranger_channels', JSON.stringify(rfChannels));
        // WICHTIG: Sync Channels auch wieder speichern (falls Merge neue gebracht hat)
        localStorage.setItem('tier_sync_channels', JSON.stringify(syncChannels));
        localStorage.setItem('userFlavorTags', JSON.stringify(userFlavorTags));
        localStorage.setItem('savedFacts', JSON.stringify(savedFacts));

        showErrorToast("Import erfolgreich! App wird neu geladen...", true);
        setTimeout(() => location.reload(), 1000);

    } catch (e) {
        console.error("Import Fehler:", e);
        showErrorToast("Fehler: " + e.message);
    }
}

// Cloud Engine (Ntfy Chunking) Ende

/* === CRYPTO ENGINE (FIXED FOR LARGE FILES) === */

const enc = new TextEncoder();
const dec = new TextDecoder();

// Helper: Blob zu Base64 (Verhindert Stack Overflow bei gro√üen Dateien)
function bufferToBase64(buffer) {
    return new Promise((resolve) => {
        const blob = new Blob([buffer]);
        const reader = new FileReader();
        reader.onload = () => {
            // "data:application/octet-stream;base64,....." -> Nur den Teil nach dem Komma nehmen
            const base64 = reader.result.split(',')[1];
            resolve(base64);
        };
        reader.readAsDataURL(blob);
    });
}

// 1. Schl√ºssel ableiten
async function getKey(password, salt) {
    const keyMaterial = await window.crypto.subtle.importKey(
        "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
    );
    return window.crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
        keyMaterial, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
    );
}

// 2. VERSCHL√úSSELN (Robust)
async function encryptText(text, password) {
    const salt = window.crypto.getRandomValues(new Uint8Array(16));
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const key = await getKey(password, salt);
    
    const encrypted = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", iv: iv }, key, enc.encode(text)
    );

    // Zusammenbauen: Salt (16) + IV (12) + Content
    const buffer = new Uint8Array(salt.byteLength + iv.byteLength + encrypted.byteLength);
    buffer.set(salt, 0);
    buffer.set(iv, 16);
    buffer.set(new Uint8Array(encrypted), 28);

    // HIER WAR DER FEHLER: Statt String.fromCharCode nutzen wir jetzt den FileReader
    return await bufferToBase64(buffer);
}

// 3. ENTSCHL√úSSELN
async function decryptText(base64Data, password) {
    try {
        // Base64 zu Binary zur√ºckwandeln
        const binaryStr = atob(base64Data);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
            bytes[i] = binaryStr.charCodeAt(i);
        }

        // Extrahieren
        const salt = bytes.slice(0, 16);
        const iv = bytes.slice(16, 28);
        const data = bytes.slice(28);

        const key = await getKey(password, salt);
        
        const decrypted = await window.crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv }, key, data
        );

        return dec.decode(decrypted);
    } catch (e) {
        console.error(e);
        throw new Error("Entschl√ºsselung fehlgeschlagen (Falsches Passwort?)");
    }
}

function setAppMode(mode) {
    // Toggle Logik: Wenn man auf den aktiven Modus klickt, zur√ºck zu Tieren
    if (appMode === mode && mode !== 'animals') {
        appMode = 'animals';
    } else {
        appMode = mode;
    }
    
    // Feedback
    let text = "Ansicht: Tiere";
    if (appMode === 'notes') text = "Ansicht: Notizen";
    if (appMode === 'gallery') text = "Ansicht: Galerie";
    showFeedback(text);
    
    render();
}

function cycleAppMode() {
    // Zyklus: Tiere -> Notizen -> Fotos -> Tiere
    if (appMode === 'animals') {
        appMode = 'notes';
    } else if (appMode === 'notes') {
        appMode = 'gallery';
    } else {
        appMode = 'animals';
    }
    
    render(); // Aktualisiert Liste und Button-Text
}

/* === SYNC CONTEXT MENU === */
function openSyncChannelMenu(event) {
    if(!activeSyncId) return showErrorToast("Kein Kanal ausgew√§hlt!");
    
    const ch = syncChannels.find(c => c.id === activeSyncId);
    if(!ch) return;

    // Men√º Eintr√§ge definieren
    const items = [
        { 
            label: 'Bearbeiten', 
            icon: '‚úèÔ∏è', 
            action: `editSyncChannel('${ch.id}')` 
        },
        { 
            label: 'Kanal-Key kopieren', 
            icon: 'üìã', 
            action: `copySyncKey()` 
        },
        { 
            label: 'Passwort kopieren', 
            icon: 'üîë', 
            action: `copySyncPass()` 
        },
        { 
            label: 'L√∂schen', 
            icon: 'üóëÔ∏è', 
            action: `deleteSyncChannel()`, 
            danger: true 
        }
    ];

    // Positionierung des Men√ºs
    let x = event.clientX || (event.touches ? event.touches[0].clientX : 0);
    let y = event.clientY || (event.touches ? event.touches[0].clientY : 0);
    
    // Fallback falls Klick komisch war
    if(x === 0 && y === 0) { 
        const rect = event.target.getBoundingClientRect();
        x = rect.left; y = rect.bottom;
    }

    openContextMenu(x, y, items);
}

// === TIME FILTER UI LOGIC ===
function toggleTimePanel() {
    const p = document.getElementById('timeFilterPanel');
    const inputStart = document.getElementById('tfStart');
    const inputEnd = document.getElementById('tfEnd');
    
    if (p.style.display === 'block') {
        p.style.display = 'none';
    } else {
        // Werte beim √ñffnen setzen
        inputStart.value = timeFilter.start;
        inputEnd.value = timeFilter.end;
        p.style.display = 'block';
    }
}

function saveTimeFilter() {
    const s = document.getElementById('tfStart').value;
    const e = document.getElementById('tfEnd').value;
    
    timeFilter = { start: s, end: e };
    localStorage.setItem('timeFilter', JSON.stringify(timeFilter));
    
    render(); // Liste neu laden!
}

function resetTimeFilter(e) {
    if(e) e.stopPropagation(); // Damit Panel nicht aufgeht
    timeFilter = { start: '', end: '' };
    localStorage.setItem('timeFilter', JSON.stringify(timeFilter));
    document.getElementById('timeFilterPanel').style.display = 'none';
    render();
    showErrorToast("Zeitfilter entfernt: Zeige alles", true);
}

function applyTimeFilterPreset(mode) {
    const now = new Date();
    const y = now.getFullYear();
    const m = String(now.getMonth() + 1).padStart(2, '0');
    const d = String(now.getDate()).padStart(2, '0');
    const today = `${y}-${m}-${d}`;
    
    if (mode === 'today') {
        timeFilter = { start: today, end: today };
    } else if (mode === 'month') {
        timeFilter = { start: `${y}-${m}-01`, end: `${y}-${m}-${new Date(y, now.getMonth()+1, 0).getDate()}` };
    } else if (mode === 'year') {
        timeFilter = { start: `${y}-01-01`, end: `${y}-12-31` };
    }
    
    localStorage.setItem('timeFilter', JSON.stringify(timeFilter));
    
    // UI Inputs updaten
    document.getElementById('tfStart').value = timeFilter.start;
    document.getElementById('tfEnd').value = timeFilter.end;
    
    render();
}

/* === MICRO MENU LOGIC === */

// √ñffnet/Schlie√üt ein Men√º und schlie√üt alle anderen
function toggleMicroMenu(id) {
    const menus = ['menu-view', 'menu-mode', 'menu-sort'];
    
    menus.forEach(mId => {
        const m = document.getElementById(mId);
        const btn = document.getElementById(mId.replace('menu-', 'btn-'));
        
        if (mId === id) {
            // Togglen
            if (m.classList.contains('show')) {
                m.classList.remove('show');
                btn.classList.remove('is-open');
            } else {
                m.classList.add('show');
                btn.classList.add('is-open');
            }
        } else {
            // Andere schlie√üen
            m.classList.remove('show');
            btn.classList.remove('is-open');
        }
    });
}

// Globaler Klick-Listener: Schlie√üt Men√ºs, wenn man daneben klickt
document.addEventListener('click', function(e) {
    if (!e.target.closest('.micro-btn-wrap')) {
        document.querySelectorAll('.micro-menu').forEach(el => el.classList.remove('show'));
        document.querySelectorAll('.micro-btn').forEach(el => el.classList.remove('is-open'));
    }
});

/* --- ACTIONS --- */

function setMicroView(mode) {
    viewMode = mode;
    localStorage.setItem('viewMode', mode);
    updateMicroUI();
    render();
    toggleMicroMenu('close-all'); // Schlie√üen erzwingen
}

function setMicroMode(mode) {
    appMode = mode;
    updateMicroUI();
    render();
    toggleMicroMenu('close-all');
}

function setMicroSort(mode) {
    sortMode = mode;
    localStorage.setItem('sortMode', mode);
    updateMicroUI();
    render();
    toggleMicroMenu('close-all');
}

/* --- UI UPDATE HELPER --- */
// Aktualisiert die Button-Beschriftungen und Selection-States
function updateMicroUI() {
    // 1. VIEW
    const lblView = document.getElementById('lbl-view');
    if(lblView) lblView.innerText = (viewMode === 'grid') ? 'GRID' : 'LIST';
    
    // 2. MODE
    const lblMode = document.getElementById('lbl-mode');
    if(lblMode) {
        if(appMode === 'animals') lblMode.innerText = 'TIERE';
        else if(appMode === 'notes') lblMode.innerText = 'NOTIZ';
        else if(appMode === 'gallery') lblMode.innerText = 'FOTOS';
    }

    // 3. SORT
    const lblSort = document.getElementById('lbl-sort');
    if(lblSort) {
        if(sortMode === 'fav') lblSort.innerText = '‚òÖ';
        else if(sortMode === 'last') lblSort.innerText = 'NEU';
        else if(sortMode === 'name') lblSort.innerText = 'A-Z';
        else lblSort.innerText = '1-9';
    }

    // Highlighting im Men√º (Optional, aber schick)
    // Entfernt 'selected' von allen und setzt es neu (Logik vereinfacht)
    document.querySelectorAll('.mm-item').forEach(el => el.classList.remove('selected'));
    // (Hier k√∂nnte man noch spezifische Klassen pro Item setzen, 
    // aber das Feedback im Button reicht meistens aus)
}

// Start-Check
setTimeout(() => { startTutorial(); }, 1500);

// STARTUP
loadGlobals(); render(); initSwipeGestures();


</script>

<script>
function rfEscape(str) {
    if (!str) return "";
    const p = document.createElement('p');
    p.textContent = str; // Wandelt <script> in &lt;script&gt; um
    return p.innerHTML;
}

/* === ULTIMATE PIXEL GAME ENGINE (DYNAMIC HTML FIX) === */

// 1. STYLES (Sofort laden)
(function injectPixelStyles() {
    const style = document.createElement('style');
    style.innerHTML = `
        #pixelModal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); z-index: 20000; 
            display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); 
        }
        .px-content { 
            background: #1a1a1a; color: white; border: 1px solid #444; 
            border-radius: 16px; padding: 20px; width: 90%; max-width: 500px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.5); 
            position: relative;
        }
        .px-game-area {
            position: relative; width: 100%; height: 280px; background: #000; 
            border-radius: 12px; overflow: hidden; margin: 15px 0; box-shadow: 0 0 20px rgba(189, 147, 249, 0.2);
        }
        .px-tile { background: #111; border: 1px solid #222; transition: opacity 0.2s, transform 0.2s; }
        .px-tile.hidden { opacity: 0; transform: scale(0); }
        .px-btn { 
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); 
            padding: 12px; border-radius: 10px; color: white; font-weight: bold; cursor: pointer; transition: 0.1s; font-size: 13px;
        }
        .px-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }
        .px-btn.correct { background: #4cd137 !important; color: #000; border-color: #4cd137; }
        .px-btn.wrong { background: #ff4757 !important; opacity: 0.4; }
        
        .px-mode-card {
            cursor: pointer; text-align: center; padding: 10px; border-radius: 10px; transition: background 0.2s;
        }
        .px-mode-card:active { background: rgba(255,255,255,0.1); }
        .px-mode-icon {
            font-size: 28px; width: 50px; height: 50px; background: rgba(255,255,255,0.1);
            border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 5px auto;
        }
    `;
    document.head.appendChild(style);
})();

// Global State
window.pxState = { timer: null, step: 0, maxSteps: 20, currentAnimal: null, mode: 'blur', imgObj: null };

// 1. Hilfsfunktion: Sammelt ALLE Bilder
window.getAllPixelCandidates = function() {
    let pool = [];
    if(typeof animals !== 'undefined') {
        animals.forEach((a, i) => {
            if(a.imageId) pool.push({ name: a.name, imgId: a.imageId, type: 'Profilbild' });
        });
    }
    if(typeof getAvailableYears === 'function' && typeof getHistory === 'function') {
        const years = getAvailableYears();
        years.forEach(y => {
            const h = getHistory(y);
            Object.values(h).forEach(day => {
                if(day.perAnimal) {
                    Object.entries(day.perAnimal).forEach(([idxStr, entries]) => {
                        const idx = parseInt(idxStr);
                        const animal = animals[idx];
                        if(animal) {
                            entries.forEach(entry => {
                                if(entry.noteImageId) {
                                    pool.push({ name: animal.name, imgId: entry.noteImageId, type: 'Notiz-Foto' });
                                }
                            });
                        }
                    });
                }
            });
        });
    }
    return pool;
};

// 2. √ñffnen (MIT AUTOMATISCHEM HTML BAU)
window.openPixelQuiz = function() {
    console.log("Starte Pixel-J√§ger...");

    const candidates = window.getAllPixelCandidates();
    if (candidates.length < 3) {
        alert(`Zu wenig Fotos!\n\nDu hast aktuell nur ${candidates.length} Fotos.\nDu brauchst mindestens 3 verschiedene Fotos (Profil oder Notizen), um zu spielen.`);
        return;
    }

    // === HIER IST DER FIX: MODAL BAUEN WENN ES FEHLT ===
    let modal = document.getElementById('pixelModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'pixelModal';
        modal.innerHTML = `
            <div class="px-content">
                <div style="position:absolute; top:15px; right:15px; cursor:pointer; font-size:20px; font-weight:bold;" onclick="document.getElementById('pixelModal').style.display='none'">‚úï</div>
                
                <div style="margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:10px;">
                    <span style="font-size:24px">üì∏</span> 
                    <span style="color:#bd93f9; font-weight:900; letter-spacing:1px; text-transform:uppercase;">Pixel J√§ger</span>
                </div>

                <div class="px-game-area">
                    <canvas id="pxCanvas" width="600" height="400" style="width:100%; height:100%; object-fit:contain; display:none;"></canvas>
                    <div id="pxTileGrid" style="position:absolute; top:0; left:0; width:100%; height:100%; display:none; grid-template-columns:repeat(4, 1fr); grid-template-rows:repeat(4, 1fr);"></div>
                    
                    <!-- Start Overlay -->
                    <div id="pxOverlay" style="position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:10;">
                        <p style="margin-bottom:20px; font-weight:bold;">W√§hle Modus:</p>
                        <div style="display:flex; gap:15px;">
                            <div class="px-mode-card" onclick="window.startPixelGame('blur')">
                                <div class="px-mode-icon">üå´Ô∏è</div><div>Nebel</div>
                            </div>
                            <div class="px-mode-card" onclick="window.startPixelGame('pixel')">
                                <div class="px-mode-icon">üëæ</div><div>8-Bit</div>
                            </div>
                            <div class="px-mode-card" onclick="window.startPixelGame('tiles')">
                                <div class="px-mode-icon">üß±</div><div>Kacheln</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="pxOptions" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;"></div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    // ====================================================

    // UI Reset
    document.getElementById('pxOverlay').style.display = 'flex';
    document.getElementById('pxCanvas').style.display = 'none';
    document.getElementById('pxTileGrid').style.display = 'none';
    document.getElementById('pxOptions').innerHTML = '';
    
    // Anzeigen
    modal.style.display = 'flex';
};

// 3. Spiel Start
window.startPixelGame = async function(mode) {
    const candidates = window.getAllPixelCandidates();
    if (candidates.length < 3) { alert("Zu wenig Bilder."); return; }

    window.pxState.mode = mode;
    window.pxState.step = 0;
    
    const targetItem = candidates[Math.floor(Math.random() * candidates.length)];
    window.pxState.currentAnimal = { name: targetItem.name };

    console.log(`Quiz Ziel: ${targetItem.name} (${targetItem.type})`);

    try {
        const src = await dbGetImg(targetItem.imgId);
        if(!src) throw new Error("Bilddaten leer");
        const img = new Image();
        img.src = src;
        await new Promise(r => img.onload = r);
        window.pxState.imgObj = img;
    } catch(e) {
        alert("Fehler beim Laden des Bildes."); return;
    }

    document.getElementById('pxOverlay').style.display = 'none';
    const canvas = document.getElementById('pxCanvas');
    const grid = document.getElementById('pxTileGrid');
    canvas.width = 600; canvas.height = 400; 
    
    if (mode === 'tiles') {
        canvas.style.display = 'block'; grid.style.display = 'grid'; grid.innerHTML = '';
        const ctx = canvas.getContext('2d');
        window.pxDrawContain(ctx, window.pxState.imgObj, canvas.width, canvas.height);
        for(let i=0; i<16; i++) { const t = document.createElement('div'); t.className = 'px-tile'; grid.appendChild(t); }
        window.pxState.maxSteps = 16;
    } else {
        grid.style.display = 'none'; canvas.style.display = 'block'; window.pxState.maxSteps = 20;
    }

    window.pxGenerateOptions(window.pxState.currentAnimal);
    clearInterval(window.pxState.timer);
    window.pxRenderFrame(); 
    window.pxState.timer = setInterval(window.pxRenderFrame, 800); 
};

// 4. Render Loop (Optimierte Geschwindigkeit)
window.pxRenderFrame = function() {
    const s = window.pxState;
    const canvas = document.getElementById('pxCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width; const h = canvas.height;

    s.step++;
    if (s.step > s.maxSteps) { clearInterval(s.timer); window.pxDrawContain(ctx, s.imgObj, w, h); return; }

    if (s.mode === 'blur') {
        const blurAmount = Math.max(0, 60 - (s.step * 5));
        ctx.clearRect(0,0,w,h); ctx.filter = `blur(${blurAmount}px)`;
        window.pxDrawContain(ctx, s.imgObj, w, h); ctx.filter = 'none';
    } 
    else if (s.mode === 'pixel') {
        const percent = s.step / s.maxSteps; 
        const scale = 0.02 + (Math.pow(percent, 2) * 0.98); 
        ctx.imageSmoothingEnabled = false; ctx.clearRect(0,0,w,h);
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = Math.max(4, Math.floor(w * scale)); 
        tmpCanvas.height = Math.max(4, Math.floor(h * scale));
        const tCtx = tmpCanvas.getContext('2d');
        window.pxDrawContain(tCtx, s.imgObj, tmpCanvas.width, tmpCanvas.height);
        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvas.width, tmpCanvas.height, 0, 0, w, h);
    }
    else if (s.mode === 'tiles') {
        const remaining = Array.from(document.querySelectorAll('.px-tile:not(.hidden)'));
        if (remaining.length > 0) remaining[Math.floor(Math.random() * remaining.length)].classList.add('hidden');
    }
};

window.pxDrawContain = function(ctx, img, cw, ch) {
    const scale = Math.min(cw / img.width, ch / img.height);
    const x = (cw / 2) - (img.width / 2) * scale;
    const y = (ch / 2) - (img.height / 2) * scale;
    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
};

window.pxGenerateOptions = function(target) {
    const box = document.getElementById('pxOptions');
    box.innerHTML = '';
    const wrongs = animals.filter(a => a.name !== target.name).sort(() => 0.5 - Math.random()).slice(0, 3);
    const opts = [target, ...wrongs].sort(() => 0.5 - Math.random());
    opts.forEach(a => {
        const btn = document.createElement('div');
        btn.className = 'px-btn'; btn.innerText = a.name;
        btn.onclick = () => window.pxCheck(btn, a.name === target.name);
        box.appendChild(btn);
    });
};

window.pxCheck = function(btn, isCorrect) {
    if (document.getElementById('pxOptions').style.pointerEvents === 'none') return;
    const s = window.pxState;
    clearInterval(s.timer); 
    const canvas = document.getElementById('pxCanvas');
    const ctx = canvas.getContext('2d');
    ctx.filter = 'none'; ctx.imageSmoothingEnabled = true;
    window.pxDrawContain(ctx, s.imgObj, canvas.width, canvas.height);
    document.querySelectorAll('.px-tile').forEach(t => t.classList.add('hidden'));
    
    document.getElementById('pxOptions').style.pointerEvents = 'none'; 

    if (isCorrect) {
        btn.classList.add('correct');
        if(typeof playSound === 'function') playSound('pop');
        const pts = Math.max(10, 100 - (s.step * 4));
        quizXP += pts; localStorage.setItem('quizXP', quizXP);
        setTimeout(() => { 
            document.getElementById('pxOptions').style.pointerEvents = 'auto';
            document.getElementById('pxOverlay').style.display = 'flex'; 
        }, 1500);
    } else {
        btn.classList.add('wrong');
        if(navigator.vibrate) navigator.vibrate(200);
        setTimeout(() => { 
            document.getElementById('pxOptions').style.pointerEvents = 'auto';
            document.getElementById('pxOverlay').style.display = 'flex'; 
        }, 2000);
    }
};
</script>
</body>
</html>
